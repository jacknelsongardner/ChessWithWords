var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _WebViewHook_hookId, _WebViewHook_url, _WebViewHook_onMessage, _WebViewHook_onUnmount, _WebViewHook_renderContext, _WebViewHook_invalidate, _WebViewHook_emitFullscreenEffect;
import { EffectType } from '@devvit/protos';
import { WebViewVisibility } from '@devvit/protos';
import { apiPathPrefix } from '@devvit/shared-types/constants.js';
import { StringUtil } from '@devvit/shared-types/StringUtil.js';
import { webViewMessageIsInternalAndClientScope } from '../../helpers/devvitInternalMessage.js';
import { registerHook } from './BlocksHandler.js';
class WebViewHook {
    constructor(params, options) {
        this.state = { messageCount: 0, isMounted: false };
        _WebViewHook_hookId.set(this, void 0);
        // This url is the path to the asset that will be loaded in the web view.
        // It is ensured to be a valid path prior to the effect being emitted.
        _WebViewHook_url.set(this, void 0);
        _WebViewHook_onMessage.set(this, void 0);
        _WebViewHook_onUnmount.set(this, void 0);
        _WebViewHook_renderContext.set(this, void 0);
        _WebViewHook_invalidate.set(this, void 0);
        /**
         * Send a message from a Devvit app to a web view (fullscreen).
         */
        this.postMessage = (message) => {
            try {
                // Encode message as JSON for consistency with the mobile clients
                const jsonString = JSON.stringify(message);
                // Handle messages sent from Devvit app -> web view
                __classPrivateFieldGet(this, _WebViewHook_renderContext, "f").emitEffect(`postMessage${this.state.messageCount++}`, {
                    type: EffectType.EFFECT_WEB_VIEW,
                    webView: {
                        postMessage: {
                            webViewId: __classPrivateFieldGet(this, _WebViewHook_hookId, "f"),
                            app: {
                                message, // This is deprecated, but populated for mobile client backwards compatibility
                                jsonString,
                            },
                        },
                    },
                });
            }
            catch (e) {
                console.error(StringUtil.caughtToString(e));
                // Safety net if something went wrong with JSON.stringify
                throw Error('Something went wrong. Please check the contents of your postMessage.');
            }
        };
        /**
         * Triggers the fullscreen effect to show the web view in fullscreen mode.
         */
        this.mount = () => {
            // If already mounted, do nothing
            if (this.state.isMounted) {
                console.warn('Webview is already mounted!');
                return;
            }
            const assets = __classPrivateFieldGet(this, _WebViewHook_renderContext, "f")?.devvitContext?.assets;
            let url;
            if (__classPrivateFieldGet(this, _WebViewHook_url, "f").startsWith(apiPathPrefix))
                url = __classPrivateFieldGet(this, _WebViewHook_url, "f");
            // Get the public URL for the asset. Returns an empty string if the asset is not found.
            else {
                const asset = __classPrivateFieldGet(this, _WebViewHook_url, "f").replace(/[#?].*/, '');
                url = `${assets.getURL(asset, { webView: true })}${__classPrivateFieldGet(this, _WebViewHook_url, "f").slice(asset.length)}`;
            }
            if (!url) {
                throw Error(`useWebView fullscreen request failed; web view asset could not be found`);
            }
            __classPrivateFieldGet(this, _WebViewHook_emitFullscreenEffect, "f").call(this, true, url);
        };
        /**
         * Triggers the fullscreen effect to hide the open web view.
         */
        this.unmount = () => {
            __classPrivateFieldGet(this, _WebViewHook_emitFullscreenEffect, "f").call(this, false, '');
        };
        _WebViewHook_emitFullscreenEffect.set(this, (show, url) => {
            __classPrivateFieldGet(this, _WebViewHook_renderContext, "f").emitEffect('fullscreen', {
                type: EffectType.EFFECT_WEB_VIEW,
                webView: {
                    fullscreen: {
                        id: __classPrivateFieldGet(this, _WebViewHook_hookId, "f"),
                        show,
                        url,
                    },
                },
            });
        });
        // Default to index.html if there is no URL provided.
        __classPrivateFieldSet(this, _WebViewHook_url, options.url ?? 'index.html', "f");
        __classPrivateFieldSet(this, _WebViewHook_hookId, params.hookId, "f");
        __classPrivateFieldSet(this, _WebViewHook_onMessage, options.onMessage, "f");
        __classPrivateFieldSet(this, _WebViewHook_onUnmount, options.onUnmount, "f");
        __classPrivateFieldSet(this, _WebViewHook_renderContext, params.context, "f");
        __classPrivateFieldSet(this, _WebViewHook_invalidate, params.invalidate, "f");
    }
    onStateLoaded() {
        // No need to remount here since the UI events will handle the state
    }
    /**
     * Handles UI events originating from the web view and calls associated callbacks for the Devvit app to handle.
     */
    async onUIEvent(event) {
        if (event.webView?.fullScreen) {
            const isVisible = event.webView.fullScreen.visibility === WebViewVisibility.WEBVIEW_VISIBLE;
            this.state.isMounted = isVisible;
            __classPrivateFieldGet(this, _WebViewHook_invalidate, "f").call(this); // Ensure the state change is persisted
            if (!isVisible && __classPrivateFieldGet(this, _WebViewHook_onUnmount, "f"))
                await __classPrivateFieldGet(this, _WebViewHook_onUnmount, "f").call(this, this);
        }
        else if (event.webView?.postMessage) {
            // Handle messages sent from web view -> Devvit app
            // Fallback to deprecated message field for mobile client backwards compatibility
            const message = event.webView.postMessage.jsonString
                ? JSON.parse(event.webView.postMessage.jsonString)
                : event.webView.postMessage.message;
            // TODO: Temporary. Remove this filter once clients are updated.
            if (webViewMessageIsInternalAndClientScope(message))
                return;
            await __classPrivateFieldGet(this, _WebViewHook_onMessage, "f").call(this, message, this);
        }
    }
}
_WebViewHook_hookId = new WeakMap(), _WebViewHook_url = new WeakMap(), _WebViewHook_onMessage = new WeakMap(), _WebViewHook_onUnmount = new WeakMap(), _WebViewHook_renderContext = new WeakMap(), _WebViewHook_invalidate = new WeakMap(), _WebViewHook_emitFullscreenEffect = new WeakMap();
/**
 * Use this hook to handle a web view's visibility state and any messages sent to your app.
 * */
export function useWebView(options) {
    const hook = registerHook({
        namespace: 'useWebView',
        initializer: (params) => new WebViewHook(params, options),
    });
    return {
        postMessage: hook.postMessage,
        mount: hook.mount,
        unmount: hook.unmount,
    };
}
