import type { Block, BlockRenderRequest, Dimensions, Effect, FormSubmittedEvent, Metadata, RealtimeSubscriptionEvent, UIEvent } from '@devvit/protos';
import type { FormKey } from '@devvit/shared-types/useForm.js';
import type { AssetsClient } from '../../../apis/AssetsClient/AssetsClient.js';
import type { ModLogClient } from '../../../apis/modLog/ModLogClient.js';
import type { RealtimeClient } from '../../../apis/realtime/RealtimeClient.js';
import type { RedditAPIClient } from '../../../apis/reddit/RedditAPIClient.js';
import type { Form, FormFunction, MediaPlugin, Scheduler, SettingsClient, UIClient, UseChannelHook, UseFormHook, UseFormHookState, UseIntervalHook, UseIntervalHookState, UseStateHook } from '../../../types/index.js';
import type { JSONObject, PartialJSONObject } from '../../../types/json.js';
import type { KVStore } from '../../../types/kvStore.js';
import type { RedisClient } from '../../../types/redis.js';
import type { BlockElement } from '../../Devvit.js';
import { Devvit } from '../../Devvit.js';
import type { CacheHelper } from '../cache.js';
import type { LocalCache } from '../promise_cache.js';
import { BlocksTransformer } from './BlocksTransformer.js';
import type { EffectEmitter } from './EffectEmitter.js';
export type ReifiedBlockElement = {
    type: string;
    props: {
        [key: string]: unknown;
    } | undefined;
    children: ReifiedBlockElementOrLiteral[];
};
export type ReifiedBlockElementOrLiteral = ReifiedBlockElement | string;
/** Serializable. */
type ComponentState = {
    [hookIndex: number]: UseIntervalHookState | UseFormHookState | JSONObject;
};
/** Serializable. */
type RenderState = {
    [componentKey: string]: ComponentState;
};
export declare function assertNotString(reified: ReifiedBlockElementOrLiteral): asserts reified is ReifiedBlockElement;
/**
 * @experimental Do not use directly, for internal use only.
 * An instance of this class should be instantiated for each OnRender call.
 * This class is responsible for:
 *   - rendering JSX elements into Blocks.
 *   - managing state and hooks for each component.
 *   - drilling the shared clients into function components.
 */
export declare class BlocksReconciler implements EffectEmitter {
    #private;
    component: JSX.ComponentFunction;
    event: BlockRenderRequest | UIEvent | undefined;
    state: {
        __renderState: RenderState;
        __postData?: {
            thingId?: string;
        };
        __realtimeChannels?: string[];
        __cache?: LocalCache;
    };
    metadata: Metadata;
    modLog: ModLogClient;
    reddit: RedditAPIClient;
    kvStore: KVStore;
    cache: CacheHelper;
    redis: RedisClient;
    scheduler: Scheduler;
    dimensions?: Dimensions;
    ui: UIClient;
    settings: SettingsClient;
    media: MediaPlugin;
    assets: AssetsClient;
    realtime: RealtimeClient;
    hooks: {
        useState: UseStateHook;
        useInterval: UseIntervalHook;
        useForm: UseFormHook;
        useChannel: UseChannelHook;
    };
    emitEffect(_dedupeKey: string, effect: Effect): void;
    renderState: RenderState;
    currentComponentKey: string[];
    currentHookIndex: number;
    actions: Map<string, Function>;
    forms: Map<FormKey, Form | FormFunction>;
    realtimeChannels: string[];
    realtimeUpdated: boolean;
    pendingHooks: (() => Promise<void>)[];
    isRendering: boolean;
    transformer: BlocksTransformer;
    effects: Effect[];
    constructor(component: JSX.ComponentFunction, event: BlockRenderRequest | UIEvent | undefined, state: PartialJSONObject | undefined, metadata: Metadata, dimensions: Dimensions | undefined);
    render(): Promise<Block>;
    makeUniqueActionID(id: string): string;
    reconcile(): Promise<void>;
    buildBlocksUI(): Promise<Block>;
    renderElement(ctx: Devvit.Context, element: JSX.Element): Promise<Block>;
    processProps(block: BlockElement): Promise<void>;
    processBlock(element: JSX.Element | JSX.Element[], idGenerator?: (id: string) => string, path?: string[]): Promise<ReifiedBlockElementOrLiteral>;
    getCurrentComponentKey(): string[];
    getCurrentComponentState<S>(): {
        [hookIndex: number]: S;
    };
    getPreviousComponentState<S>(): {
        [hookIndex: number]: S;
    };
    get isInitialRender(): boolean;
    get isUserActionRender(): boolean;
    get isEffectRender(): boolean;
    get formSubmittedEvent(): FormSubmittedEvent | undefined | false;
    get blockRenderEventId(): string | undefined | false;
    get realtimeEvent(): RealtimeSubscriptionEvent | undefined | false;
    runHook(hook: () => Promise<void>): void;
    rerenderIn(delayMs: number): void;
    addRealtimeChannel(channel: string): void;
    removeRealtimeChannel(channel: string): void;
    get realtimeEffect(): Effect[];
    getEffects(): Effect[];
    buildNextState(): void;
}
export {};
//# sourceMappingURL=BlocksReconciler.d.ts.map