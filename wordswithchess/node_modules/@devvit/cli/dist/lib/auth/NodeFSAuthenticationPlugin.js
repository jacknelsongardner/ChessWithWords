var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _NodeFSAuthenticationPlugin_instances, _NodeFSAuthenticationPlugin_authCfg, _NodeFSAuthenticationPlugin_authTokenStoreUpdatesSubscription, _NodeFSAuthenticationPlugin_revokeTokenUrl_get, _NodeFSAuthenticationPlugin_authenticationUrl_get, _NodeFSAuthenticationPlugin_resetAutoRefreshTokenTimeout, _NodeFSAuthenticationPlugin_revokeToken, _NodeFSAuthenticationPlugin_getCurrentTokenRefreshedIfNeeded, _NodeFSAuthenticationPlugin_login, _NodeFSAuthenticationPlugin_listenForAuthCallback;
import crypto from 'node:crypto';
import querystring from 'node:querystring';
import { StringUtil } from '@devvit/shared-types/StringUtil.js';
import inquirer from 'inquirer';
import open from 'open';
import { map } from 'rxjs';
import { readLine } from '../../util/input-util.js';
import { fetchR2OAuthGrant, fetchR2OAuthRefresh } from '../http/oauth.js';
import { AuthTokenStore } from './AuthTokenStore.js';
import { localCodeServer } from './local-code-server.js';
import { handleAccessDenied } from './login-view.js';
import { StoredToken } from './StoredToken.js';
/**
 * @description server side Node FS implementation of an authentication plugin
 */
export class NodeFSAuthenticationPlugin {
    constructor(cfg) {
        _NodeFSAuthenticationPlugin_instances.add(this);
        _NodeFSAuthenticationPlugin_authCfg.set(this, void 0);
        _NodeFSAuthenticationPlugin_authTokenStoreUpdatesSubscription.set(this, void 0);
        __classPrivateFieldSet(this, _NodeFSAuthenticationPlugin_authCfg, cfg.auth, "f");
        this.authTokenStore = new AuthTokenStore(cfg.dotDevvitDir);
    }
    /** Remember to call .dispose() if you subscribed to auth changes through
     * NotifyAuthenticationUpdates to clear the timeouts!
     */
    async dispose() {
        await this.authTokenStore.dispose();
        __classPrivateFieldGet(this, _NodeFSAuthenticationPlugin_authTokenStoreUpdatesSubscription, "f")?.unsubscribe();
        if (this.autoRefreshTokenTimeout != null) {
            clearTimeout(this.autoRefreshTokenTimeout);
        }
    }
    async refreshStoredToken(refreshToken, copyPaste) {
        const refresh = await fetchR2OAuthRefresh(__classPrivateFieldGet(this, _NodeFSAuthenticationPlugin_authCfg, "f"), copyPaste, refreshToken);
        const token = StoredToken.fromGrant(refresh);
        await this.authTokenStore.writeFSToken(token, copyPaste);
        return { token: token, copyPaste };
    }
    async Authenticate() {
        const validation = await this.Validate();
        if (validation) {
            return validation;
        }
        const newToken = await __classPrivateFieldGet(this, _NodeFSAuthenticationPlugin_instances, "m", _NodeFSAuthenticationPlugin_login).call(this);
        await this.authTokenStore.writeFSToken(newToken);
        return newToken;
    }
    async Validate() {
        try {
            const token = await __classPrivateFieldGet(this, _NodeFSAuthenticationPlugin_instances, "m", _NodeFSAuthenticationPlugin_getCurrentTokenRefreshedIfNeeded).call(this);
            if (token) {
                return token;
            }
        }
        catch (err) {
            console.error(StringUtil.caughtToString(err, 'message'));
            console.warn(`Authentication required`);
        }
    }
    /**
     * @description this implementation pushed updates in 2 cases:
     * 1. When this.#authTokenStore file watcher notifies that changes have been
     *    made to the auth store. (e.g. devvit login in a different session)
     * 2. Before the current auth token is about to expire, the auth store will be
     *    requested to refresh.
     */
    NotifyAuthenticationUpdates(_request) {
        // subscribe to token changes on FS and set up auto refresh token
        if (!__classPrivateFieldGet(this, _NodeFSAuthenticationPlugin_authTokenStoreUpdatesSubscription, "f")) {
            __classPrivateFieldSet(this, _NodeFSAuthenticationPlugin_authTokenStoreUpdatesSubscription, this.authTokenStore.updates.subscribe(__classPrivateFieldGet(this, _NodeFSAuthenticationPlugin_instances, "m", _NodeFSAuthenticationPlugin_resetAutoRefreshTokenTimeout).bind(this)), "f");
        }
        return this.authTokenStore.updates.pipe(map((v) => (v.token.hasScopes(__classPrivateFieldGet(this, _NodeFSAuthenticationPlugin_authCfg, "f").scopes) ? v : undefined)));
    }
    async Logout(_request) {
        const tokenInfo = await this.authTokenStore.readFSToken();
        if (tokenInfo) {
            await __classPrivateFieldGet(this, _NodeFSAuthenticationPlugin_instances, "m", _NodeFSAuthenticationPlugin_revokeToken).call(this, tokenInfo.token);
        }
        await this.authTokenStore.clearToken();
        return {};
    }
    async loginViaCopyPaste() {
        const state = crypto.randomBytes(16).toString('hex');
        const authenticationUrl = `${__classPrivateFieldGet(this, _NodeFSAuthenticationPlugin_instances, "a", _NodeFSAuthenticationPlugin_authenticationUrl_get)}?${querystring.stringify({
            client_id: __classPrivateFieldGet(this, _NodeFSAuthenticationPlugin_authCfg, "f").copyPasteClientId,
            duration: __classPrivateFieldGet(this, _NodeFSAuthenticationPlugin_authCfg, "f").tokenDuration,
            redirect_uri: __classPrivateFieldGet(this, _NodeFSAuthenticationPlugin_authCfg, "f").copyPasteRedirectUri,
            response_type: 'code',
            scope: __classPrivateFieldGet(this, _NodeFSAuthenticationPlugin_authCfg, "f").scopes,
            devvit_cli: 'true',
            state,
        })}`;
        console.log('Please open this page:');
        console.log();
        console.log(authenticationUrl.replace('*', '%2A'));
        console.log();
        const { code } = await inquirer.prompt([
            {
                name: 'code',
                message: 'Paste the code you got here and press Enter:',
                type: 'input',
            },
        ]);
        const token = await this.fetchAccessToken(code, true);
        await this.authTokenStore.writeFSToken(token);
        return token;
    }
    async fetchAccessToken(authCode, copyPaste) {
        const grant = await fetchR2OAuthGrant(authCode, __classPrivateFieldGet(this, _NodeFSAuthenticationPlugin_authCfg, "f"), copyPaste);
        return StoredToken.fromGrant(grant);
    }
}
_NodeFSAuthenticationPlugin_authCfg = new WeakMap(), _NodeFSAuthenticationPlugin_authTokenStoreUpdatesSubscription = new WeakMap(), _NodeFSAuthenticationPlugin_instances = new WeakSet(), _NodeFSAuthenticationPlugin_revokeTokenUrl_get = function _NodeFSAuthenticationPlugin_revokeTokenUrl_get() {
    return `${__classPrivateFieldGet(this, _NodeFSAuthenticationPlugin_authCfg, "f").apiV1Url}/revoke_token`;
}, _NodeFSAuthenticationPlugin_authenticationUrl_get = function _NodeFSAuthenticationPlugin_authenticationUrl_get() {
    return `${__classPrivateFieldGet(this, _NodeFSAuthenticationPlugin_authCfg, "f").apiV1Url}/authorize`;
}, _NodeFSAuthenticationPlugin_resetAutoRefreshTokenTimeout = function _NodeFSAuthenticationPlugin_resetAutoRefreshTokenTimeout(curStoredToken) {
    if (this.autoRefreshTokenTimeout != null) {
        clearTimeout(this.autoRefreshTokenTimeout);
    }
    // refresh 10 minutes before actual expiry
    const refreshIn = curStoredToken.token.expiresAt.getTime() - Date.now() - 10 * 60 * 1000;
    if (refreshIn <= 0) {
        // to-do: why isn't this awaited?
        this.Authenticate()
            .then()
            .catch((err) => console.error(StringUtil.caughtToString(err)));
        return;
    }
    this.autoRefreshTokenTimeout = setTimeout(() => {
        // to-do: why isn't this awaited?
        this.refreshStoredToken(curStoredToken.token.refreshToken, !!curStoredToken.copyPaste)
            .then()
            .catch(() => { });
    }, refreshIn);
}, _NodeFSAuthenticationPlugin_revokeToken = async function _NodeFSAuthenticationPlugin_revokeToken(token, copyPaste) {
    const formData = new FormData();
    formData.append('refresh_token', encodeURIComponent(token.refreshToken));
    formData.append('token_type_hint', 'refresh_token');
    const headers = copyPaste
        ? __classPrivateFieldGet(this, _NodeFSAuthenticationPlugin_authCfg, "f").copyPasteClientHeaders
        : __classPrivateFieldGet(this, _NodeFSAuthenticationPlugin_authCfg, "f").devvitOAuthClientHeaders;
    const response = await fetch(__classPrivateFieldGet(this, _NodeFSAuthenticationPlugin_instances, "a", _NodeFSAuthenticationPlugin_revokeTokenUrl_get), {
        method: 'POST',
        headers,
        body: formData,
    });
    await response.text();
}, _NodeFSAuthenticationPlugin_getCurrentTokenRefreshedIfNeeded = 
/**
 * @returns undefined if no token on disk can be found. Otherwise, returns a
 * valid StoredToken instance
 */
async function _NodeFSAuthenticationPlugin_getCurrentTokenRefreshedIfNeeded() {
    let tokenInfo = await this.authTokenStore.readFSToken();
    if (!tokenInfo || !tokenInfo.token.hasScopes(__classPrivateFieldGet(this, _NodeFSAuthenticationPlugin_authCfg, "f").scopes)) {
        return undefined;
    }
    if (tokenInfo.token.isFresh()) {
        return tokenInfo.token;
    }
    tokenInfo = await this.refreshStoredToken(tokenInfo.token.refreshToken, !!tokenInfo.copyPaste);
    return tokenInfo.token;
}, _NodeFSAuthenticationPlugin_login = async function _NodeFSAuthenticationPlugin_login() {
    const state = crypto.randomBytes(16).toString('hex');
    const authenticationUrl = `${__classPrivateFieldGet(this, _NodeFSAuthenticationPlugin_instances, "a", _NodeFSAuthenticationPlugin_authenticationUrl_get)}?${querystring.stringify({
        client_id: __classPrivateFieldGet(this, _NodeFSAuthenticationPlugin_authCfg, "f").clientId,
        duration: __classPrivateFieldGet(this, _NodeFSAuthenticationPlugin_authCfg, "f").tokenDuration,
        redirect_uri: __classPrivateFieldGet(this, _NodeFSAuthenticationPlugin_authCfg, "f").redirectUri,
        response_type: 'code',
        scope: __classPrivateFieldGet(this, _NodeFSAuthenticationPlugin_authCfg, "f").scopes,
        devvit_cli: 'true',
        state,
    })}`.replaceAll('*', '%2A'); // querystring thinks this is safe, but it's not standard
    console.log(`
Press enter to open Reddit to complete authentication:

${authenticationUrl}
`); // extra line for spacing on terminal output
    // Don't await. Start the server immediately so we don't miss a callback.
    const line = readLine();
    line.then(() => open(authenticationUrl)).catch(() => { });
    try {
        return await __classPrivateFieldGet(this, _NodeFSAuthenticationPlugin_instances, "m", _NodeFSAuthenticationPlugin_listenForAuthCallback).call(this, state, authenticationUrl);
    }
    catch (err) {
        console.error('Failed to login to reddit');
        throw err;
    }
    finally {
        // Regardless of the outcome, we're done.
        line.reject();
    }
}, _NodeFSAuthenticationPlugin_listenForAuthCallback = function _NodeFSAuthenticationPlugin_listenForAuthCallback(state, authenticationUrl) {
    return localCodeServer({
        port: __classPrivateFieldGet(this, _NodeFSAuthenticationPlugin_authCfg, "f").callbackListenerPort,
        state,
        requestHandler: async (queryParams, resp) => {
            if (queryParams.code) {
                // If there's an auth code, attempt using it to get an access token
                const { code: queryCode } = queryParams;
                const code = typeof queryCode === 'string' ? queryCode : queryCode[0];
                return await this.fetchAccessToken(code, false);
            }
            if (queryParams.error === 'access_denied') {
                // If access was denied, print a message asking them to try again and approve access
                handleAccessDenied(resp, authenticationUrl);
            }
            return false;
        },
    });
};
