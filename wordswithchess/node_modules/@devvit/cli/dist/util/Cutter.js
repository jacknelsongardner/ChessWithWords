var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _Cutter_instances, _Cutter_fetchAndExtract, _Cutter_cut;
import fsp from 'node:fs/promises';
import os from 'node:os';
import path from 'node:path';
import { fileTypeFromFile } from 'file-type';
import JSZip from 'jszip';
import Mustache from 'mustache';
const RAW_FILE_MIME_TYPES = [
    'image/',
    'video/',
    'application/',
    'video/',
    'audio/',
    'font/',
    'model/',
];
// Use custom Mustache delimiters that won't conflict with JSX/TSX curly braces.
const MUSTACHE_TAGS = ['<%', '%>'];
function m(template, mustacheContext) {
    return Mustache.render(template, mustacheContext, undefined, { tags: MUSTACHE_TAGS });
}
/** Render a template directly to the filesystem. */
class Cutter {
    constructor(sourceUrl) {
        _Cutter_instances.add(this);
        this.sourceUrl = sourceUrl;
    }
    async cut(target, mustacheContext) {
        await fsp.mkdir(target, { recursive: true });
        console.log('Fetching and extracting the template...');
        const tmpdir = await __classPrivateFieldGet(this, _Cutter_instances, "m", _Cutter_fetchAndExtract).call(this, this.sourceUrl);
        console.log('Cutting the template to the target directory...');
        await __classPrivateFieldGet(this, _Cutter_instances, "m", _Cutter_cut).call(this, tmpdir, target, mustacheContext);
    }
}
_Cutter_instances = new WeakSet(), _Cutter_fetchAndExtract = async function _Cutter_fetchAndExtract(sourceUrl) {
    const tmpdir = await fsp.mkdtemp(path.join(os.tmpdir(), 'devvit-cutter-'));
    // Fetch the source URL into a buffer
    const response = await fetch(sourceUrl);
    if (!response.ok) {
        throw new Error(`Failed to fetch template from ${sourceUrl}: ${response.statusText}`);
    }
    const buffer = await response.arrayBuffer();
    // Extract the buffer to the temporary directory using jszip
    const zip = await JSZip.loadAsync(buffer);
    await Promise.all(Object.values(zip.files).map(async (file) => {
        const filePath = path.join(tmpdir, file.name);
        // Make sure the directory exists (whether this entry is a file or dir)
        // Some zip archives (e.g., those generated by GitHub) may omit explicit directory
        // entries for nested paths, so we need to create them ourselves.
        const dirToCreate = file.dir ? filePath : path.dirname(filePath);
        await fsp.mkdir(dirToCreate, { recursive: true });
        // If itâ€™s a file, write its content
        if (!file.dir) {
            const content = await file.async('nodebuffer');
            await fsp.writeFile(filePath, content);
        }
    }));
    // There will be a subdirectory in the temporary directory; we want to return the path to that subdirectory.
    const entries = await fsp.readdir(tmpdir, { withFileTypes: true });
    if (entries.length !== 1 || !entries[0].isDirectory()) {
        throw new Error(`Expected a single directory in ${tmpdir}, found: ${entries.map((e) => e.name).join(', ')}`);
    }
    // Return the path to the extracted directory
    return path.join(tmpdir, entries[0].name);
}, _Cutter_cut = async function _Cutter_cut(source, target, mustacheContext) {
    for await (const entry of await fsp.opendir(source)) {
        const newName = m(entry.name, mustacheContext);
        const newTarget = path.join(target, newName);
        const newSource = path.join(source, entry.name);
        if (entry.isDirectory()) {
            if (entry.name === 'node_modules') {
                continue;
            }
            await fsp.mkdir(newTarget);
            await __classPrivateFieldGet(this, _Cutter_instances, "m", _Cutter_cut).call(this, newSource, newTarget, mustacheContext);
        }
        else if (entry.isFile()) {
            // skip template config since it's only needed for CLI
            if (entry.name === 'template-config.json') {
                continue;
            }
            const type = await fileTypeFromFile(newSource);
            // If we could determine the file type, and it starts with a raw mime type indicator
            if (type && RAW_FILE_MIME_TYPES.some((mime) => type.mime.startsWith(mime))) {
                // Copy the file directly, no Mustache
                await fsp.copyFile(newSource, newTarget);
                continue;
            }
            // Else, run Mustache against the file contents & write the output
            const content = await fsp.readFile(newSource, 'utf8');
            const newContent = m(content, mustacheContext);
            await fsp.writeFile(newTarget, newContent);
        }
        else {
            throw new Error(`Unknown file type: ${entry.name}`);
        }
    }
};
export default Cutter;
