/**
 * `ClassicAppConfig` is the old config being phased out for "Webbit".
 * "v1" / `AppConfig` is the new config backed by config-file.v1.json.
 * `DevvitConfig` is either of these.
 *
 * to-do: delete this comment when ClassicAppConfig is deleted.
 */
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _Project_config, _Project_packageConfig;
import { existsSync, readFileSync, writeFileSync } from 'node:fs';
import { apiPathPrefix } from '@devvit/shared-types/constants.js';
import { parseAppConfig, } from '@devvit/shared-types/schemas/config-file.v1.js';
import path from 'path';
import { DEVVIT_SUBREDDIT } from '../constants/Environment.js';
import { findUpDirContaining, isFile } from './file-util.js';
import { dumpJsonToYaml, readYamlToJson } from './files.js';
import { readPackageJSON } from './package-managers/package-util.js';
/** Basename of default classic config. */
export const devvitClassicConfigFilename = 'devvit.yaml';
/** Basename of default schema v1 config. */
export const devvitV1ConfigFilename = 'devvit.json';
/** A logical project file. See config-file.v1.json. */
export class Project {
    /**
     * @arg root Project root directory.
     * @arg filename Project config filename.
     */
    static async new(root, filename, mode) {
        const config = await readConfig(root, filename, mode === 'Uninitialized');
        let packageJSON;
        try {
            packageJSON = await readPackageJSON(root);
        }
        catch {
            // Failure is fine, it just means we don't have a config file (yet)
        }
        if (isAppConfig(config)) {
            const missingFiles = validateConfig(config, existsSync, mode);
            // check if package.json has a build command
            if (missingFiles.length) {
                const containsBuildScript = Object.keys(packageJSON?.scripts ?? {}).some((script) => script.includes('build'));
                let error = "Your devvit.json references files that don't exist: ";
                error += missingFiles.join(', ');
                if (containsBuildScript) {
                    error += `. You may need to run your build script to fix this.`;
                }
                throw Error(error);
            }
        }
        return new Project(root, filename, config, packageJSON?.devvit);
    }
    constructor(root, filename, config, packageConfig) {
        this.flag = {};
        this.app = {};
        _Project_config.set(this, void 0);
        /** @deprecated Use the config-file.v1.json schema instead. */
        _Project_packageConfig.set(this, void 0);
        this.root = root;
        this.filename = filename;
        __classPrivateFieldSet(this, _Project_config, config, "f");
        __classPrivateFieldSet(this, _Project_packageConfig, packageConfig, "f");
    }
    get appConfig() {
        return isAppConfig(__classPrivateFieldGet(this, _Project_config, "f")) ? __classPrivateFieldGet(this, _Project_config, "f") : undefined;
    }
    // to-do: just return post once classic is removed.
    get clientDir() {
        return isAppConfig(__classPrivateFieldGet(this, _Project_config, "f")) ? __classPrivateFieldGet(this, _Project_config, "f").post?.dir : 'webroot';
    }
    // to-do: just return media once classic is removed.
    get mediaDir() {
        return isAppConfig(__classPrivateFieldGet(this, _Project_config, "f")) ? __classPrivateFieldGet(this, _Project_config, "f").media?.dir : 'assets';
    }
    get name() {
        return __classPrivateFieldGet(this, _Project_config, "f").name;
    }
    set name(name) {
        __classPrivateFieldGet(this, _Project_config, "f").name = name.toLowerCase();
        if (isAppConfig(__classPrivateFieldGet(this, _Project_config, "f")))
            __classPrivateFieldGet(this, _Project_config, "f").json.name = __classPrivateFieldGet(this, _Project_config, "f").name;
        writeConfig(this.root, this.filename, __classPrivateFieldGet(this, _Project_config, "f"));
    }
    get permissions() {
        return isAppConfig(__classPrivateFieldGet(this, _Project_config, "f")) ? __classPrivateFieldGet(this, _Project_config, "f").permissions : undefined;
    }
    get post() {
        return isAppConfig(__classPrivateFieldGet(this, _Project_config, "f")) ? __classPrivateFieldGet(this, _Project_config, "f").post : undefined;
    }
    get server() {
        return isAppConfig(__classPrivateFieldGet(this, _Project_config, "f")) ? __classPrivateFieldGet(this, _Project_config, "f").server : undefined;
    }
    // to-do: move into devvit.json.
    get watchDebounceMillis() {
        return this.flag.watchDebounceMillis ?? __classPrivateFieldGet(this, _Project_packageConfig, "f")?.playtest?.debounceConfigMs ?? 100;
    }
    getSubreddit(mode) {
        if (mode === 'Prod') {
            throw Error(`Getting Prod subreddits isn't supported yet.`);
        }
        const trimmedEnvVar = process.env[DEVVIT_SUBREDDIT]?.trim();
        if (trimmedEnvVar) {
            return trimmedEnvVar;
        }
        const trimmedFlag = this.flag.subreddit?.trim();
        if (trimmedFlag) {
            return trimmedFlag;
        }
        if (isAppConfig(__classPrivateFieldGet(this, _Project_config, "f")) && __classPrivateFieldGet(this, _Project_config, "f").dev?.subreddit) {
            return __classPrivateFieldGet(this, _Project_config, "f").dev.subreddit;
        }
        return this.app.defaultPlaytestSubredditId;
    }
    setSubreddit(subreddit, mode) {
        var _a, _b;
        if (mode === 'Prod') {
            throw Error(`Setting Prod subreddits isn't supported yet.`);
        }
        if (!isAppConfig(__classPrivateFieldGet(this, _Project_config, "f")))
            return;
        (_a = __classPrivateFieldGet(this, _Project_config, "f")).dev ?? (_a.dev = {});
        __classPrivateFieldGet(this, _Project_config, "f").dev.subreddit = subreddit;
        (_b = __classPrivateFieldGet(this, _Project_config, "f").json).dev ?? (_b.dev = {});
        __classPrivateFieldGet(this, _Project_config, "f").json.dev.subreddit = subreddit;
        writeConfig(this.root, this.filename, __classPrivateFieldGet(this, _Project_config, "f"));
    }
}
_Project_config = new WeakMap(), _Project_packageConfig = new WeakMap();
/**
 * Searches for dir containing the config filename. If found, returns a cached
 * config.
 *
 * @arg filename Optional config filename override (usually CLI flag).
 */
export async function newProject(filename, mode) {
    filename || (filename = (await findUpDirContaining(devvitV1ConfigFilename))
        ? devvitV1ConfigFilename
        : devvitClassicConfigFilename);
    const root = await findUpDirContaining(filename);
    if (root)
        return await Project.new(root, filename, mode);
}
/** @internal */
export function isAppConfig(config) {
    return 'schema' in config && !!config.schema;
}
/** @internal */
export function parseClassicConfig(json) {
    if (json == null || typeof json !== 'object' || Array.isArray(json))
        throw Error(`${devvitClassicConfigFilename} must be an object \`{"name": "foo", ...}\`.`);
    if (typeof json.name !== 'string')
        throw Error(`${devvitClassicConfigFilename} must have \`name\` property.`);
    // Include original data in case it's a superset.
    return { ...json, name: json.name.toLowerCase() };
}
async function readConfig(root, filename, allowUninitializedConfig) {
    const configFilename = path.join(root, filename);
    if (!(await isFile(configFilename)))
        throw new Error(`${configFilename} does not exist`);
    if (configFilename.endsWith('.json')) {
        let str;
        try {
            str = readFileSync(configFilename, 'utf8');
        }
        catch (err) {
            throw Error(`cannot read config ${configFilename}`, { cause: err });
        }
        return parseAppConfig(str, allowUninitializedConfig);
    }
    return parseClassicConfig(await readYamlToJson(configFilename));
}
/** @internal; */
export function validateConfig(config, fileExists, mode) {
    const missingFiles = [];
    if (config.blocks && !fileExists(config.blocks.entry))
        missingFiles.push(`\`config.blocks.entry\` (${config.blocks.entry})`);
    if (config.media && !fileExists(config.media.dir))
        missingFiles.push(`\`config.media.dir\` (${config.media.dir})`);
    if (config.post) {
        if (!fileExists(config.post.dir) && mode === 'Static')
            missingFiles.push(`\`config.post.dir\` (${config.post.dir})`);
        for (const [name, entrypoint] of Object.entries(config.post.entrypoints)) {
            if (entrypoint.entry.startsWith(apiPathPrefix) || mode === 'Dynamic') {
                // URL path or user is rebuilding regularly during playtest.
            }
            else {
                const dir = path.resolve(config.post.dir);
                const entry = path.resolve(dir, entrypoint.entry);
                if (!fileExists(entry)) {
                    missingFiles.push(`\`config.post.entrypoints.${name}.entry\` (${entrypoint.entry})`);
                }
            }
        }
    }
    const serverEntry = config.server ? path.join(config.server.dir, config.server.entry) : undefined;
    if (serverEntry && !fileExists(serverEntry) && mode === 'Static')
        missingFiles.push(`\`config.server\` (${serverEntry})`);
    return missingFiles;
}
function writeConfig(projectPath, configFile, config) {
    writeFileSync(path.join(projectPath, configFile), isAppConfig(config) ? JSON.stringify(config.json, undefined, 2) : dumpJsonToYaml(config));
}
export function isRunningInAppDirectory() {
    return (existsSync(path.join(process.cwd(), devvitClassicConfigFilename)) ||
        existsSync(path.join(process.cwd(), devvitV1ConfigFilename)));
}
