var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var _ProjectTemplateResolver_instances, _ProjectTemplateResolver_options, _ProjectTemplateResolver_fetchOptions;
import { getHeaders } from '../clientGenerators.js';
import { DEVVIT_PORTAL_URL } from '../config.js';
export class ProjectTemplateResolver {
    constructor() {
        _ProjectTemplateResolver_instances.add(this);
        _ProjectTemplateResolver_options.set(this, undefined);
    }
    get options() {
        __classPrivateFieldSet(this, _ProjectTemplateResolver_options, __classPrivateFieldGet(this, _ProjectTemplateResolver_options, "f") ?? __classPrivateFieldGet(this, _ProjectTemplateResolver_instances, "m", _ProjectTemplateResolver_fetchOptions).call(this), "f");
        return __classPrivateFieldGet(this, _ProjectTemplateResolver_options, "f");
    }
    async getProjectUrl(projectName) {
        const projectNameLower = projectName.toLowerCase();
        const options = await this.options;
        const templateProject = options.find((opt) => opt.name.toLowerCase() === projectNameLower ||
            opt.shortName?.toLowerCase() === projectNameLower);
        if (!templateProject) {
            throw new Error(`Specified template: ${projectName} does not exist`);
        }
        return templateProject.url;
    }
    async isValidProjectTemplate(templateName) {
        return (await this.options).some((opt) => opt.name.toLowerCase() === templateName.toLowerCase() ||
            opt.shortName?.toLowerCase() === templateName.toLowerCase());
    }
}
_ProjectTemplateResolver_options = new WeakMap(), _ProjectTemplateResolver_instances = new WeakSet(), _ProjectTemplateResolver_fetchOptions = async function _ProjectTemplateResolver_fetchOptions() {
    const response = await fetch(DEVVIT_PORTAL_URL + '/templates.json', {
        headers: getHeaders(),
    });
    if (!response.ok) {
        throw new Error(`Failed to fetch templates: ${response.statusText}`);
    }
    return (await response.json());
};
