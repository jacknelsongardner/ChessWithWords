var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _AppUploader_instances, _AppUploader_cmd, _AppUploader_appClient, _AppUploader_promptNameUntilNotTaken, _AppUploader_promptForNSFW, _AppUploader_getAppDescription;
import { APP_SLUG_BASE_MAX_LENGTH, makeSlug, sluggable } from '@devvit/shared-types/slug.js';
import { StringUtil } from '@devvit/shared-types/StringUtil.js';
import { ux } from '@oclif/core';
import inquirer from 'inquirer';
import { TwirpError, TwirpErrorCode } from 'twirp-ts';
import { MY_PORTAL_ENABLED } from '../lib/config.js';
import { getCaptcha } from './captcha.js';
import { checkAppNameAvailability } from './checkAppNameAvailability.js';
import { createAppClient } from './clientGenerators.js';
import { readPackageJSON } from './package-managers/package-util.js';
export class AppUploader {
    constructor(cmd) {
        _AppUploader_instances.add(this);
        _AppUploader_cmd.set(this, void 0);
        _AppUploader_appClient.set(this, createAppClient());
        __classPrivateFieldSet(this, _AppUploader_cmd, cmd, "f");
    }
    async createNewApp(copyPaste, justDoIt) {
        const appName = await __classPrivateFieldGet(this, _AppUploader_instances, "m", _AppUploader_promptNameUntilNotTaken).call(this, sluggable(__classPrivateFieldGet(this, _AppUploader_cmd, "f").project.name) ? makeSlug(__classPrivateFieldGet(this, _AppUploader_cmd, "f").project.name) : undefined);
        const description = await __classPrivateFieldGet(this, _AppUploader_instances, "m", _AppUploader_getAppDescription).call(this);
        const isNsfw = justDoIt ? false : await __classPrivateFieldGet(this, _AppUploader_instances, "m", _AppUploader_promptForNSFW).call(this);
        let captcha = '';
        // Captcha not required in snoodev, but required in prod
        // TODO We should make a development only API key; once we do, we can remove this & check captchas in dev!
        if (!MY_PORTAL_ENABLED) {
            captcha = await getCaptcha({ copyPaste });
        }
        try {
            ux.action.start('Creating app');
            // let's eliminate the "slug" field and just update the "name" directly
            const newApp = await __classPrivateFieldGet(this, _AppUploader_appClient, "f").Create({
                autogenerateName: false,
                name: appName,
                description: description ?? '',
                isNsfw,
                categories: [], // TODO: should prompt in the future
                captcha,
                categoryIds: [],
            });
            __classPrivateFieldGet(this, _AppUploader_cmd, "f").project.name = newApp.slug;
            ux.action.stop('Successfully created your app in Reddit!');
            return {
                app: newApp,
                versions: [], // There's no versions, we just made it :)
                fetchDomainRequests: [],
            };
        }
        catch (err) {
            ux.action.stop('Error');
            if (err instanceof TwirpError) {
                if (err.code === TwirpErrorCode.AlreadyExists) {
                    __classPrivateFieldGet(this, _AppUploader_cmd, "f").error(`An app account with the name "${appName}" already exists. Please change the "name" field of devvit.yaml and try again.`);
                }
                else {
                    __classPrivateFieldGet(this, _AppUploader_cmd, "f").error(StringUtil.caughtToString(err, 'message'));
                }
            }
            else {
                __classPrivateFieldGet(this, _AppUploader_cmd, "f").error('Your app could not be uploaded because we encountered an issue creating your app account. This may happen because of a network issue on our end. Please try again.');
            }
        }
    }
}
_AppUploader_cmd = new WeakMap(), _AppUploader_appClient = new WeakMap(), _AppUploader_instances = new WeakSet(), _AppUploader_promptNameUntilNotTaken = async function _AppUploader_promptNameUntilNotTaken(suggestedName) {
    let appName = suggestedName;
    for (;;) {
        const rsp = await inquirer.prompt([
            {
                default: appName,
                name: 'appName',
                type: 'input',
                message: 'Pick a name for your app:',
                validate: async (input) => {
                    if (!sluggable(input)) {
                        return `The name of your app must be between 3 and ${APP_SLUG_BASE_MAX_LENGTH} characters long, and contains only alphanumeric characters, spaces, and dashes.`;
                    }
                    return true;
                },
                filter: (input) => {
                    return makeSlug(input.trim().toLowerCase());
                },
            },
        ]);
        appName = rsp.appName;
        if (appName) {
            const isAvailableResponse = await checkAppNameAvailability(__classPrivateFieldGet(this, _AppUploader_appClient, "f"), appName);
            if (!isAvailableResponse.exists) {
                // Doesn't exist, we're good
                return appName;
            }
            __classPrivateFieldGet(this, _AppUploader_cmd, "f").warn(`The app name "${appName}" is unavailable. The app name must be a unique Reddit username.`);
            if (isAvailableResponse.suggestions.length > 0) {
                __classPrivateFieldGet(this, _AppUploader_cmd, "f").log(`Here's some suggestions:\n  * ${isAvailableResponse.suggestions.join('\n  * ')}`);
                appName = isAvailableResponse.suggestions[0];
            }
        }
    }
}, _AppUploader_promptForNSFW = async function _AppUploader_promptForNSFW() {
    return (await inquirer.prompt([
        {
            name: 'isNSFW',
            message: 'Is the app NSFW?',
            type: 'confirm',
            default: false,
        },
    ])).isNSFW;
}, _AppUploader_getAppDescription = async function _AppUploader_getAppDescription() {
    return ((await readPackageJSON(__classPrivateFieldGet(this, _AppUploader_cmd, "f").project.root)).description || '')?.substring(0, 200);
};
