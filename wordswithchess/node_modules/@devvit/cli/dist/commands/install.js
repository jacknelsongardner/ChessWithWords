var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _Install_instances, _Install_appClient, _Install_appVersionClient, _Install_installationsClient, _Install_findExistingInstallation;
import os from 'node:os';
import { InstallationType, NutritionCategory } from '@devvit/protos/community.js';
import { StringUtil } from '@devvit/shared-types/StringUtil.js';
import { DevvitVersion } from '@devvit/shared-types/Version.js';
import { Args, ux } from '@oclif/core';
import { TwirpError } from 'twirp-ts/build/twirp/errors.js';
import { getAccessTokenAndLoginIfNeeded } from '../util/auth.js';
import { createAppClient, createAppVersionClient, createInstallationsClient, } from '../util/clientGenerators.js';
import { DevvitCommand, toLowerCaseArgParser } from '../util/commands/DevvitCommand.js';
import { getSubredditNameWithoutPrefix } from '../util/common-actions/getSubredditNameWithoutPrefix.js';
import { getVersionByNumber } from '../util/common-actions/getVersionByNumber.js';
import { getAppBySlug } from '../util/getAppBySlug.js';
class Install extends DevvitCommand {
    constructor() {
        super(...arguments);
        _Install_instances.add(this);
        _Install_appClient.set(this, createAppClient());
        _Install_appVersionClient.set(this, createAppVersionClient());
        _Install_installationsClient.set(this, createInstallationsClient());
    }
    async run() {
        const { args } = await this.parse(Install);
        const subreddit = getSubredditNameWithoutPrefix(args.subreddit);
        const inferredParams = await this.inferAppNameAndVersion(args.appWithVersion);
        await this.checkIfUserLoggedIn();
        await this.checkDeveloperAccount();
        const token = await getAccessTokenAndLoginIfNeeded('LocalSocket');
        const userT2Id = await this.getUserT2Id(token);
        let appInfo;
        try {
            appInfo = await getAppBySlug(__classPrivateFieldGet(this, _Install_appClient, "f"), {
                slug: inferredParams.appName,
            });
        }
        catch (err) {
            this.error(`App ${inferredParams.appName} is not found. Please run 'devvit upload' and try again.\n${StringUtil.caughtToString(err, 'message')}`);
        }
        if (!appInfo?.app) {
            this.error(`App ${inferredParams.appName} is not found. Please run 'devvit upload' and try again.`);
        }
        const appVersion = await getVersionByNumber(inferredParams.version, appInfo?.versions);
        const name = appInfo.app.slug;
        const version = DevvitVersion.fromProtoAppVersionInfo(appVersion).toString();
        ux.action.start(`Requesting installation details on ${name}`);
        const [existingInstallInfo, nutrition] = await Promise.all([
            __classPrivateFieldGet(this, _Install_instances, "m", _Install_findExistingInstallation).call(this, {
                subreddit: subreddit,
                appId: appInfo.app.id,
            }),
            __classPrivateFieldGet(this, _Install_appVersionClient, "f").GetNutritionByNameVersion({ name, version }),
        ]);
        if (existingInstallInfo) {
            ux.action.stop(`Currently on version ${DevvitVersion.fromProtoAppVersionInfo(existingInstallInfo.appVersion).toString()}`);
        }
        this.log(nutritionCategoriesToString(name, nutrition.categories));
        ux.action.start(`Installing ${name} to r/${subreddit}`);
        let installationInfo;
        try {
            if (existingInstallInfo) {
                if (existingInstallInfo.appVersion && appVersion.id === existingInstallInfo.appVersion.id) {
                    // exit gracefully if the current app version is already installed
                    ux.action.stop(`Version ${DevvitVersion.fromProtoAppVersionInfo(existingInstallInfo.appVersion).toString()} has already been installed.`);
                    return;
                }
                else {
                    installationInfo = await __classPrivateFieldGet(this, _Install_installationsClient, "f").Upgrade({
                        appVersionId: appVersion.id,
                        id: existingInstallInfo.installation?.id ?? '',
                    });
                }
            }
            else {
                installationInfo = await __classPrivateFieldGet(this, _Install_installationsClient, "f").Create({
                    appVersionId: appVersion.id,
                    runAs: userT2Id,
                    type: InstallationType.SUBREDDIT,
                    location: subreddit,
                    upgradeStrategy: 0,
                });
            }
            ux.action.stop(`Successfully installed version ${DevvitVersion.fromProtoAppVersionInfo(installationInfo.appVersion).toString()}!`);
        }
        catch (err) {
            ux.action.stop('Error');
            this.error(`An error occurred while installing your app: ${StringUtil.caughtToString(err, 'message')}`);
        }
    }
}
_Install_appClient = new WeakMap(), _Install_appVersionClient = new WeakMap(), _Install_installationsClient = new WeakMap(), _Install_instances = new WeakSet(), _Install_findExistingInstallation = async function _Install_findExistingInstallation({ subreddit, appId, }) {
    let existingInstalls = { installations: [] };
    try {
        existingInstalls = await __classPrivateFieldGet(this, _Install_installationsClient, "f").GetAllWithInstallLocation({
            location: subreddit,
            type: InstallationType.SUBREDDIT,
        });
    }
    catch (err) {
        if (err instanceof TwirpError) {
            if (err.code === 'not_found') {
                this.error(`Community '${subreddit}' not found.`);
            }
        }
        throw err;
    }
    const fullInstallInfoList = await Promise.all(existingInstalls.installations.map((install) => {
        // TODO I'm not a fan of having to re-fetch these installs to get the app IDs
        // TODO we should update the protobuf to include the app and app version IDs
        return __classPrivateFieldGet(this, _Install_installationsClient, "f").GetByUUID({ id: install.id });
    }));
    return fullInstallInfoList.find((install) => {
        return install.app?.id === appId;
    });
};
Install.description = 'Install an app from the App Directory to a subreddit that you moderate. Specify the version you want to install, or default to @latest';
Install.examples = [
    '$ devvit install <subreddit> [app-name][@version]',
    '$ devvit install r/MyTestSubreddit',
    '$ devvit install MyOtherTestSubreddit my-app',
    '$ devvit install r/SomeOtherSubreddit my-app@1.2.3',
    '$ devvit install r/AnotherSubreddit @1.2.3',
];
Install.args = {
    subreddit: Args.string({
        description: 'Provide the name of the subreddit where you want to install. The "r/" prefix is optional',
        required: true,
        parse: toLowerCaseArgParser,
    }),
    appWithVersion: Args.string({
        description: 'Provide the name of the app you want to install (defaults to working directory app) and version (defaults to latest)',
        required: false,
        parse: toLowerCaseArgParser,
    }),
};
export default Install;
export function nutritionCategoriesToString(name, cats) {
    if (!cats.length)
        return `${name} requires no permissions!`;
    return `${name} may:\n${cats
        .map((cat) => ` â€¢ ${nutritionCategoryToString[cat] ??
        nutritionCategoryToString[NutritionCategory.UNRECOGNIZED]}`)
        .join(os.EOL)}`;
}
const nutritionCategoryToString = {
    [NutritionCategory.UNCATEGORIZED]: 'Use uncategorized permissions.',
    [NutritionCategory.APP_TRIGGERS]: 'Execute when installed or upgraded.',
    [NutritionCategory.ASSETS]: 'Present predefined audio-visual media.',
    [NutritionCategory.DATA]: 'Read and write _app_ data to Reddit servers.',
    [NutritionCategory.HTTP]: 'Read and write _any_ data to and from the internet.',
    [NutritionCategory.MODERATOR]: "Appear and act as a moderator on subreddits where it's installed.",
    [NutritionCategory.MODLOG]: 'Read and write to Reddit moderator logs.',
    [NutritionCategory.PAYMENTS]: 'Sell digital goods or services.',
    [NutritionCategory.REDDIT_API]: 'Read and write _any_ Reddit data.',
    [NutritionCategory.REDDIT_TRIGGERS]: 'Observe Reddit events such as post creation, comment deletion, and more.',
    [NutritionCategory.SCHEDULER]: 'Schedule itself for later execution.',
    [NutritionCategory.UI]: 'Appear in subreddit, post, and comment menu entries, and custom posts.',
    [NutritionCategory.UNRECOGNIZED]: 'Use unknown permissions.',
    [NutritionCategory.WEBVIEW]: 'Embed webapps to display rich content.',
    [NutritionCategory.CUSTOM_POST]: 'Can create a custom post.',
    [NutritionCategory.USER_ACTIONS]: 'Can call Reddit APIs on behalf of the user.',
};
