var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _BundleActor_instances, _BundleActor_makeBundles, _BundleActor_getOwnerUsername;
import { mkdir, writeFile } from 'node:fs/promises';
import path from 'node:path';
import { Bundle } from '@devvit/protos/types/devvit/plugin/buildpack/buildpack_common.js';
import { ActorSpec, TargetRuntime } from '@devvit/protos/types/devvit/runtime/bundle.js';
import { Args, Flags } from '@oclif/core';
import { getAccessToken } from '../../util/auth.js';
import { Bundler } from '../../util/Bundler.js';
import { toLowerCaseArgParser } from '../../util/commands/DevvitCommand.js';
import { DevvitCommand } from '../../util/commands/DevvitCommand.js';
import { distDirFilename } from '../../util/config.js';
import { getPaymentsConfig, readProducts } from '../../util/payments/paymentsConfig.js';
class BundleActor extends DevvitCommand {
    constructor() {
        super(...arguments);
        _BundleActor_instances.add(this);
    }
    async run() {
        const { args, flags } = await this.parse(BundleActor);
        const username = await __classPrivateFieldGet(this, _BundleActor_instances, "m", _BundleActor_getOwnerUsername).call(this);
        const actorSpec = {
            name: args.name,
            owner: username,
            version: '0.0.0', // Version is unknown.
        };
        await __classPrivateFieldGet(this, _BundleActor_instances, "m", _BundleActor_makeBundles).call(this, actorSpec, flags.metafile);
        this.log(`Successfully bundled actor: ${actorSpec.name}`);
    }
}
_BundleActor_instances = new WeakSet(), _BundleActor_makeBundles = async function _BundleActor_makeBundles(actorSpec, includeMetafile) {
    const actorBundler = new Bundler();
    const bundles = await actorBundler.bundle(this.project, actorSpec, includeMetafile);
    const products = await readProducts(this.project.root);
    await mkdir(path.join(this.project.root, distDirFilename), { recursive: true });
    await Promise.all(bundles.map(async (bundle) => {
        const target = bundle.buildInfo?.targetRuntime ?? TargetRuntime.UNIVERSAL;
        let type = '';
        if (target === TargetRuntime.CLIENT) {
            type = '.client';
        }
        if (products) {
            bundle.paymentsConfig = getPaymentsConfig(this.project.mediaDir, bundle, products, false);
        }
        await writeFile(path.join(this.project.root, distDirFilename, `${actorSpec.name}.bundle${type}.json`), JSON.stringify(Bundle.toJSON(bundle)));
        if (bundle.metafile) {
            await writeFile(path.join(this.project.root, distDirFilename, `${actorSpec.name}.metafile${type}.json`), bundle.metafile);
        }
    }));
}, _BundleActor_getOwnerUsername = async function _BundleActor_getOwnerUsername() {
    let username = '';
    try {
        const token = await getAccessToken();
        if (token) {
            username = await this.getUserDisplayName(token);
        }
    }
    catch {
        // Username is unavailable.
    }
    if (!username) {
        this.warn(`You are not logged in: setting "username" as empty`);
    }
    return username;
};
BundleActor.description = 'Bundle an actor into bundle.json';
BundleActor.examples = ['$ devvit bundle actor my-actor'];
BundleActor.args = {
    name: Args.string({
        description: 'The name of of the actor to bundle',
        required: false,
        parse: toLowerCaseArgParser,
        default: 'main',
    }),
};
BundleActor.flags = {
    metafile: Flags.boolean({
        description: 'Produce a metafile to analyze the size of the bundle',
        required: false,
    }),
};
BundleActor.hidden = true;
export default BundleActor;
