var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var _Playtest_instances, _a, _Playtest_installationsClient, _Playtest_appClient, _Playtest_appVersionClient, _Playtest_bundler, _Playtest_subreddit, _Playtest_flags, _Playtest_appInfo, _Playtest_version, _Playtest_installationInfo, _Playtest_lastBundles, _Playtest_lastQueuedBundles, _Playtest_isOnWatchExecuting, _Playtest_appLogSub, _Playtest_watchAssets, _Playtest_watchConfigFile, _Playtest_watchSrc, _Playtest_server, _Playtest_getExistingInstallInfo, _Playtest_startWatchingSrc, _Playtest_startWatchingAssets, _Playtest_startWatchingConfigFile, _Playtest_onConfigFileModified, _Playtest_onWatch, _Playtest_onWatchActual, _Playtest_onWatchError, _Playtest_runQueuedBundlePlaytest, _Playtest_checkIfUserAllowedToPlaytestThisApp, _Playtest_destroyWatchers, _Playtest_onExit, _Playtest_refreshAppInfoAndSetSubreddit;
import { updateBundleServer, updateBundleVersion } from '@devvit/build-pack/esbuild/ESBuildPack.js';
import { InstallationType, VersionVisibility } from '@devvit/protos/community.js';
import { ACTOR_SRC_DIR, ACTOR_SRC_PRIMARY_NAME, MAX_ALLOWED_SUBSCRIBER_COUNT, PRODUCTS_JSON_FILE, } from '@devvit/shared-types/constants.js';
import { debounce } from '@devvit/shared-types/debounce.js';
import { StringUtil } from '@devvit/shared-types/StringUtil.js';
import { DevvitVersion, VersionBumpType } from '@devvit/shared-types/Version.js';
import { Args, Flags, ux } from '@oclif/core';
import chalk from 'chalk';
import chokidar from 'chokidar';
import { existsSync } from 'fs';
import path from 'path';
import { map } from 'rxjs';
import { TwirpError, TwirpErrorCode } from 'twirp-ts';
import { REDDIT_DESKTOP } from '../lib/config.js';
import { fetchSubredditSubscriberCount, isCurrentUserEmployee } from '../lib/http/gql.js';
import { PlaytestServer } from '../lib/playtest-server.js';
import { makeLogSubscription } from '../util/app-logs/make-log-subscription.js';
import { AppVersionUploader } from '../util/AppVersionUploader.js';
import { getAccessTokenAndLoginIfNeeded } from '../util/auth.js';
import { Bundler } from '../util/Bundler.js';
import { checkAppNameAvailability } from '../util/checkAppNameAvailability.js';
import { createAppClient, createAppVersionClient, createInstallationsClient, } from '../util/clientGenerators.js';
import { toLowerCaseArgParser } from '../util/commands/DevvitCommand.js';
import { DevvitCommand } from '../util/commands/DevvitCommand.js';
import { getSubredditNameWithoutPrefix } from '../util/common-actions/getSubredditNameWithoutPrefix.js';
import { installOnSubreddit } from '../util/common-actions/installOnSubreddit.js';
import { waitUntilVersionBuildComplete } from '../util/common-actions/waitUntilVersionBuildComplete.js';
import { getAppBySlug } from '../util/getAppBySlug.js';
import { isWebContainer } from '../util/platform-util.js';
import { devvitClassicConfigFilename, devvitV1ConfigFilename } from '../util/project.js';
import Logs from './logs.js';
class Playtest extends DevvitCommand {
    constructor() {
        super(...arguments);
        _Playtest_instances.add(this);
        // API Clients
        _Playtest_installationsClient.set(this, createInstallationsClient());
        _Playtest_appClient.set(this, createAppClient());
        _Playtest_appVersionClient.set(this, createAppVersionClient());
        _Playtest_bundler.set(this, void 0);
        // Args
        _Playtest_subreddit.set(this, void 0); // unprefixed
        _Playtest_flags.set(this, void 0);
        // State
        _Playtest_appInfo.set(this, void 0);
        _Playtest_version.set(this, void 0);
        _Playtest_installationInfo.set(this, void 0);
        _Playtest_lastBundles.set(this, void 0);
        _Playtest_lastQueuedBundles.set(this, void 0);
        _Playtest_isOnWatchExecuting.set(this, false);
        // Processes
        _Playtest_appLogSub.set(this, void 0);
        _Playtest_watchAssets.set(this, void 0);
        _Playtest_watchConfigFile.set(this, void 0);
        _Playtest_watchSrc.set(this, void 0);
        _Playtest_server.set(this, void 0);
        _Playtest_onConfigFileModified.set(this, async (ev, file) => {
            // Does the file exist?
            if (ev !== 'add' && ev !== 'change')
                return;
            // Is the file the config?
            const baseFile = path.basename(file);
            if ((__classPrivateFieldGet(this, _Playtest_flags, "f")?.config &&
                path.resolve(this.project.root, __classPrivateFieldGet(this, _Playtest_flags, "f").config) !== path.resolve(file)) ||
                (!__classPrivateFieldGet(this, _Playtest_flags, "f")?.config &&
                    baseFile !== devvitV1ConfigFilename &&
                    baseFile !== devvitClassicConfigFilename))
                return;
            ux.action.start(`Reloading config`);
            try {
                await this.init();
            }
            catch (err) {
                ux.action.stop(`Error: ${StringUtil.caughtToString(err, 'message')}.`);
                return;
            }
            ux.action.stop(`OK`);
            await __classPrivateFieldGet(this, _Playtest_instances, "m", _Playtest_destroyWatchers).call(this);
            await this.run();
        });
        _Playtest_onWatch.set(this, debounce((result) => {
            void __classPrivateFieldGet(this, _Playtest_onWatchActual, "f").call(this, result);
        }, 
        // Use a lambda here, because value won't be set at class construction time.
        () => this.project.watchDebounceMillis));
        _Playtest_onWatchActual.set(this, async (result) => {
            /* We have to do this here because none of the rxjs functions fit this use case perfectly. What
             * we need is something that serializes this whole pipeline, but also discards all but the most
             * recent value once we resume processing. We would love to use one of these, but...
             * - concatMap(): Serializes the pipeline correctly but doesn't discard intermediate values. We
             *    only care about the latest bundle, not a queue of bundles.
             * - exhaustMap(): Serializes the pipeline correctly but won't enqueue the latest value.
             * - switchMap(): Takes the latest value correctly but doesn't serialize the pipeline, and we
             *    don't support cancel.
             * There is probably a way to do this using pure RxJS, but it seems substantially more difficult
             * than just doing it ourselves here.
             */
            if (__classPrivateFieldGet(this, _Playtest_isOnWatchExecuting, "f")) {
                // if we're already executing, queue this watch to be executed after we're done
                __classPrivateFieldSet(this, _Playtest_lastQueuedBundles, result.bundles, "f");
                return;
            }
            // No bundles produced, ignore
            if (!result.bundles?.length) {
                return;
            }
            if (this.project.server &&
                !existsSync(path.resolve(this.project.root, this.project.server.dir, this.project.server.entry))) {
                // User may be in the process of building a server entry. Wait.
                return;
            }
            __classPrivateFieldSet(this, _Playtest_lastBundles, result.bundles, "f");
            __classPrivateFieldSet(this, _Playtest_isOnWatchExecuting, true, "f");
            if (!__classPrivateFieldGet(this, _Playtest_appInfo, "f")?.app) {
                this.error(`Something went wrong: App ${this.project.name} is not found`);
            }
            if (!__classPrivateFieldGet(this, _Playtest_version, "f")) {
                this.error('Something went wrong: no version of this app exists.');
            }
            // 1. bump playtest version:
            __classPrivateFieldGet(this, _Playtest_version, "f").bumpVersion(VersionBumpType.Prerelease);
            try {
                // 2. update bundle:
                updateBundleVersion(__classPrivateFieldGet(this, _Playtest_lastBundles, "f"), __classPrivateFieldGet(this, _Playtest_version, "f").toString());
                try {
                    updateBundleServer(__classPrivateFieldGet(this, _Playtest_lastBundles, "f"), this.project.root, this.project.server);
                }
                catch (err) {
                    this.error(err instanceof Error ? err.message : String(err), {
                        exit: false,
                    });
                    return;
                }
                // 3. create new playtest version:
                const appVersionCreator = new AppVersionUploader(this, {
                    verbose: Boolean(__classPrivateFieldGet(this, _Playtest_flags, "f")?.verbose),
                });
                const appVersionInfo = await appVersionCreator.createVersion({
                    appId: __classPrivateFieldGet(this, _Playtest_appInfo, "f").app.id,
                    appSlug: __classPrivateFieldGet(this, _Playtest_appInfo, "f").app.slug,
                    appSemver: __classPrivateFieldGet(this, _Playtest_version, "f"),
                    visibility: VersionVisibility.PRIVATE,
                }, __classPrivateFieldGet(this, _Playtest_lastBundles, "f"), true // The playtest subreddit should've already been created so we prevent creating a new one
                );
                if (__classPrivateFieldGet(this, _Playtest_lastQueuedBundles, "f")) {
                    // No need to go further if there's a newer playtest version is waiting
                    __classPrivateFieldGet(this, _Playtest_instances, "m", _Playtest_runQueuedBundlePlaytest).call(this, __classPrivateFieldGet(this, _Playtest_lastQueuedBundles, "f"));
                    return;
                }
                // 5. confirm new version has finished building
                await waitUntilVersionBuildComplete(this, __classPrivateFieldGet(this, _Playtest_appVersionClient, "f"), appVersionInfo);
                if (__classPrivateFieldGet(this, _Playtest_lastQueuedBundles, "f")) {
                    // No need to go further if there's a newer playtest version is waiting
                    __classPrivateFieldGet(this, _Playtest_instances, "m", _Playtest_runQueuedBundlePlaytest).call(this, __classPrivateFieldGet(this, _Playtest_lastQueuedBundles, "f"));
                    return;
                }
                // 6. install playtest version to specified subreddit:
                ux.action.start(`Installing playtest version ${__classPrivateFieldGet(this, _Playtest_version, "f")}`);
                await __classPrivateFieldGet(this, _Playtest_installationsClient, "f").Upgrade({
                    id: __classPrivateFieldGet(this, _Playtest_installationInfo, "f").installation.id,
                    appVersionId: appVersionInfo.id,
                });
                __classPrivateFieldGet(this, _Playtest_server, "f")?.send({ appInstalled: {} });
                const playtestUrl = chalk.bold.green(`${REDDIT_DESKTOP}/r/${__classPrivateFieldGet(this, _Playtest_subreddit, "f")}/${__classPrivateFieldGet(this, _Playtest_flags, "f")?.connect ? `?playtest=${__classPrivateFieldGet(this, _Playtest_appInfo, "f").app.slug}` : ''}`);
                ux.action.stop(`Success! Please visit your test subreddit and refresh to see your latest changes:\n${playtestUrl}\n`);
            }
            catch (err) {
                ux.action.stop('Error'); // Stop any spinner if it's running
                this.log(chalk.red(`Something went wrong... ${StringUtil.caughtToString(err, 'message')}`));
            }
            finally {
                __classPrivateFieldSet(this, _Playtest_isOnWatchExecuting, false, "f");
            }
            if (__classPrivateFieldGet(this, _Playtest_lastQueuedBundles, "f")) {
                __classPrivateFieldGet(this, _Playtest_instances, "m", _Playtest_runQueuedBundlePlaytest).call(this, __classPrivateFieldGet(this, _Playtest_lastQueuedBundles, "f"));
            }
        });
        _Playtest_onWatchError.set(this, (err) => {
            this.error(`watch error: ${StringUtil.caughtToString(err, 'message')}`);
        });
        _Playtest_onExit.set(this, async () => {
            await __classPrivateFieldGet(this, _Playtest_instances, "m", _Playtest_destroyWatchers).call(this);
            ux.action.stop('Stopped');
            // If this.#installationInfo exists that means a playtest version has already been installed
            if (__classPrivateFieldGet(this, _Playtest_installationInfo, "f")) {
                const revertCommand = chalk.green(`devvit install ${__classPrivateFieldGet(this, _Playtest_subreddit, "f")} ${this.project.name}@latest`);
                this.log(`To revert back to the latest non-playtest version of the app, run: \n${revertCommand}`);
            }
            process.exit(0);
        });
    }
    async run() {
        // Despite the name, finally() is only invoked on successful termination.
        process.on('SIGINT', __classPrivateFieldGet(this, _Playtest_onExit, "f"));
        const { args, flags } = await this.parse(_a);
        __classPrivateFieldSet(this, _Playtest_flags, flags, "f");
        __classPrivateFieldSet(this, _Playtest_bundler, new Bundler(), "f");
        this.project.flag.watchDebounceMillis = __classPrivateFieldGet(this, _Playtest_flags, "f")?.['debounce'];
        this.project.flag.subreddit = args.subreddit;
        const token = await getAccessTokenAndLoginIfNeeded(isWebContainer() ? 'CopyPaste' : 'LocalSocket');
        const username = await this.getUserDisplayName(token);
        await this.checkDeveloperAccount();
        if (flags.connect) {
            __classPrivateFieldSet(this, _Playtest_server, new PlaytestServer({
                dateFormat: undefined,
                runtime: flags['log-runtime'],
                verbose: flags.verbose,
                showTimestamps: flags['show-timestamps'],
            }, this), "f");
            __classPrivateFieldGet(this, _Playtest_server, "f").open();
        }
        __classPrivateFieldSet(this, _Playtest_appInfo, await getAppBySlug(__classPrivateFieldGet(this, _Playtest_appClient, "f"), {
            slug: this.project.name,
            limit: 1, // fetched version limit; we only need the latest one
        }), "f");
        if (!__classPrivateFieldGet(this, _Playtest_appInfo, "f")?.app) {
            this.error("Your app doesn't exist yet - you'll need to run 'npm create devvit' before you can playtest your app.");
        }
        this.project.app.defaultPlaytestSubredditId = __classPrivateFieldGet(this, _Playtest_appInfo, "f").app.defaultPlaytestSubredditId;
        const isOwner = __classPrivateFieldGet(this, _Playtest_appInfo, "f")?.app?.owner?.displayName === username;
        await __classPrivateFieldGet(this, _Playtest_instances, "m", _Playtest_checkIfUserAllowedToPlaytestThisApp).call(this, this.project.name, isOwner, token, flags['employee-update']);
        // Set the target subreddit to the passed argument, or to the config subreddit, or to the app's default, in this order.
        // If none of these are set, it will be undefined, and we will create a new playtest subreddit.
        const targetSubreddit = this.project.getSubreddit('Dev');
        if (targetSubreddit) {
            __classPrivateFieldSet(this, _Playtest_subreddit, getSubredditNameWithoutPrefix(targetSubreddit), "f");
        }
        const shouldWriteToConfig = !__classPrivateFieldGet(this, _Playtest_subreddit, "f");
        let latestVersion;
        if (__classPrivateFieldGet(this, _Playtest_appInfo, "f").versions.length > 0 && __classPrivateFieldGet(this, _Playtest_appInfo, "f").versions[0]) {
            latestVersion = __classPrivateFieldGet(this, _Playtest_appInfo, "f").versions[0];
        }
        else {
            // Need to upload version 0.0.1
            const firstVersion = new DevvitVersion(0, 0, 1);
            const appVersionCreator = new AppVersionUploader(this, {
                verbose: Boolean(__classPrivateFieldGet(this, _Playtest_flags, "f")?.verbose),
            });
            const bundles = await __classPrivateFieldGet(this, _Playtest_bundler, "f").bundle(this.project, {
                name: ACTOR_SRC_PRIMARY_NAME,
                owner: username,
                version: firstVersion.toString(),
            });
            this.log(chalk.green(`We'll create a default playtest subreddit for your app!`));
            latestVersion = await appVersionCreator.createVersion({
                appId: __classPrivateFieldGet(this, _Playtest_appInfo, "f").app.id,
                appSlug: __classPrivateFieldGet(this, _Playtest_appInfo, "f").app.slug,
                appSemver: firstVersion,
                visibility: VersionVisibility.PRIVATE,
            }, bundles, false);
            await __classPrivateFieldGet(this, _Playtest_instances, "m", _Playtest_refreshAppInfoAndSetSubreddit).call(this);
            // Delay writing to the config so we can write the subreddit name from the installation instead of the ID
        }
        __classPrivateFieldSet(this, _Playtest_version, new DevvitVersion(latestVersion.majorVersion, latestVersion.minorVersion, latestVersion.patchVersion, latestVersion.prereleaseVersion), "f");
        if (__classPrivateFieldGet(this, _Playtest_subreddit, "f")) {
            // alert user if they're about to run playtest in a large subreddit
            const subscriberCount = await fetchSubredditSubscriberCount(__classPrivateFieldGet(this, _Playtest_subreddit, "f"), token);
            if (subscriberCount > MAX_ALLOWED_SUBSCRIBER_COUNT) {
                this.error(`Playtest can only be used in a small test subreddit. Please try again in a community with less than ${MAX_ALLOWED_SUBSCRIBER_COUNT} members.`);
            }
        }
        else {
            this.log(chalk.green(`We'll create a default playtest subreddit for your app!`));
            // TODO: consider having a dedicated endpoint to create the playtest subreddit so we don't have to upload a new version
            // We need to upload a new version to create a new playtest subreddit
            __classPrivateFieldGet(this, _Playtest_version, "f").bumpVersion(VersionBumpType.Prerelease);
            const appVersionCreator = new AppVersionUploader(this, {
                verbose: Boolean(__classPrivateFieldGet(this, _Playtest_flags, "f")?.verbose),
            });
            const bundles = await __classPrivateFieldGet(this, _Playtest_bundler, "f").bundle(this.project, {
                name: ACTOR_SRC_PRIMARY_NAME,
                owner: username,
                version: __classPrivateFieldGet(this, _Playtest_version, "f").toString(),
            });
            latestVersion = await appVersionCreator.createVersion({
                appId: __classPrivateFieldGet(this, _Playtest_appInfo, "f").app.id,
                appSlug: __classPrivateFieldGet(this, _Playtest_appInfo, "f").app.slug,
                appSemver: __classPrivateFieldGet(this, _Playtest_version, "f"),
                visibility: VersionVisibility.PRIVATE,
            }, bundles, false);
            await __classPrivateFieldGet(this, _Playtest_instances, "m", _Playtest_refreshAppInfoAndSetSubreddit).call(this);
            // Delay writing to the config so we can write the subreddit name from the installation instead of the ID
        }
        if (!__classPrivateFieldGet(this, _Playtest_subreddit, "f")) {
            this.error('Something went wrong: we should have a subreddit by now. Please playtest on a different subreddit using `devvit playtest <your_subreddit>` instead.');
        }
        // before starting playtest session, make sure app has been installed to the test subreddit:
        __classPrivateFieldSet(this, _Playtest_installationInfo, await __classPrivateFieldGet(this, _Playtest_instances, "m", _Playtest_getExistingInstallInfo).call(this, this.project.name, __classPrivateFieldGet(this, _Playtest_subreddit, "f")), "f");
        if (!__classPrivateFieldGet(this, _Playtest_installationInfo, "f")) {
            ux.action.start(`Installing`);
            try {
                const userT2Id = await this.getUserT2Id(token);
                __classPrivateFieldSet(this, _Playtest_installationInfo, await installOnSubreddit(this, __classPrivateFieldGet(this, _Playtest_appVersionClient, "f"), __classPrivateFieldGet(this, _Playtest_installationsClient, "f"), userT2Id, latestVersion, __classPrivateFieldGet(this, _Playtest_subreddit, "f")), "f");
                ux.action.stop();
            }
            catch (err) {
                ux.action.stop('Error');
                this.error(`An error occurred while installing your app: ${StringUtil.caughtToString(err, 'message')}`);
            }
        }
        __classPrivateFieldSet(this, _Playtest_subreddit, __classPrivateFieldGet(this, _Playtest_installationInfo, "f").installation.location.name, "f");
        if (shouldWriteToConfig) {
            this.project.setSubreddit(__classPrivateFieldGet(this, _Playtest_subreddit, "f"), 'Dev'); // Write the new default playtest subreddit to the project config
        }
        __classPrivateFieldSet(this, _Playtest_appLogSub, makeLogSubscription({
            subreddit: __classPrivateFieldGet(this, _Playtest_installationInfo, "f").installation.location.id,
            appName: this.project.name,
        }, this, flags), "f");
        __classPrivateFieldGet(this, _Playtest_instances, "m", _Playtest_startWatchingSrc).call(this, username);
        __classPrivateFieldGet(this, _Playtest_instances, "m", _Playtest_startWatchingAssets).call(this);
        __classPrivateFieldGet(this, _Playtest_instances, "m", _Playtest_startWatchingConfigFile).call(this);
        // We don't know when the user is done. If connected to a terminal, end when
        // stdin is closed. Otherwise, close immediately to avoid the chance that
        // forever processes are created. This is the approach taken by esbuild,
        // https://github.com/evanw/esbuild/commit/77194c8.
        if (process.stdin.isTTY) {
            await new Promise((resolve) => process.stdin.once('close', resolve));
        }
    }
    async init() {
        await super.init('Dynamic');
    }
}
_a = Playtest, _Playtest_installationsClient = new WeakMap(), _Playtest_appClient = new WeakMap(), _Playtest_appVersionClient = new WeakMap(), _Playtest_bundler = new WeakMap(), _Playtest_subreddit = new WeakMap(), _Playtest_flags = new WeakMap(), _Playtest_appInfo = new WeakMap(), _Playtest_version = new WeakMap(), _Playtest_installationInfo = new WeakMap(), _Playtest_lastBundles = new WeakMap(), _Playtest_lastQueuedBundles = new WeakMap(), _Playtest_isOnWatchExecuting = new WeakMap(), _Playtest_appLogSub = new WeakMap(), _Playtest_watchAssets = new WeakMap(), _Playtest_watchConfigFile = new WeakMap(), _Playtest_watchSrc = new WeakMap(), _Playtest_server = new WeakMap(), _Playtest_onConfigFileModified = new WeakMap(), _Playtest_onWatch = new WeakMap(), _Playtest_onWatchActual = new WeakMap(), _Playtest_onWatchError = new WeakMap(), _Playtest_onExit = new WeakMap(), _Playtest_instances = new WeakSet(), _Playtest_getExistingInstallInfo = async function _Playtest_getExistingInstallInfo(appName, subreddit) {
    ux.action.start(`Checking for existing installation`);
    try {
        const result = await __classPrivateFieldGet(this, _Playtest_installationsClient, "f").GetByAppNameAndInstallLocation({
            location: subreddit,
            type: InstallationType.SUBREDDIT,
            slug: appName,
        });
        ux.action.stop();
        return result;
    }
    catch (err) {
        if (err instanceof TwirpError && err.code === TwirpErrorCode.NotFound) {
            ux.action.stop(`No existing installation found.`);
            // ignore
            return;
        }
        else {
            ux.action.stop();
            this.error('Something went wrong when checking for existing installations');
        }
    }
}, _Playtest_startWatchingSrc = function _Playtest_startWatchingSrc(username) {
    if (!__classPrivateFieldGet(this, _Playtest_bundler, "f"))
        throw Error('no bundler');
    const watchSrc = __classPrivateFieldGet(this, _Playtest_bundler, "f").watch(this.project, this.project.root, {
        name: ACTOR_SRC_PRIMARY_NAME,
        owner: username,
        // Version is always incorrect since it changes on each upload and the
        // watch request isn't reissued.
        version: '0.0.0',
    });
    // Async subscribers are
    // unsupported (https://github.com/ReactiveX/rxjs/issues/2827). Pipe all
    // bundles through an asynchronous observable and only open a subscription
    // for errors. We just dispose the source (bundler) to unsubscribe.
    __classPrivateFieldSet(this, _Playtest_watchSrc, watchSrc
        .pipe(map((result) => __classPrivateFieldGet(this, _Playtest_onWatch, "f").call(this, result)))
        .subscribe({ error: __classPrivateFieldGet(this, _Playtest_onWatchError, "f") }), "f");
}, _Playtest_startWatchingAssets = function _Playtest_startWatchingAssets() {
    const productsJSON = path.join(this.project.root, ACTOR_SRC_DIR, PRODUCTS_JSON_FILE);
    const assetPaths = [productsJSON];
    if (this.project.mediaDir)
        assetPaths.push(path.join(this.project.root, this.project.mediaDir));
    if (this.project.clientDir)
        assetPaths.push(path.join(this.project.root, this.project.clientDir));
    if (this.project.server)
        // Watch the server directory to allow the watched file to be renamed or deleted.
        assetPaths.push(path.join(this.project.root, this.project.server.dir, '..'));
    if (this.project.appConfig?.marketingAssets?.icon) {
        assetPaths.push(path.join(this.project.root, this.project.appConfig.marketingAssets.icon));
    }
    __classPrivateFieldSet(this, _Playtest_watchAssets, chokidar.watch(assetPaths, { ignoreInitial: true }), "f");
    __classPrivateFieldGet(this, _Playtest_watchAssets, "f").on('all', () => {
        // asset changes don't result in a code change, so just re-send the last bundles
        __classPrivateFieldGet(this, _Playtest_onWatch, "f").call(this, { bundles: __classPrivateFieldGet(this, _Playtest_lastBundles, "f") });
    });
}, _Playtest_startWatchingConfigFile = function _Playtest_startWatchingConfigFile() {
    // Watch the owning directory to support deletes and renames.
    const files = __classPrivateFieldGet(this, _Playtest_flags, "f")?.config
        ? [path.dirname(path.resolve(this.project.root, this.project.filename))]
        : [path.resolve(this.project.root)];
    __classPrivateFieldSet(this, _Playtest_watchConfigFile, chokidar.watch(files, {
        ignoreInitial: true,
        depth: 0,
    }), "f");
    __classPrivateFieldGet(this, _Playtest_watchConfigFile, "f").on('all', __classPrivateFieldGet(this, _Playtest_onConfigFileModified, "f"));
}, _Playtest_runQueuedBundlePlaytest = function _Playtest_runQueuedBundlePlaytest(newerBundles) {
    this.log('Starting a new build...');
    __classPrivateFieldSet(this, _Playtest_isOnWatchExecuting, false, "f");
    __classPrivateFieldSet(this, _Playtest_lastQueuedBundles, undefined, "f");
    __classPrivateFieldGet(this, _Playtest_onWatch, "f").call(this, { bundles: newerBundles });
}, _Playtest_checkIfUserAllowedToPlaytestThisApp = async function _Playtest_checkIfUserAllowedToPlaytestThisApp(appName, isOwner, token, employeeUpdateFlag) {
    if (isOwner) {
        return;
    }
    if (employeeUpdateFlag) {
        const isEmployee = await isCurrentUserEmployee(token);
        if (!isEmployee) {
            this.error(`You're not an employee, so you can't playtest someone else's app.`);
        }
        // Else, we're an employee, so we can update someone else's app
        this.warn(`Overriding ownership check because you're an employee and told me to!`);
    }
    else {
        // Check if the app name is available, implying this is a first run
        const appExists = await checkAppNameAvailability(__classPrivateFieldGet(this, _Playtest_appClient, "f"), appName);
        if (appExists.exists) {
            this.error(`That app already exists, and you can't playtest someone else's app!`);
        }
        // App doesn't exist - tell the user to run `devvit upload` first
        this.error("Your app doesn't exist yet - you'll need to run 'devvit upload' once before you can playtest your app.");
    }
}, _Playtest_destroyWatchers = async function _Playtest_destroyWatchers() {
    process.removeListener('SIGINT', __classPrivateFieldGet(this, _Playtest_onExit, "f"));
    __classPrivateFieldGet(this, _Playtest_watchSrc, "f")?.unsubscribe();
    __classPrivateFieldGet(this, _Playtest_appLogSub, "f")?.unsubscribe();
    await __classPrivateFieldGet(this, _Playtest_bundler, "f")?.dispose();
    __classPrivateFieldGet(this, _Playtest_server, "f")?.close();
    await __classPrivateFieldGet(this, _Playtest_watchAssets, "f")?.close();
    await __classPrivateFieldGet(this, _Playtest_watchConfigFile, "f")?.close();
    __classPrivateFieldGet(this, _Playtest_onWatch, "f").clear();
}, _Playtest_refreshAppInfoAndSetSubreddit = async function _Playtest_refreshAppInfoAndSetSubreddit() {
    __classPrivateFieldSet(this, _Playtest_appInfo, await getAppBySlug(__classPrivateFieldGet(this, _Playtest_appClient, "f"), {
        slug: this.project.name,
        limit: 1, // fetched version limit; we only need the latest one
    }), "f");
    if (!__classPrivateFieldGet(this, _Playtest_appInfo, "f")?.app) {
        this.error('Something went wrong: we could not find your app. Please try again.');
    }
    else if (!__classPrivateFieldGet(this, _Playtest_appInfo, "f").app.defaultPlaytestSubredditId && !__classPrivateFieldGet(this, _Playtest_subreddit, "f")) {
        this.error('Something went wrong: we could not find the newly created playtest subreddit. Please playtest on a different subreddit using `devvit playtest <your_subreddit>` instead.');
    }
    __classPrivateFieldSet(this, _Playtest_subreddit, __classPrivateFieldGet(this, _Playtest_subreddit, "f") ?? __classPrivateFieldGet(this, _Playtest_appInfo, "f").app.defaultPlaytestSubredditId, "f");
};
Playtest.description = 'Installs your app to your test subreddit and starts a playtest session where a new version is installed whenever you save changes to your app code, and logs are continuously streamed';
Playtest.examples = [
    '$ devvit playtest',
    '$ devvit playtest <subreddit>',
    '$ devvit playtest r/myTestSubreddit',
    '$ devvit playtest myOtherTestSubreddit',
];
Playtest.flags = {
    ...Logs.flags,
    'employee-update': Flags.boolean({
        aliases: ['employeeUpdate'],
        description: "I'm an employee and I want to update someone else's app. (This will only work if you're an employee.)",
        required: false,
        hidden: true,
    }),
    debounce: Flags.integer({
        description: 'Debounce time in milliseconds for file changes',
        required: false,
    }),
};
Playtest.args = {
    subreddit: Args.string({
        description: `Provide the name of a small test subreddit with <${MAX_ALLOWED_SUBSCRIBER_COUNT} members. The "r/" prefix is optional. Leaving this empty will use the subreddit set in the in the "dev.subreddit" field of devvit.json. If neither is set, we will create a "r/[app-name]_dev" subreddit for you.`,
        required: false,
        parse: toLowerCaseArgParser,
    }),
};
export default Playtest;
