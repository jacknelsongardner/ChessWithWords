var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _AddProduct_instances, _a, _AddProduct_prompt, _AddProduct_getProductsConfig, _AddProduct_getAvailableAssets;
import { readdir, writeFile } from 'node:fs/promises';
import { PRODUCTS_JSON_FILE } from '@devvit/shared-types/constants.js';
import { AccountingType } from '@devvit/shared-types/payments/Product.js';
import { Args, Flags, ux } from '@oclif/core';
import chalk from 'chalk';
import inquirer from 'inquirer';
import * as path from 'path';
import { DevvitCommand } from '../../util/commands/DevvitCommand.js';
import { readProducts } from '../../util/payments/paymentsConfig.js';
// TODO: Import these from the products.json schema file.
const ALLOWED_PRICES = [5, 25, 50, 100, 150, 250, 500, 1000, 2500];
const ACCOUNTING_TYPE_TO_LABEL = {
    INSTANT: `Instant: ${chalk.dim('Is used immediately and disappears.')}`,
    DURABLE: `Durable: ${chalk.dim('Is permanently applied to the account and can be used any number of times.')}`,
    CONSUMABLE: `Consumable: ${chalk.dim('Can be used at a later date but is removed once it is used.')}`,
    VALID_FOR_1D: `Valid for 1 day: ${chalk.dim('Can be used for 1 day after purchase.')}`,
    VALID_FOR_7D: `Valid for 7 days: ${chalk.dim('Can be used for 7 days after purchase.')}`,
    VALID_FOR_30D: `Valid for 30 days: ${chalk.dim('Can be used for 30 days after purchase.')}`,
    VALID_FOR_1Y: `Valid for 1 year: ${chalk.dim('Can be used for 1 year after purchase.')}`,
};
const LABEL_TO_ACCOUNTING_TYPE = Object.fromEntries(Object.entries(ACCOUNTING_TYPE_TO_LABEL).map(([key, value]) => [
    value,
    key,
]));
class AddProduct extends DevvitCommand {
    constructor() {
        super(...arguments);
        _AddProduct_instances.add(this);
    }
    get productsFilePath() {
        return path.join(this.project.root, 'src', PRODUCTS_JSON_FILE);
    }
    async run() {
        const { args, flags } = await this.parse(_a);
        const { sku } = args;
        const { name: displayName, description, price, type, icon } = flags;
        const accountingType = type;
        const productsJSON = await __classPrivateFieldGet(this, _AddProduct_instances, "m", _AddProduct_getProductsConfig).call(this);
        const existingSKUs = productsJSON.products.map((product) => product.sku);
        if (sku && existingSKUs.includes(sku)) {
            this.error(`A product with SKU "${sku}" already exists. Please provide a unique SKU.`);
        }
        const availableAssets = await __classPrivateFieldGet(this, _AddProduct_instances, "m", _AddProduct_getAvailableAssets).call(this);
        if (icon && !availableAssets.includes(icon)) {
            this.error(`File "${icon}" was not found in the assets directory.`);
        }
        // The exactOptionalPropertyTypes TS setting does not allow for partial types with undefined values
        // so we need to manually create a partial object with only the defined values.
        const prefilledProduct = {};
        if (sku)
            prefilledProduct.sku = sku;
        if (displayName)
            prefilledProduct.displayName = displayName;
        if (description)
            prefilledProduct.description = description;
        if (price)
            prefilledProduct.price = price;
        if (accountingType)
            prefilledProduct.accountingType = accountingType;
        if (icon)
            prefilledProduct.images = { icon };
        const product = await __classPrivateFieldGet(this, _AddProduct_instances, "m", _AddProduct_prompt).call(this, prefilledProduct, { availableAssets, existingSKUs });
        productsJSON.products = [...productsJSON.products, product];
        try {
            ux.action.start('Saving product');
            await writeFile(this.productsFilePath, JSON.stringify(productsJSON, null, 2), 'utf-8');
            ux.action.stop(`Product "${product.sku}" added successfully!`);
            this.log(`Go to ${chalk.underline('https://developers.reddit.com/docs/payments/payments_add#complete-the-payment-flow')} to integrate the product into your app.`);
        }
        catch (error) {
            this.error(`Failed to write ${PRODUCTS_JSON_FILE}:\n${error}`);
        }
    }
}
_a = AddProduct, _AddProduct_instances = new WeakSet(), _AddProduct_prompt = async function _AddProduct_prompt(prefilledProduct, { existingSKUs, availableAssets }) {
    return await inquirer.prompt([
        {
            message: 'Product SKU (50 characters max, alphanumeric and dashes only):',
            type: 'input',
            name: 'sku',
            validate: (input) => {
                if (existingSKUs.includes(input)) {
                    return `A product with SKU "${input}" already exists. Please provide a unique SKU.`;
                }
                if (input.length === 0) {
                    return 'A SKU is required';
                }
                if (!/^[A-z0-9-_]+$/.test(input)) {
                    return 'SKU must be alphanumeric';
                }
                if (input.length > 50) {
                    return 'SKU must be 50 characters or less';
                }
                return true;
            },
        },
        {
            message: 'Product name (50 characters max):',
            type: 'input',
            name: 'displayName',
            filter: (input) => input.trim(),
            validate: (input) => {
                if (input.length === 0) {
                    return 'Please provide a name.';
                }
                if (input.length > 50) {
                    return 'Name must be 50 characters or less.';
                }
                return true;
            },
        },
        {
            message: 'Long description (250 characters max):',
            type: 'input',
            name: 'description',
            filter: (input) => input.trim(),
            validate: (input) => {
                if (input.length > 250) {
                    return 'Description must be 250 characters or less.';
                }
                return true;
            },
        },
        {
            message: 'Price in Reddit Gold:',
            type: 'list',
            name: 'price',
            choices: ALLOWED_PRICES,
        },
        {
            message: 'Product type:',
            type: 'list',
            name: 'accountingType',
            filter: (input) => LABEL_TO_ACCOUNTING_TYPE[input],
            choices: Object.values(ACCOUNTING_TYPE_TO_LABEL),
        },
        {
            message: 'Product icon:',
            type: 'list',
            name: 'images',
            filter: (input) => (input === 'None' ? undefined : { icon: input }),
            choices: ['None', new inquirer.Separator(), ...availableAssets],
        },
    ], prefilledProduct);
}, _AddProduct_getProductsConfig = async function _AddProduct_getProductsConfig() {
    const productsJSON = {
        $schema: 'https://developers.reddit.com/schema/products.json',
        products: [],
    };
    ux.action.start(`Reading ${PRODUCTS_JSON_FILE}`);
    const products = await readProducts(this.project.root);
    if (products) {
        ux.action.stop(`${PRODUCTS_JSON_FILE} json read successfully. Found ${products.length} products.`);
        productsJSON.products = products;
    }
    else {
        ux.action.stop(`No ${PRODUCTS_JSON_FILE} found. A new one will be created.`);
    }
    return productsJSON;
}, _AddProduct_getAvailableAssets = async function _AddProduct_getAvailableAssets() {
    if (!this.project.mediaDir)
        return [];
    return (await readdir(path.join(this.project.root, this.project.mediaDir), { recursive: true })).filter((file) => file.endsWith('.png'));
};
AddProduct.description = 'Add a new product to your app';
AddProduct.examples = [
    '$ devvit products add',
    '$ devvit products add my-product-sku',
    '$ devvit products add my-product-sku --name="My Product" --description="A product description" --price=100 --type=INSTANT --icon=icon.png',
];
AddProduct.args = {
    sku: Args.string({ description: 'Product SKU' }),
};
AddProduct.flags = {
    name: Flags.string({
        description: 'Product display name',
    }),
    description: Flags.string({
        description: 'Product description',
    }),
    price: Flags.integer({
        options: ALLOWED_PRICES.map((price) => price.toString()),
        description: 'Product price in Reddit Gold',
    }),
    type: Flags.string({
        options: [
            'INSTANT',
            'DURABLE',
            'CONSUMABLE',
            'VALID_FOR_1D',
            'VALID_FOR_7D',
            'VALID_FOR_30D',
            'VALID_FOR_1Y',
        ],
        description: 'Product type',
    }),
    icon: Flags.file({
        description: 'Product icon asset PNG filename.',
        defaultHelp: 'Must be a relative path within the assets directory.',
        dependsOn: ['config'],
        parse: async (input) => {
            if (!input)
                return '';
            if (!input.endsWith('.png')) {
                throw new Error('Icon must be a PNG file');
            }
            // Remove leading slashes and dots
            return input.replace(/^\.?\/?/, '');
        },
    }),
};
export default AddProduct;
