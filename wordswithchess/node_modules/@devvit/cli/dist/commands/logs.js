var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var _Logs_instances, _Logs_appLogSub, _Logs_playtest, _Logs_getTailFilter, _Logs_onExit;
import { InstallationType } from '@devvit/protos/community.js';
import { RemoteLogSubredditAppNameFilter } from '@devvit/protos/types/devvit/remote_logger/remote_logger.js';
import { Args, Flags } from '@oclif/core';
import { sub } from 'date-fns';
import { Subscription } from 'rxjs';
import { PlaytestServer } from '../lib/playtest-server.js';
import { defaultAppLogDateFormat, formatAppLogDivider, parseAppLogDuration, supportedDurationFormats, } from '../util/app-logs/app-log-util.js';
import { makeLogSubscription } from '../util/app-logs/make-log-subscription.js';
import { createInstallationsClient } from '../util/clientGenerators.js';
import { DevvitCommand, toLowerCaseArgParser } from '../util/commands/DevvitCommand.js';
import { getSubredditNameWithoutPrefix } from '../util/common-actions/getSubredditNameWithoutPrefix.js';
const durationFlag = Flags.custom({
    default: async () => new Date(),
    defaultHelp: async () => '0m',
    parse: async (str) => sub(new Date(), parseAppLogDuration(str)),
});
class Logs extends DevvitCommand {
    constructor() {
        super(...arguments);
        _Logs_instances.add(this);
        _Logs_appLogSub.set(this, void 0);
        _Logs_playtest.set(this, void 0);
    }
    async run() {
        // Despite the name, finally() is only invoked on successful termination.
        process.on('SIGINT', () => void __classPrivateFieldGet(this, _Logs_instances, "m", _Logs_onExit).call(this));
        await this.checkIfUserLoggedIn();
        await this.checkDeveloperAccount();
        const { args, flags } = await this.parse(Logs);
        __classPrivateFieldSet(this, _Logs_playtest, new PlaytestServer({
            dateFormat: flags.dateformat,
            runtime: flags['log-runtime'],
            verbose: flags.verbose,
            showTimestamps: flags['show-timestamps'],
        }, this), "f");
        if (flags.connect)
            __classPrivateFieldGet(this, _Logs_playtest, "f").open();
        const appName = args.app || this.project.name;
        const subreddit = getSubredditNameWithoutPrefix(args.subreddit);
        const subredditAppName = await __classPrivateFieldGet(this, _Logs_instances, "m", _Logs_getTailFilter).call(this, subreddit, appName);
        if (!flags.json) {
            this.log(formatAppLogDivider(`streaming logs for ${appName} on r/${subreddit}`));
        }
        __classPrivateFieldSet(this, _Logs_appLogSub, makeLogSubscription(subredditAppName, this, flags), "f");
    }
}
_Logs_appLogSub = new WeakMap(), _Logs_playtest = new WeakMap(), _Logs_instances = new WeakSet(), _Logs_getTailFilter = async function _Logs_getTailFilter(subreddit, appName) {
    // if the dummy-logger is asked for don't worry about doing any lookup, the dummy logger works
    // for every subreddit regardless of user. It's designed to test that logs are flowing through
    // the system. Long term, this will likely be removed as we build confidence in our logger.
    if (appName === 'dummy-logger') {
        return { appName, subreddit };
    }
    // Call DevPortal to ensure the installation is valid and to convert
    // the subreddit name to a t5_ id.
    // TODO: move this conversion/check into Gateway
    const installationClient = createInstallationsClient();
    const result = await installationClient.GetByAppNameAndInstallLocation({
        location: subreddit,
        slug: appName,
        type: InstallationType.SUBREDDIT,
    });
    return { appName, subreddit: result.installation?.location?.id ?? '' };
}, _Logs_onExit = function _Logs_onExit() {
    __classPrivateFieldGet(this, _Logs_appLogSub, "f")?.unsubscribe();
    __classPrivateFieldGet(this, _Logs_playtest, "f")?.close();
    process.exit(0);
};
Logs.description = 'Streams logs for an installation within a specified subreddit';
Logs.examples = [
    '$ devvit logs <subreddit> [app]',
    '$ devvit logs r/myTestSubreddit',
    '$ devvit logs myOtherTestSubreddit my-app',
];
Logs.args = {
    subreddit: Args.string({
        description: 'Provide the subreddit name. The "r/" prefix is optional',
        required: true,
        parse: toLowerCaseArgParser,
    }),
    app: Args.string({
        description: 'Provide the app name (defaults to working directory app)',
        required: false,
        parse: toLowerCaseArgParser,
    }),
};
Logs.flags = {
    connect: Flags.boolean({ default: true, description: 'Connect to local runtime.' }),
    dateformat: Flags.string({
        char: 'd',
        description: 'Format for rendering dates. See https://date-fns.org/v2.29.3/docs/format for format options',
        default: defaultAppLogDateFormat,
    }),
    json: Flags.boolean({
        char: 'j',
        description: 'output JSON for each log line',
        default: false,
    }),
    'log-runtime': Flags.boolean({
        aliases: ['logRuntime'],
        description: 'Include executing runtime in logs. Remote logs originate from apps running on Reddit servers, local logs originate from your browser.',
    }),
    'show-keep-alive': Flags.boolean({
        aliases: ['showKeepAlive'],
        default: false,
        hidden: true,
    }),
    'show-timestamps': Flags.boolean({
        default: false,
        description: 'Show log message timestamps',
        aliases: ['showTimestamps'],
    }),
    since: durationFlag({
        char: 's',
        description: `when to start the logs from. example "15s", "2w1d" "30m"\n${supportedDurationFormats}`,
    }),
    verbose: Flags.boolean({ default: false }),
};
export default Logs;
