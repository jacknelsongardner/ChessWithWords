import { LoggerDefinition, Severity } from '@devvit/protos';
import {} from '@devvit/protos/json/devvit/ui/effects/web_view/v1alpha/context.js';
import { Devvit, SettingScope, } from '@devvit/public-api';
import { getServerPort } from '@devvit/server';
import { Header } from '@devvit/shared-types/Header.js';
import { getDevvitConfig } from '@devvit/shared-types/server/get-devvit-config.js';
import { StringUtil } from '@devvit/shared-types/StringUtil.js';
import { Splash } from '@devvit/splash/splash.js';
import { backgroundUrl } from '@devvit/splash/utils/assets.js';
// Hack: rename config2 to workaround declaration in
//       packages/runtime-lite/src/runtime/SandboxedRuntimeLite.ts.
// __devvit__ is initialized by ESBuildPack and undefined in tests only.
// @ts-expect-error no type.
const config2 = globalThis.__devvit__?.config;
/** @internal [state] Map of devvit.json form keys to Devvit-singleton form keys. */
export const formKeyMap = {};
function configurePermissions(permissions) {
    // to-do: remove. This is a relic of LinkedBundle generation.
    Devvit.configure({
        http: {
            enabled: permissions.http.enable,
            domains: permissions.http.domains,
        },
        media: permissions.media,
        // to-do: payments permissions.
        realtime: permissions.realtime,
        redditAPI: permissions.reddit.enable,
        modLog: permissions.reddit.scope === 'moderator',
        userActions: permissions.reddit.asUser.length > 0 ? { scopes: permissions.reddit.asUser } : false,
        redis: permissions.redis,
    });
}
function configurePost(name, post) {
    const defaultEntrypoint = post.entrypoints.default;
    const renderSplash = (ctx) => {
        const postDataHeader = ctx.metadata[Header.PostData]?.values[0];
        const postData = postDataHeader
            ? JSON.parse(postDataHeader)
            : {};
        const splash = postData.splash;
        const entry = splash?.entry ? post.entrypoints[splash.entry] : undefined;
        return (
        // Align to `submitCustomPost()`.
        Devvit.createElement(Splash, { appDisplayName: splash?.appDisplayName ?? name, appIconUri: splash?.appIconUri, backgroundUri: splash?.backgroundUri ?? backgroundUrl, buttonLabel: splash?.buttonLabel, description: splash?.description, entryUri: entry?.entry ?? defaultEntrypoint.entry, heading: splash?.title, height: entry?.height ?? defaultEntrypoint.height }));
    };
    const renderInline = (_ctx) => {
        return (Devvit.createElement("blocks", { height: defaultEntrypoint.height },
            Devvit.createElement("webview", { url: defaultEntrypoint.entry, width: "100%", height: "100%" })));
    };
    Devvit.addCustomPostType({
        name: '',
        render: (ctx) => {
            return defaultEntrypoint.inline ? renderInline(ctx) : renderSplash(ctx);
        },
        // to-do: vary dynamically on entrypoint.
        height: defaultEntrypoint.height,
    });
}
function configureMenuItems(menuItems) {
    for (const action of menuItems) {
        const menuItem = {
            label: action.label,
            location: action.location,
            onPress: async (ev, ctx) => {
                const responseJson = await callWebbitEndpoint(action.endpoint, ev, ctx.metadata);
                const uiResponse = responseJson;
                validateUiResponse(uiResponse);
                await handleUiResponse(ctx, uiResponse);
            },
        };
        // "user" type is blank in Devvit classic. So if it's present in
        // devvit.json, we add an extra menu item without forUserType set.
        // "moderator" maps across as expected.
        // "loggedOut" type (Devvit classic) we no longer support
        if (action.forUserType === 'moderator')
            menuItem.forUserType = 'moderator';
        if (action.postFilter === 'currentApp')
            menuItem.postFilter = action.postFilter;
        if (action.description)
            menuItem.description = action.description;
        Devvit.addMenuItem(menuItem);
    }
}
function configureForms(forms) {
    for (const [name, endpoint] of Object.entries(forms)) {
        formKeyMap[name] = Devvit.createForm({ fields: [] }, (ev, ctx) => handleFormResponse(endpoint, ev, ctx));
    }
}
function configureTriggers(triggers) {
    for (const [name, endpoint] of Object.entries(triggers)) {
        const ev = name.replace(/^on/, '');
        Devvit.addTrigger({
            event: ev,
            async onEvent(ev, ctx) {
                // Convert the hydrated old Protobuf to JSON. Don't use
                // Protobuf.toJSON() which would omit default values.
                const body = JSON.parse(JSON.stringify(ev));
                // Cast to JsonObject since interfaces are open types.
                await callWebbitEndpoint(endpoint, body, ctx.metadata);
            },
        });
    }
}
async function handleFormResponse(endpoint, event, ctx) {
    const responseJson = await callWebbitEndpoint(endpoint, event.values, ctx.metadata);
    const uiResponse = responseJson;
    validateUiResponse(uiResponse);
    await handleUiResponse(ctx, uiResponse);
}
// TODO: expand this to fully validate the UiResponse format, including Form definitions,
// and convert signature to validateUiResponse(uiResponse: JsonValue): uiResponse is UiResponse
/** @internal */
export function validateUiResponse(uiResponse) {
    // Validations:
    // (1) The only valid fields on uiResponse are showToast, navigateTo, and showForm.
    const validKeys = ['showToast', 'navigateTo', 'showForm'];
    const invalidKeys = Object.keys(uiResponse).filter((key) => !validKeys.includes(key));
    if (invalidKeys.length > 0) {
        throw new Error(`Invalid fields found in UiResponse: "${invalidKeys.join('", "')}". Valid fields are: "${validKeys.join('", "')}"`);
    }
    // (2) showForm must have a name that exists in the formKeyMap.
    if (uiResponse.showForm) {
        if (!uiResponse.showForm.name) {
            throw new Error('showForm must have a name');
        }
        if (!formKeyMap[uiResponse.showForm.name]) {
            throw new Error(`Form with name "${uiResponse.showForm.name}" not found in devvit.json. Consider adding:\n\n    "forms": {"${uiResponse.showForm.name}":"/internal/your/endpoint"}\n\n`);
        }
    }
    // (3) showToast must be a string or an object with only fields [text, appearance]
    //     and text is a mandatory string.
    if (uiResponse.showToast !== undefined) {
        if (typeof uiResponse.showToast === 'string') {
            // Valid case: showToast is a string
        }
        else if (typeof uiResponse.showToast === 'object' && uiResponse.showToast !== null) {
            // Check if it's an object with valid fields
            const toastKeys = Object.keys(uiResponse.showToast);
            const validToastKeys = ['text', 'appearance'];
            const invalidToastKeys = toastKeys.filter((key) => !validToastKeys.includes(key));
            if (invalidToastKeys.length > 0) {
                throw new Error(`Invalid fields found in showToast: "${invalidToastKeys.join('", "')}". Valid fields are: "${validToastKeys.join('", ')}"`);
            }
            if (typeof uiResponse.showToast.text !== 'string') {
                throw new Error('showToast.text is required and must be a string');
            }
        }
        else {
            throw new Error('showToast must be a string or an object with text and optional appearance fields');
        }
    }
    // (4) navigateTo must be a valid URL or a Post object. (this is validated client-side, so
    //     we don't need to validate it here).
    // (5) navigateTo and showForm are mutually exclusive.
    if (uiResponse.navigateTo && uiResponse.showForm) {
        throw new Error('navigateTo and showForm cannot be used together in UiResponse');
    }
}
function validateSettingsValidationResponse(response) {
    if (typeof response !== 'object' || response === null) {
        throw new Error('SettingsValidationResponse must be an object');
    }
    if (!('success' in response) || typeof response.success !== 'boolean') {
        throw new Error('SettingsValidationResponse must have a boolean "success" field');
    }
    if ('error' in response && typeof response.error !== 'string') {
        throw new Error('"error" field in SettingsValidationResponse must be a string');
    }
}
/**
 * Handle a UiResponse from a Webbit handler (menu action or form handler).
 * This is used to create client-side UI effects in Reddit clients as responses
 * to user actions in cases where the Devvit app is not in the direct code path.
 *
 * If multiple effects are present in the UiResponse, they will all be applied.
 */
async function handleUiResponse(ctx, uiResponse) {
    if (uiResponse.showToast) {
        ctx.ui.showToast(uiResponse.showToast);
    }
    if (uiResponse.navigateTo) {
        ctx.ui.navigateTo(uiResponse.navigateTo);
    }
    if (uiResponse.showForm) {
        ctx.ui.showFormInternal(formKeyMap[uiResponse.showForm.name], uiResponse.showForm.data, uiResponse.showForm.form);
    }
}
async function callWebbitEndpoint(endpoint, body, metadata) {
    const url = new URL(endpoint, `http://webbit.local:${getServerPort()}/`);
    const headers = {};
    Object.entries(metadata).forEach(([key, metadata]) => {
        headers[key] = metadata.values[0];
    });
    headers['Content-Type'] = 'application/json';
    headers['Accept'] = 'application/json';
    const response = await fetch(url, {
        method: 'POST',
        body: JSON.stringify(body),
        headers,
    });
    if (!response.ok) {
        const bodyText = await response.text();
        // Try parsing the response as JSON / UiResponse. If valid, return it so callers can handle
        // it like effects. If not, fall down to error case.
        try {
            const jsonResponse = JSON.parse(bodyText);
            validateUiResponse(jsonResponse);
            return jsonResponse;
        }
        catch {
            let errorMessage = `Failed to POST ${endpoint}: ${response.statusText}, `;
            if (response.status === 404) {
                errorMessage += `ensure that you're handling this endpoint in your server code.`;
            }
            else {
                errorMessage += `body: ${bodyText.substring(0, 100)}`;
            }
            throw new Error(errorMessage);
        }
    }
    const contentType = response.headers.get('Content-Type');
    if (!contentType || !contentType.includes('application/json')) {
        throw new Error(`Failed to POST ${endpoint}: expected response type 'application/json', received '${contentType}'`);
    }
    try {
        return await response.json();
    }
    catch (error) {
        throw new Error(`Failed to POST ${endpoint}: ${error}`);
    }
}
function configureScheduler(schedulerConfig) {
    const cronTasks = {};
    for (const [name, task] of Object.entries(schedulerConfig.tasks)) {
        Devvit.addSchedulerJob({
            name: name,
            onRun: async (event, context) => {
                await callWebbitEndpoint(task.endpoint, { name: event.name, data: event.data }, context.metadata);
            },
        });
        // Tasks with cron specified require a bit more work further down
        if (task.cron) {
            cronTasks[name] = task;
        }
    }
    // If provided, schedule any cron tasks the user asked for on install/upgrade, being careful to
    // un-schedule any previously scheduled instances of these tasks
    if (Object.keys(cronTasks).length > 0) {
        Devvit.addTrigger({
            events: ['AppInstall', 'AppUpgrade'],
            onEvent: async (_event, context) => {
                // Get all jobs
                const existingJobs = await context.scheduler.listJobs();
                // Filter down to just cron jobs
                const jobsToCancel = existingJobs.filter((job) => {
                    // Only cancel cron jobs
                    return 'cron' in job;
                });
                // Cancel everything we need to
                await Promise.all(jobsToCancel.map((job) => context.scheduler.cancelJob(job.id)));
                // Schedule all the cron tasks we were given in the config
                await Promise.all(Object.entries(cronTasks).map(async ([name, task]) => {
                    const logger = getDevvitConfig().use(LoggerDefinition);
                    try {
                        await context.scheduler.runJob({
                            name: name,
                            cron: task.cron,
                            ...(task.data ? { data: task.data } : {}),
                        });
                    }
                    catch (error) {
                        await logger.Log({
                            message: `Failed to schedule ${name}: ${StringUtil.caughtToString(error, 'message')}`,
                            severity: Severity.ERROR,
                            tags: [],
                        }, context.metadata);
                        throw error;
                    }
                    await logger.Log({ message: `Cron task '${name}' scheduled.`, severity: Severity.VERBOSE, tags: [] }, context.metadata);
                }));
            },
        });
    }
}
function configureSettings(settings) {
    const classicSettings = [];
    for (const config of Object.values(settings?.global || {})) {
        classicSettings.push(coerceSettingForClassic(config, SettingScope.App));
    }
    for (const config of Object.values(settings?.subreddit || {})) {
        classicSettings.push(coerceSettingForClassic(config, SettingScope.Installation));
    }
    Devvit.addSettings(classicSettings);
}
function coerceSettingForClassic(setting, scope) {
    let classicSetting;
    if (setting.type === 'select') {
        const { defaultValue, ...settingWithoutDefault } = setting;
        classicSetting = {
            ...settingWithoutDefault,
            scope,
        };
        if (defaultValue) {
            classicSetting.defaultValue = [defaultValue];
        }
    }
    else if (setting.type === 'multiSelect') {
        classicSetting = {
            ...setting,
            type: 'select',
            multiSelect: true,
            scope,
        };
    }
    else {
        classicSetting = {
            ...setting,
            scope,
        };
    }
    if (setting.validationEndpoint) {
        classicSetting.onValidate = async function validateSettingsField(event, context) {
            const responseJson = await callWebbitEndpoint(setting.validationEndpoint, { value: event.value, isEditing: event.isEditing }, context.metadata);
            validateSettingsValidationResponse(responseJson);
            if (responseJson.success) {
                return;
            }
            return responseJson.error;
        };
    }
    return classicSetting;
}
if (config2) {
    configurePermissions(config2.permissions);
    if (config2.post)
        configurePost(config2.name, config2.post);
    if (config2.menu?.items) {
        configureMenuItems(config2.menu.items);
    }
    if (config2.scheduler)
        configureScheduler(config2.scheduler);
    if (config2.forms)
        configureForms(config2.forms);
    if (config2.triggers)
        configureTriggers(config2.triggers);
    if (config2.settings)
        configureSettings(config2.settings);
}
export default Devvit;
