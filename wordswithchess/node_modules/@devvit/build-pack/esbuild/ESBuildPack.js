var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _Watcher_instances, _Watcher_disableExternDevvitProtos, _Watcher_config, _Watcher_root, _Watcher_observable, _Watcher_disposedNotifier, _Watcher_disposeWatcher, _Watcher_namespace, _Watcher_buildTargets, _Watcher_ready, _Watcher_init, _Watcher_makeEntry, _Watcher_makeEsbuildContext, _Watcher_onBuildEnd, _ESBuildPack_bundleWatchers, _ESBuildPack_namespace, _ESBuildPack_disableExternDevvitProtos;
import fs, { readFileSync } from 'node:fs';
import path from 'node:path';
import { Bundle } from '@devvit/protos/types/devvit/plugin/buildpack/buildpack_common.js';
import { TargetRuntime, } from '@devvit/protos/types/devvit/runtime/bundle.js';
import { ConfigImpl as Config } from '@devvit/shared-types/ConfigImpl.js';
import { NonNull } from '@devvit/shared-types/NonNull.js';
import { StringUtil } from '@devvit/shared-types/StringUtil.js';
import esbuild, {} from 'esbuild';
import { BehaviorSubject, Observable, Subject } from 'rxjs';
import { of } from 'rxjs';
import { takeUntil } from 'rxjs/operators';
import { getClassicModuleEntrypoint, getModuleEntrypoint } from '../lib/BuildPack.js';
import { newBuildInfoDependencies } from './BuildInfoUtil.js';
import { dangerouslyGetBundleActor } from './BundleModule.js';
import { createDependencySpec } from './dependency-spec-util.js';
import { externalizeDevvitProtos } from './plugins/externalizeDevvitProtos.js';
import { postProcessServerStubCode, serverClientCodeSplit, } from './plugins/serverClientCodeSplit.js';
import { templatize } from './templatizer/templatizer.js';
import { prefixBuildResultLogs } from './utils.js';
const FAKE_FACTORY = {
    // TODO: remove use of any below
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    Build() { },
};
const BUILD_TARGETS = [TargetRuntime.UNIVERSAL, TargetRuntime.CLIENT];
export class Watcher {
    /**
     * The default behavior is to externalize @devvit/protos. Set
     * disableExternDevvitProtos to bundle this large dependency.
     */
    constructor(config, namespace, root, actorSpec, options) {
        _Watcher_instances.add(this);
        _Watcher_disableExternDevvitProtos.set(this, void 0);
        _Watcher_config.set(this, void 0);
        _Watcher_root.set(this, void 0);
        /**
         * the actual emitter of updates
         */
        _Watcher_observable.set(this, void 0);
        /**
         * subscribers to this.observable will continue subscribing until this notifier emits a values
         */
        _Watcher_disposedNotifier.set(this, new Subject());
        /**
         * will be asynchronously set as buildResult.stop after calling esbuild.build
         */
        _Watcher_disposeWatcher.set(this, void 0);
        _Watcher_namespace.set(this, void 0);
        _Watcher_buildTargets.set(this, new Map());
        _Watcher_ready.set(this, void 0);
        __classPrivateFieldSet(this, _Watcher_config, config, "f");
        __classPrivateFieldSet(this, _Watcher_namespace, namespace, "f");
        __classPrivateFieldSet(this, _Watcher_root, root, "f");
        __classPrivateFieldSet(this, _Watcher_disableExternDevvitProtos, options?.disableExternDevvitProtos ?? false, "f");
        //  observers of this will be subscribed until this.disposedNotifier emits a value
        const sourceObservable = new Observable().pipe(takeUntil(__classPrivateFieldGet(this, _Watcher_disposedNotifier, "f")));
        // our observable is a BehaviorSubject used to multicast the source observer
        __classPrivateFieldSet(this, _Watcher_observable, new BehaviorSubject({
            bundles: [],
            errors: [],
            warnings: [],
        }), "f");
        // multi-casts (shares) here
        sourceObservable.subscribe(__classPrivateFieldGet(this, _Watcher_observable, "f"));
        // #init handles errors.
        __classPrivateFieldSet(this, _Watcher_ready, __classPrivateFieldGet(this, _Watcher_instances, "m", _Watcher_init).call(this, actorSpec), "f");
    }
    getObservable() {
        return __classPrivateFieldGet(this, _Watcher_observable, "f");
    }
    async dispose() {
        await __classPrivateFieldGet(this, _Watcher_disposeWatcher, "f")?.call(this);
        // cancels all subscriptions after emitting value due to "takeUntil"
        __classPrivateFieldGet(this, _Watcher_disposedNotifier, "f").next();
        // clean up self
        __classPrivateFieldGet(this, _Watcher_disposedNotifier, "f").complete();
    }
}
_Watcher_disableExternDevvitProtos = new WeakMap(), _Watcher_config = new WeakMap(), _Watcher_root = new WeakMap(), _Watcher_observable = new WeakMap(), _Watcher_disposedNotifier = new WeakMap(), _Watcher_disposeWatcher = new WeakMap(), _Watcher_namespace = new WeakMap(), _Watcher_buildTargets = new WeakMap(), _Watcher_ready = new WeakMap(), _Watcher_instances = new WeakSet(), _Watcher_init = async function _Watcher_init(actorSpec) {
    const entry = __classPrivateFieldGet(this, _Watcher_instances, "m", _Watcher_makeEntry).call(this);
    // Building for Universal and Client targets. May include Server in the future.
    for (const target of BUILD_TARGETS) {
        __classPrivateFieldGet(this, _Watcher_buildTargets, "f").set(target, {
            ctx: await __classPrivateFieldGet(this, _Watcher_instances, "m", _Watcher_makeEsbuildContext).call(this, actorSpec, target, entry),
        });
    }
    __classPrivateFieldSet(this, _Watcher_disposeWatcher, async () => {
        for (const [_, target] of __classPrivateFieldGet(this, _Watcher_buildTargets, "f")) {
            await target.ctx.dispose();
        }
    }, "f");
    if (__classPrivateFieldGet(this, _Watcher_observable, "f").isStopped) {
        // Disposed while await-ing and prior to setting disposeWatcher.
        await __classPrivateFieldGet(this, _Watcher_disposeWatcher, "f").call(this);
        return;
    }
    const watchers = [];
    for (const [_, target] of __classPrivateFieldGet(this, _Watcher_buildTargets, "f")) {
        watchers.push(target.ctx.watch());
    }
    await Promise.all(watchers);
}, _Watcher_makeEntry = function _Watcher_makeEntry() {
    // The watched file doesn't change but its dependencies do.
    const entry = getModuleEntrypoint(__classPrivateFieldGet(this, _Watcher_config, "f"), __classPrivateFieldGet(this, _Watcher_root, "f"));
    if (__classPrivateFieldGet(this, _Watcher_config, "f")) {
        const template = templatize(__classPrivateFieldGet(this, _Watcher_root, "f"), __classPrivateFieldGet(this, _Watcher_config, "f").blocks?.entry);
        fs.writeFileSync(entry, template);
    }
    return entry;
}, _Watcher_makeEsbuildContext = async function _Watcher_makeEsbuildContext(actorSpec, targetRuntime, entry) {
    const cfg = esbuildConfig(__classPrivateFieldGet(this, _Watcher_config, "f"), __classPrivateFieldGet(this, _Watcher_disableExternDevvitProtos, "f"), targetRuntime, true);
    return await esbuild.context({
        ...cfg,
        entryPoints: [entry],
        minify: false,
        sourcemap: 'external',
        outfile: 'main.js',
        // esbuild now supports hooks through the onEnd callback in the build API.
        plugins: [
            {
                name: 'optionally-type-check-and-publish-compile-result-on-build-end',
                setup: (build) => {
                    build.onEnd(async (result) => {
                        await __classPrivateFieldGet(this, _Watcher_instances, "m", _Watcher_onBuildEnd).call(this, actorSpec, result, targetRuntime);
                    });
                },
            },
            excludeNodeModulesFromSourceMapsPlugin(),
            ...(cfg.plugins || []),
        ],
    });
}, _Watcher_onBuildEnd = 
/**
 * @description The callback function for esbuild's onEnd hook. This is called after esbuild has finished building.
 */
async function _Watcher_onBuildEnd(actorSpec, esbuildResult, targetRuntime) {
    await __classPrivateFieldGet(this, _Watcher_ready, "f");
    __classPrivateFieldGet(this, _Watcher_buildTargets, "f").get(targetRuntime).result = esbuildResult;
    const results = new Map();
    // bail early if any builds are incomplete
    for (const [targetRuntime, target] of __classPrivateFieldGet(this, _Watcher_buildTargets, "f")) {
        if (!target.result)
            return;
        results.set(targetRuntime, target.result);
    }
    const esbuildCompileRes = await newCompileResponse(__classPrivateFieldGet(this, _Watcher_config, "f"), __classPrivateFieldGet(this, _Watcher_namespace, "f"), actorSpec, results, __classPrivateFieldGet(this, _Watcher_root, "f"));
    // clear saved values so we don't double-fire the next time we get results
    for (const [_, target] of __classPrivateFieldGet(this, _Watcher_buildTargets, "f")) {
        target.result = undefined;
    }
    __classPrivateFieldGet(this, _Watcher_observable, "f").next(esbuildCompileRes);
};
export class ESBuildPack {
    /**
     * The default behavior is to externalize @devvit/protos. Set
     * disableExternDevvitProtos to bundle this large dependency.
     */
    constructor(namespace, options) {
        /**
         * @property {Map} bundleUpdateEmitters [note] A BehaviorSubject implements the Observable interface. Any observer who subscribes to a behavior subject will receive the last emitted value
         * @see https://rxjs.dev/guide/subject
         */
        _ESBuildPack_bundleWatchers.set(this, new Map());
        _ESBuildPack_namespace.set(this, void 0);
        // EsbuildPack options
        _ESBuildPack_disableExternDevvitProtos.set(this, void 0);
        __classPrivateFieldSet(this, _ESBuildPack_namespace, namespace, "f");
        __classPrivateFieldSet(this, _ESBuildPack_disableExternDevvitProtos, options?.disableExternDevvitProtos ?? false, "f");
    }
    async compile({ config, minify, info, includeMetafile, root, }) {
        const entry = getModuleEntrypoint(config, root);
        if (config) {
            const template = templatize(root, config.blocks?.entry);
            try {
                fs.writeFileSync(entry, template);
            }
            catch (err) {
                return unknownToErrorCompileResponse('Compilation', err);
            }
        }
        const buildResults = new Map();
        for (const targetRuntime of BUILD_TARGETS) {
            const cfg = esbuildConfig(config, __classPrivateFieldGet(this, _ESBuildPack_disableExternDevvitProtos, "f"), targetRuntime);
            try {
                const buildResult = await esbuild.build({
                    ...cfg,
                    entryPoints: [entry],
                    metafile: true,
                    sourcemap: 'external',
                    plugins: [excludeNodeModulesFromSourceMapsPlugin(), ...(cfg.plugins || [])],
                    sourcesContent: false,
                    minify: minify === 'All',
                    outfile: 'main.js',
                    treeShaking: true,
                });
                buildResults.set(targetRuntime, buildResult);
            }
            catch (err) {
                return isEsbuildResult(err)
                    ? await newCompileResponse(config, __classPrivateFieldGet(this, _ESBuildPack_namespace, "f"), info, new Map([[targetRuntime, err]]), root, includeMetafile)
                    : unknownToErrorCompileResponse('Compilation', err);
            }
        }
        const esbuildCompileResult = await newCompileResponse(config, __classPrivateFieldGet(this, _ESBuildPack_namespace, "f"), info, buildResults, root, includeMetafile);
        if (esbuildCompileResult.bundles.length === 0) {
            throw new Error(esbuildCompileResult.errors?.[0]?.text ?? 'Missing bundle');
        }
        return esbuildCompileResult;
    }
    async dispose() {
        await Promise.all(Array.from(__classPrivateFieldGet(this, _ESBuildPack_bundleWatchers, "f").values()).map((watcher) => watcher.dispose()));
    }
    watch({ config, root, info }) {
        // Use a stable entrypoint, not a template.
        const blocksEntry = config?.blocks?.entry ?? getClassicModuleEntrypoint(root);
        if (!__classPrivateFieldGet(this, _ESBuildPack_bundleWatchers, "f").has(blocksEntry)) {
            let watcher;
            try {
                watcher = new Watcher(config, __classPrivateFieldGet(this, _ESBuildPack_namespace, "f"), root, info, {
                    disableExternDevvitProtos: __classPrivateFieldGet(this, _ESBuildPack_disableExternDevvitProtos, "f"),
                });
            }
            catch (err) {
                return of(unknownToErrorCompileResponse('Compilation', err));
            }
            __classPrivateFieldGet(this, _ESBuildPack_bundleWatchers, "f").set(root, watcher);
            return watcher.getObservable();
        }
        return NonNull(__classPrivateFieldGet(this, _ESBuildPack_bundleWatchers, "f").get(blocksEntry)).getObservable();
    }
}
_ESBuildPack_bundleWatchers = new WeakMap(), _ESBuildPack_namespace = new WeakMap(), _ESBuildPack_disableExternDevvitProtos = new WeakMap();
async function newCompileResponse(config, namespace, actorSpec, buildResults, root, includeMetafile = false) {
    const errors = [];
    const warnings = [];
    const bundles = [];
    for (const [targetRuntime, buildResult] of buildResults) {
        if (!buildResult)
            continue;
        prefixBuildResultLogs(buildResult, 'esbuild');
        errors.push(...buildResult.errors.map(esbuildMessageToBuildLog));
        warnings.push(...buildResult.warnings.map(esbuildMessageToBuildLog));
        let code = '';
        let sourceMap = '';
        for (const outputFile of buildResult.outputFiles || []) {
            if (outputFile.path?.endsWith('.js')) {
                if (code) {
                    throw new Error('There should only be one bundle after build');
                }
                // ESBuild is wrapping our Proxy stub in this which binds the proxy to the `default` export of the module.
                // We want our proxy to be the mapper when importing from the stubbed file so we need to unwrap this so
                // the import statement doesn't become the object: { default: <proxy> } but just <proxy>.
                code = postProcessServerStubCode(outputFile.text);
            }
            else if (outputFile.path?.endsWith('.js.map')) {
                sourceMap = outputFile.text;
            }
            else {
                throw new Error('Unexpected output file: ' + outputFile.path);
            }
        }
        if (!code) {
            const errors = buildResult.errors.map(esbuildMessageToBuildLog);
            const warnings = buildResult.warnings.map(esbuildMessageToBuildLog);
            return { bundles: [], errors, warnings };
        }
        let dependencies;
        try {
            dependencies = await getDependencySpec(actorSpec, code, config, namespace);
        }
        catch (err) {
            return unknownToErrorCompileResponse('Evaluation', err);
        }
        let metafile;
        if (includeMetafile && buildResult.metafile) {
            metafile = JSON.stringify(buildResult.metafile);
        }
        bundles.push({
            assetIds: {},
            code,
            sourceMap,
            dependencies,
            buildInfo: {
                created: new Date(),
                dependencies: newBuildInfoDependencies(root),
                targetRuntime,
            },
            webviewAssetIds: {},
            metafile,
        });
    }
    try {
        updateBundleServer(bundles, root, config?.server);
    }
    catch {
        const serverEntry = config?.server
            ? path.join(config.server.dir, config.server.entry)
            : undefined;
        return unknownToErrorCompileResponse('Evaluation', `Cannot read \`config.server.entry\` file (${serverEntry}).`);
    }
    return { bundles, errors, warnings };
}
async function dangerouslyMakeDependencySpec(namespace, actorSpec, ActorClass) {
    const config = new Config(FAKE_FACTORY, actorSpec, {}, {});
    new ActorClass(config);
    const spec = config.export(namespace);
    for (const provide of spec.provides) {
        for (const method of provide.definition?.methods ?? []) {
            if (!(method.name in ActorClass.prototype)) {
                throw new Error(`App class ${ActorClass.name} does not implement ${method.fullName}`);
            }
        }
    }
    return spec;
}
/** Stringifies val as a BuildLog error in a CompileResponse. */
function unknownToErrorCompileResponse(phase, val) {
    return {
        bundles: [],
        errors: [{ text: `${phase} failure: ${StringUtil.caughtToString(val)}` }],
        warnings: [],
    };
}
function esbuildMessageToBuildLog(msg) {
    return {
        text: msg.text,
        ...(msg.location != null && {
            detail: {
                column: msg.location.column,
                filename: msg.location.file,
                line: msg.location.line,
                suggestion: msg.location.suggestion,
                text: msg.location.lineText,
            },
        }),
    };
}
function isEsbuildResult(err) {
    return err instanceof Object && 'errors' in err && 'warnings' in err;
}
/** Call with defined config for v1 behavior. */
function esbuildConfig(config, disableExternDevvitProtos, targetRuntime, watchMode = false) {
    return {
        // When Blocks migration is used, the Devvit singleton used in the template
        // must be the same instance as that used elsewhere. Aliases are resolved
        // from the current working directory, not the compiled file's directory, so
        // this effectively maps the template's @devvit/public-api to the app's
        // version. The same could be done for @devvit/server but apps don't
        // necessarily have a copy.
        alias: config?.blocks ? { '@devvit/public-api': '@devvit/public-api' } : {},
        // Recursively inline any imported dependencies.
        bundle: true,
        // Tightly coupled to blocks.template.tsx.
        define: {
            'globalThis.__devvit__': config ? JSON.stringify({ config }, undefined, 2) : 'undefined',
        },
        external: [
            'node:*',
            // All .js files from https://github.com/nodejs/node/tree/b2405e9/lib that
            // don't start with _. Another option is to mark everything external for
            // server builds but then the user can't bundle _anything_.
            'assert',
            'async_hooks',
            'buffer',
            'child_process',
            'cluster',
            'console',
            'constants',
            'crypto',
            'dgram',
            'diagnostics_channel',
            'dns',
            'domain',
            'events',
            'fs',
            'http',
            'http2',
            'https',
            'inspector',
            'module',
            'net',
            'os',
            'path',
            'perf_hooks',
            'process',
            'punycode',
            'querystring',
            'quic',
            'readline',
            'repl',
            'sea',
            'sqlite',
            'stream',
            'string_decoder',
            'sys',
            'test',
            'timers',
            'tls',
            'trace_events',
            'tty',
            'url',
            'util',
            'v8',
            'vm',
            'wasi',
            'worker_threads',
            'zlib',
        ],
        // Split the @devvit/protos from the LinkedBundle. This means apps assume
        // @devvit/protos is available for import at execution time.
        plugins: [
            externalizeDevvitProtos(disableExternDevvitProtos),
            ...(targetRuntime === TargetRuntime.CLIENT ? [serverClientCodeSplit(watchMode)] : []),
        ],
        // to-do: uncomment once runtime is split aware and deployed everywhere.
        // external: ['@devvit/protos'],
        // Both format and target are intended to align to
        // @devvit/runtimes/package.json's build scripts for bootstrap compatibility.
        format: 'cjs',
        // Use our own built-in `Blocks.createElement` for JSX calls instead
        // of defaulting to `React.createElement`.
        // This should be automatic since its configured in TSConfig, so this
        // is to keep things explicit.
        // See https://esbuild.github.io/api/#jsx-fragment
        jsxFactory: 'Devvit.createElement',
        jsxFragment: 'Devvit.Fragment',
        // Do not show any console output. Warnings and errors are reported in the
        // response.
        logLevel: 'silent',
        platform: targetRuntime === TargetRuntime.UNIVERSAL ? 'node' : 'browser',
        target: 'es2020',
        // Write to in-memory buffers.
        write: false,
    };
}
/**
 * Plugin for excluding code from inclusion in the source map by filename. This helps keep bundle size manageable.
 * @arg {RegExp} config.filter - A filter for what paths to exclude, if they match.
 */
function excludeNodeModulesFromSourceMapsPlugin() {
    return {
        name: 'excludeNodeModulesFromSourceMaps',
        setup(build) {
            build.onLoad({ filter: /@devvit\/protos/ }, (args) => {
                if (args.path.endsWith('.js')) {
                    return {
                        contents: fs.readFileSync(args.path, 'utf8') +
                            // Replaces the file as it's read in by esbuild with a stubbed-out, inline sourcemap
                            // {"version":3,"sources":[""],"mappings":"A"}
                            // See: https://github.com/evanw/esbuild/issues/1685
                            '\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIiJdLCJtYXBwaW5ncyI6IkEifQ==',
                        loader: 'default',
                    };
                }
            });
        },
    };
}
async function getDependencySpec(actorSpec, code, config, namespace) {
    if (config)
        return createDependencySpec(actorSpec, config, namespace);
    const ActorClass = await dangerouslyGetBundleActor(code);
    return await dangerouslyMakeDependencySpec(namespace, actorSpec, ActorClass);
}
/** Throws when unable to read config.server.entry. */
function newServerBundle(root, server) {
    const serverEntry = path.join(server.dir, server.entry);
    let code;
    try {
        code = readFileSync(path.resolve(root, serverEntry), 'utf8');
    }
    catch (err) {
        throw Error(`Cannot read \`config.server.entry\` file (${serverEntry}).`, {
            cause: err,
        });
    }
    const sourceMapFilename = findSourceMapURL(code) ?? `${serverEntry}.map`;
    let sourceMap = '';
    try {
        sourceMap = readFileSync(path.resolve(root, sourceMapFilename), 'utf8');
    }
    catch {
        // source map files aren't required, safe to swallow this error
    }
    return { code, sourceMap };
}
/** @internal */
export function findSourceMapURL(src) {
    return /[@#]\s*sourceMappingURL=([^\s*]+)(?![\s\S]*sourceMappingURL)/.exec(src)?.[1];
}
/** Throws when unable to read config.server.entry. */
export function updateBundleServer(bundles, root, server) {
    if (!server)
        return;
    for (const bundle of bundles)
        if (bundle.buildInfo?.targetRuntime === TargetRuntime.UNIVERSAL)
            bundle.server = newServerBundle(root, server);
}
export function updateBundleVersion(bundles, version) {
    for (const bundle of bundles) {
        bundle.dependencies ??= { hostname: '', provides: [], uses: [], permissions: [] };
        bundle.dependencies.actor ??= { name: '', owner: '', version: '' };
        bundle.dependencies.actor.version = version.toString();
    }
}
