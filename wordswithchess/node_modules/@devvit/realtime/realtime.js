var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _Connection_opts;
import { emitEffect } from '@devvit/shared-types/client/emit-effect.js';
const connectionsByChannel = new Map();
/* TODO: Clean up this API. Now that realtime has been removed from the
 * EFFECTS_WITH_RESPONSE list, we probably don't need to await emitEffect.
 */
/**
 * Connects to a realtime channel for receiving messages.
 *
 * @param opts - Connection options including channel name and callbacks
 * @returns A Connection object with a disconnect method
 */
export const connectRealtime = async (opts) => {
    if (connectionsByChannel.has(opts.channel)) {
        return connectionsByChannel.get(opts.channel);
    }
    const connection = new Connection(opts);
    connectionsByChannel.set(opts.channel, connection);
    addEventListener('message', connection.onMessage);
    await emitEffect({
        realtimeSubscriptions: { subscriptionIds: [...connectionsByChannel.keys()] },
        type: 0,
    });
    return connection;
};
/**
 * Clears all connections. Used for testing purposes.
 * @internal
 */
export const __clearConnections = () => {
    connectionsByChannel.clear();
};
class Connection {
    constructor(opts) {
        _Connection_opts.set(this, void 0);
        this.onMessage = (ev) => {
            const { type, data } = ev.data;
            if (type !== 'devvit-message') {
                return;
            }
            if (!data.realtimeEvent) {
                return;
            }
            const { status, event } = data.realtimeEvent;
            if (!event?.channel.endsWith(__classPrivateFieldGet(this, _Connection_opts, "f").channel)) {
                return;
            }
            // Normalize the channel name (remove namespacing)
            event.channel = __classPrivateFieldGet(this, _Connection_opts, "f").channel;
            if (status === 0) {
                __classPrivateFieldGet(this, _Connection_opts, "f").onConnect?.(__classPrivateFieldGet(this, _Connection_opts, "f").channel);
            }
            else if (status === 1) {
                __classPrivateFieldGet(this, _Connection_opts, "f").onDisconnect?.(__classPrivateFieldGet(this, _Connection_opts, "f").channel);
            }
            else if (event.data) {
                __classPrivateFieldGet(this, _Connection_opts, "f").onMessage(event.data.msg);
            }
            else {
                console.error('[realtime] Received event without data:', {
                    channel: __classPrivateFieldGet(this, _Connection_opts, "f").channel,
                    event,
                });
            }
        };
        __classPrivateFieldSet(this, _Connection_opts, opts, "f");
    }
    /**
     * Disconnects from the realtime channel.
     *
     * This works by sending a list of all channels we want to remain subscribed to,
     * excluding the channel we want to disconnect from. The effect handler compares this
     * new list with existing subscriptions and triggers disconnect for any channel
     * that's no longer in the list.
     */
    async disconnect() {
        const connection = connectionsByChannel.get(__classPrivateFieldGet(this, _Connection_opts, "f").channel);
        if (!connection) {
            return;
        }
        // Get all current subscriptions except the one we're disconnecting
        const remainingChannels = [...connectionsByChannel.keys()].filter((ch) => ch !== __classPrivateFieldGet(this, _Connection_opts, "f").channel);
        await emitEffect({
            realtimeSubscriptions: { subscriptionIds: remainingChannels },
            type: 0,
        });
        connectionsByChannel.delete(__classPrivateFieldGet(this, _Connection_opts, "f").channel);
    }
}
_Connection_opts = new WeakMap();
