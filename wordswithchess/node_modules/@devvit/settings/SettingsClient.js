var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var _SettingsClient_instances, _SettingsClient_pluginCache, _SettingsClient_metadata_get, _SettingsClient_plugin_get;
import { FormFieldType, SettingsDefinition, } from '@devvit/protos';
import { context } from '@devvit/server';
import { getDevvitConfig } from '@devvit/shared-types/server/get-devvit-config.js';
export class SettingsClient {
    constructor() {
        _SettingsClient_instances.add(this);
        _SettingsClient_pluginCache.set(this, void 0);
    }
    async get(name) {
        const settings = await this.getAll();
        return settings[name];
    }
    async getAll() {
        const response = await __classPrivateFieldGet(this, _SettingsClient_instances, "a", _SettingsClient_plugin_get).GetSettings({}, __classPrivateFieldGet(this, _SettingsClient_instances, "a", _SettingsClient_metadata_get));
        if (!response.installationSettings) {
            throw new Error('Could not get installation settings');
        }
        if (!response.appSettings) {
            throw new Error('Could not get app settings');
        }
        cleanAppSettings(response);
        return {
            ...getSettingsValues(response.installationSettings.settings, devvit?.settings?.installation),
            ...getSettingsValues(response.appSettings.settings, devvit?.settings?.app),
        };
    }
}
_SettingsClient_pluginCache = new WeakMap(), _SettingsClient_instances = new WeakSet(), _SettingsClient_metadata_get = function _SettingsClient_metadata_get() {
    return context.metadata;
}, _SettingsClient_plugin_get = function _SettingsClient_plugin_get() {
    return (__classPrivateFieldSet(this, _SettingsClient_pluginCache, __classPrivateFieldGet(this, _SettingsClient_pluginCache, "f") ?? getDevvitConfig().use(SettingsDefinition), "f"));
};
export const settings = new SettingsClient();
export function cleanAppSettings(response) {
    if (!response.appSettings) {
        throw new Error('Could not get app settings');
    }
    // FIX: appSettings don't come back typed correctly for bools or numbers.
    // Fix that. This is a workaround. We intend to make appSettings set this
    // way entirely obsolete in the future; this is just a stopgap.
    for (const [key, value] of Object.entries(response.appSettings.settings)) {
        // Find the matching setting definition, because we can't trust the types in the response.
        const settingDefinition = devvit?.settings?.app?.find((s) => s.type !== 'group' && s.name === key);
        if (!settingDefinition) {
            continue;
        }
        // If the setting is a boolean or number, we need to convert it from string to the correct type.
        if (settingDefinition.type === 'boolean' &&
            value.fieldType === FormFieldType.STRING &&
            value.boolValue == null &&
            value.stringValue != null) {
            value.fieldType = FormFieldType.BOOLEAN;
            value.boolValue = Boolean(value.stringValue);
            delete value.stringValue;
        }
        else if (settingDefinition.type === 'number' &&
            value.fieldType === FormFieldType.STRING &&
            value.numberValue == null &&
            value.stringValue != null) {
            value.fieldType = FormFieldType.NUMBER;
            value.numberValue = Number(value.stringValue);
            delete value.stringValue;
        }
    }
}
export function getSettingsValues(results, settingsDefinitions) {
    const settingsValues = Object.keys(results).reduce((acc, key) => {
        acc[key] = flattenFormFieldValue(results[key]);
        return acc;
    }, {});
    if (settingsDefinitions) {
        setDefaultsIfNecessary(settingsValues, settingsDefinitions);
    }
    return settingsValues;
}
export function setDefaultsIfNecessary(settingsValues, settingsDefinitions) {
    for (const definition of settingsDefinitions) {
        if (definition.type === 'group') {
            // Groups get their defaults set recursively
            setDefaultsIfNecessary(settingsValues, definition.fields);
        }
        else {
            // Only set the default if the value is not already set - note that this checks if the key is
            // missing from the object, not if the value is falsy. So if the user somehow manually sets a
            // setting to `undefined`, we won't use the default value here. Same goes for 'defaultValue' -
            // if the user didn't set a default value, we won't set it to anything.
            if (!(definition.name in settingsValues) && 'defaultValue' in definition) {
                settingsValues[definition.name] = definition.defaultValue;
            }
        }
    }
}
function flattenFormFieldValue(value) {
    switch (value.fieldType) {
        case FormFieldType.STRING:
            return value.stringValue;
        case FormFieldType.IMAGE:
            // the string value is the URL
            return value.stringValue;
        case FormFieldType.PARAGRAPH:
            return value.stringValue;
        case FormFieldType.NUMBER:
            return value.numberValue;
        case FormFieldType.BOOLEAN:
            return value.boolValue;
        case FormFieldType.SELECTION:
            return value.selectionValue?.values ?? [];
        default:
            return undefined;
    }
}
