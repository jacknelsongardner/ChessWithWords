// Code generated by protoc-gen-go-redditapi. DO NOT EDIT.

package reddithttpplugin

import (
	context "context"
	fmt "fmt"
	dlog "github.snooguts.net/reddit/reddit-devplatform-monorepo/go-common/dlog"
	redditapi "github.snooguts.net/reddit/reddit-devplatform-monorepo/go-common/generated/protos/types/devvit/plugin/redditapi"
)

func (s *RedditHttpPlugin) Best(ctx context.Context, req *redditapi.GetBestRequest) (*redditapi.Listing, error) {
	resp := redditapi.Listing{}
	tmpAfterValue := ""
	if req.After != nil {
		tmpAfterValue = fmt.Sprintf("%v", req.After.Value)
	}
	tmpBeforeValue := ""
	if req.Before != nil {
		tmpBeforeValue = fmt.Sprintf("%v", req.Before.Value)
	}
	tmpCountValue := ""
	if req.Count != nil {
		tmpCountValue = fmt.Sprintf("%v", req.Count.Value)
	}
	tmpLimitValue := ""
	if req.Limit != nil {
		tmpLimitValue = fmt.Sprintf("%v", req.Limit.Value)
	}
	tmpShowValue := ""
	if req.Show != nil {
		tmpShowValue = fmt.Sprintf("%v", req.Show.Value)
	}
	hydratedPath := fmt.Sprintf(
		"/best.json?after=%v&before=%v&count=%v&limit=%v&show=%v&raw_json=1",
		tmpAfterValue,
		tmpBeforeValue,
		tmpCountValue,
		tmpLimitValue,
		tmpShowValue)
	err := s.doRequest(ctx, requestConfig{Method: "GET", ProtoMethod: "Best", Path: hydratedPath}, &resp)
	if err != nil {
		return nil, err
	}
	return &resp, nil
}

func (s *RedditHttpPlugin) ById(ctx context.Context, req *redditapi.GetByIdRequest) (*redditapi.Listing, error) {
	resp := redditapi.Listing{}
	hydratedPath := fmt.Sprintf(
		"/by_id/%v.json?raw_json=1",
		req.PostIds)
	err := s.doRequest(ctx, requestConfig{Method: "GET", ProtoMethod: "ById", Path: hydratedPath}, &resp)
	if err != nil {
		return nil, err
	}
	return &resp, nil
}

func (s *RedditHttpPlugin) Comments(ctx context.Context, req *redditapi.GetCommentsRequest) (*redditapi.ListingResponse, error) {
	tmpCommentValue := ""
	if req.Comment != nil {
		tmpCommentValue = fmt.Sprintf("%v", req.Comment.Value)
	}
	tmpContextValue := ""
	if req.Context != nil {
		tmpContextValue = fmt.Sprintf("%v", req.Context.Value)
	}
	tmpDepthValue := ""
	if req.Depth != nil {
		tmpDepthValue = fmt.Sprintf("%v", req.Depth.Value)
	}
	tmpLimitValue := ""
	if req.Limit != nil {
		tmpLimitValue = fmt.Sprintf("%v", req.Limit.Value)
	}
	tmpSortValue := ""
	if req.Sort != nil {
		tmpSortValue = fmt.Sprintf("%v", req.Sort.Value)
	}
	tmpThreadedValue := ""
	if req.Threaded != nil {
		tmpThreadedValue = fmt.Sprintf("%v", req.Threaded.Value)
	}
	tmpTruncateValue := ""
	if req.Truncate != nil {
		tmpTruncateValue = fmt.Sprintf("%v", req.Truncate.Value)
	}
	hydratedPath := fmt.Sprintf(
		"/comments/%v.json?comment=%v&context=%v&depth=%v&limit=%v&sort=%v&threaded=%v&truncate=%v&raw_json=1",
		req.Article,
		tmpCommentValue,
		tmpContextValue,
		tmpDepthValue,
		tmpLimitValue,
		tmpSortValue,
		tmpThreadedValue,
		tmpTruncateValue)
	respBody, err := s.doRequestRaw(ctx, requestConfig{Method: "GET", ProtoMethod: "Comments", Path: hydratedPath})
	if err != nil {
		return nil, err
	}
	resp, err := fixCommentsResponse(respBody)
	if err != nil {
		l := dlog.WithIncomingContext(ctx)
		l.Errorf("Could not unmarshal JSON for path %s: %v", hydratedPath, err)
		l.Errorf("Body failure: %v", string(respBody))
		return nil, err
	}
	return resp, nil
}

func (s *RedditHttpPlugin) Duplicates(ctx context.Context, req *redditapi.GetDuplicatesRequest) (*redditapi.ListingResponse, error) {
	tmpBeforeValue := ""
	if req.Before != nil {
		tmpBeforeValue = fmt.Sprintf("%v", req.Before.Value)
	}
	tmpAfterValue := ""
	if req.After != nil {
		tmpAfterValue = fmt.Sprintf("%v", req.After.Value)
	}
	tmpLimitValue := ""
	if req.Limit != nil {
		tmpLimitValue = fmt.Sprintf("%v", req.Limit.Value)
	}
	tmpSortValue := ""
	if req.Sort != nil {
		tmpSortValue = fmt.Sprintf("%v", req.Sort.Value)
	}
	tmpSrValue := ""
	if req.Sr != nil {
		tmpSrValue = fmt.Sprintf("%v", req.Sr.Value)
	}
	tmpCountValue := ""
	if req.Count != nil {
		tmpCountValue = fmt.Sprintf("%v", req.Count.Value)
	}
	tmpCrosspostsOnlyValue := ""
	if req.CrosspostsOnly != nil {
		tmpCrosspostsOnlyValue = fmt.Sprintf("%v", req.CrosspostsOnly.Value)
	}
	tmpShowValue := ""
	if req.Show != nil {
		tmpShowValue = fmt.Sprintf("%v", req.Show.Value)
	}
	hydratedPath := fmt.Sprintf(
		"/duplicates/%v.json?before=%v&after=%v&limit=%v&sort=%v&sr=%v&count=%v&crossposts_only=%v&show=%v&raw_json=1",
		req.Article,
		tmpBeforeValue,
		tmpAfterValue,
		tmpLimitValue,
		tmpSortValue,
		tmpSrValue,
		tmpCountValue,
		tmpCrosspostsOnlyValue,
		tmpShowValue)
	respBody, err := s.doRequestRaw(ctx, requestConfig{Method: "GET", ProtoMethod: "Duplicates", Path: hydratedPath})
	if err != nil {
		return nil, err
	}
	resp, err := fixDuplicatesResponse(respBody)
	if err != nil {
		l := dlog.WithIncomingContext(ctx)
		l.Errorf("Could not unmarshal JSON for path %s: %v", hydratedPath, err)
		l.Errorf("Body failure: %v", string(respBody))
		return nil, err
	}
	return resp, nil
}

func (s *RedditHttpPlugin) Hot(ctx context.Context, req *redditapi.GetHotRequest) (*redditapi.Listing, error) {
	resp := redditapi.Listing{}
	tmpSubredditValue := ""
	if req.Subreddit != nil {
		tmpSubredditValue = fmt.Sprintf("%v", req.Subreddit.Value)
	}
	tmpAfterValue := ""
	if req.After != nil {
		tmpAfterValue = fmt.Sprintf("%v", req.After.Value)
	}
	tmpBeforeValue := ""
	if req.Before != nil {
		tmpBeforeValue = fmt.Sprintf("%v", req.Before.Value)
	}
	tmpCountValue := ""
	if req.Count != nil {
		tmpCountValue = fmt.Sprintf("%v", req.Count.Value)
	}
	tmpLimitValue := ""
	if req.Limit != nil {
		tmpLimitValue = fmt.Sprintf("%v", req.Limit.Value)
	}
	tmpShowValue := ""
	if req.Show != nil {
		tmpShowValue = fmt.Sprintf("%v", req.Show.Value)
	}
	tmpGValue := ""
	if req.G != nil {
		tmpGValue = fmt.Sprintf("%v", req.G.Value)
	}
	hydratedPath := fmt.Sprintf(
		"/r/%v/hot.json?after=%v&before=%v&count=%v&limit=%v&show=%v&g=%v&raw_json=1",
		tmpSubredditValue,
		tmpAfterValue,
		tmpBeforeValue,
		tmpCountValue,
		tmpLimitValue,
		tmpShowValue,
		tmpGValue)
	err := s.doRequest(ctx, requestConfig{Method: "GET", ProtoMethod: "Hot", Path: hydratedPath}, &resp)
	if err != nil {
		return nil, err
	}
	return &resp, nil
}

func (s *RedditHttpPlugin) New(ctx context.Context, req *redditapi.GetNewRequest) (*redditapi.Listing, error) {
	resp := redditapi.Listing{}
	tmpSubredditValue := ""
	if req.Subreddit != nil {
		tmpSubredditValue = fmt.Sprintf("%v", req.Subreddit.Value)
	}
	tmpAfterValue := ""
	if req.After != nil {
		tmpAfterValue = fmt.Sprintf("%v", req.After.Value)
	}
	tmpBeforeValue := ""
	if req.Before != nil {
		tmpBeforeValue = fmt.Sprintf("%v", req.Before.Value)
	}
	tmpCountValue := ""
	if req.Count != nil {
		tmpCountValue = fmt.Sprintf("%v", req.Count.Value)
	}
	tmpLimitValue := ""
	if req.Limit != nil {
		tmpLimitValue = fmt.Sprintf("%v", req.Limit.Value)
	}
	tmpShowValue := ""
	if req.Show != nil {
		tmpShowValue = fmt.Sprintf("%v", req.Show.Value)
	}
	hydratedPath := fmt.Sprintf(
		"/r/%v/new.json?after=%v&before=%v&count=%v&limit=%v&show=%v&raw_json=1",
		tmpSubredditValue,
		tmpAfterValue,
		tmpBeforeValue,
		tmpCountValue,
		tmpLimitValue,
		tmpShowValue)
	err := s.doRequest(ctx, requestConfig{Method: "GET", ProtoMethod: "New", Path: hydratedPath}, &resp)
	if err != nil {
		return nil, err
	}
	return &resp, nil
}

func (s *RedditHttpPlugin) Rising(ctx context.Context, req *redditapi.GetRisingRequest) (*redditapi.Listing, error) {
	resp := redditapi.Listing{}
	tmpSubredditValue := ""
	if req.Subreddit != nil {
		tmpSubredditValue = fmt.Sprintf("%v", req.Subreddit.Value)
	}
	tmpAfterValue := ""
	if req.After != nil {
		tmpAfterValue = fmt.Sprintf("%v", req.After.Value)
	}
	tmpBeforeValue := ""
	if req.Before != nil {
		tmpBeforeValue = fmt.Sprintf("%v", req.Before.Value)
	}
	tmpCountValue := ""
	if req.Count != nil {
		tmpCountValue = fmt.Sprintf("%v", req.Count.Value)
	}
	tmpLimitValue := ""
	if req.Limit != nil {
		tmpLimitValue = fmt.Sprintf("%v", req.Limit.Value)
	}
	tmpShowValue := ""
	if req.Show != nil {
		tmpShowValue = fmt.Sprintf("%v", req.Show.Value)
	}
	hydratedPath := fmt.Sprintf(
		"/r/%v/rising.json?after=%v&before=%v&count=%v&limit=%v&show=%v&raw_json=1",
		tmpSubredditValue,
		tmpAfterValue,
		tmpBeforeValue,
		tmpCountValue,
		tmpLimitValue,
		tmpShowValue)
	err := s.doRequest(ctx, requestConfig{Method: "GET", ProtoMethod: "Rising", Path: hydratedPath}, &resp)
	if err != nil {
		return nil, err
	}
	return &resp, nil
}

func (s *RedditHttpPlugin) Sort(ctx context.Context, req *redditapi.GetSortRequest) (*redditapi.Listing, error) {
	resp := redditapi.Listing{}
	tmpSubredditValue := ""
	if req.Subreddit != nil {
		tmpSubredditValue = fmt.Sprintf("%v", req.Subreddit.Value)
	}
	tmpAfterValue := ""
	if req.After != nil {
		tmpAfterValue = fmt.Sprintf("%v", req.After.Value)
	}
	tmpBeforeValue := ""
	if req.Before != nil {
		tmpBeforeValue = fmt.Sprintf("%v", req.Before.Value)
	}
	tmpLimitValue := ""
	if req.Limit != nil {
		tmpLimitValue = fmt.Sprintf("%v", req.Limit.Value)
	}
	tmpCountValue := ""
	if req.Count != nil {
		tmpCountValue = fmt.Sprintf("%v", req.Count.Value)
	}
	tmpShowValue := ""
	if req.Show != nil {
		tmpShowValue = fmt.Sprintf("%v", req.Show.Value)
	}
	tmpTValue := ""
	if req.T != nil {
		tmpTValue = fmt.Sprintf("%v", req.T.Value)
	}
	hydratedPath := fmt.Sprintf(
		"/r/%v/%v.json?after=%v&before=%v&limit=%v&count=%v&show=%v&t=%v&raw_json=1",
		tmpSubredditValue,
		req.Sort,
		tmpAfterValue,
		tmpBeforeValue,
		tmpLimitValue,
		tmpCountValue,
		tmpShowValue,
		tmpTValue)
	err := s.doRequest(ctx, requestConfig{Method: "GET", ProtoMethod: "Sort", Path: hydratedPath}, &resp)
	if err != nil {
		return nil, err
	}
	return &resp, nil
}
