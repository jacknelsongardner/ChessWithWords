// Code generated by protoc-gen-go-redditapi. DO NOT EDIT.

package reddithttpplugin

import (
	context "context"
	json "encoding/json"
	fmt "fmt"
	dlog "github.snooguts.net/reddit/reddit-devplatform-monorepo/go-common/dlog"
	redditapi "github.snooguts.net/reddit/reddit-devplatform-monorepo/go-common/generated/protos/types/devvit/plugin/redditapi"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
	url "net/url"
	strconv "strconv"
)

func (s *RedditHttpPlugin) BulkReadConversations(ctx context.Context, req *redditapi.BulkReadConversationsRequest) (*redditapi.BulkReadConversationsResponse, error) {
	resp := redditapi.BulkReadConversationsResponse{}
	hydratedPath := `/api/mod/conversations/bulk/read?raw_json=1`
	body := url.Values{}
	body.Add("entity", req.Entity)
	body.Add("state", req.State)
	bodyBytes := []byte(body.Encode())
	err := s.doRequest(ctx, requestConfig{Method: "POST", ProtoMethod: "BulkReadConversations", BodyType: FORM_CAMEL, Body: bodyBytes, Path: hydratedPath}, &resp)
	if err != nil {
		return nil, err
	}
	return &resp, nil
}

func (s *RedditHttpPlugin) GetConversations(ctx context.Context, req *redditapi.GetConversationsRequest) (*redditapi.GetConversationsResponse, error) {
	tmpAfterValue := ""
	if req.After != nil {
		tmpAfterValue = fmt.Sprintf("%v", req.After.Value)
	}
	tmpEntityValue := ""
	if req.Entity != nil {
		tmpEntityValue = fmt.Sprintf("%v", req.Entity.Value)
	}
	tmpLimitValue := ""
	if req.Limit != nil {
		tmpLimitValue = fmt.Sprintf("%v", req.Limit.Value)
	}
	tmpSortValue := ""
	if req.Sort != nil {
		tmpSortValue = fmt.Sprintf("%v", req.Sort.Value)
	}
	tmpStateValue := ""
	if req.State != nil {
		tmpStateValue = fmt.Sprintf("%v", req.State.Value)
	}
	hydratedPath := fmt.Sprintf(
		"/api/mod/conversations?after=%v&entity=%v&limit=%v&sort=%v&state=%v&raw_json=1",
		tmpAfterValue,
		tmpEntityValue,
		tmpLimitValue,
		tmpSortValue,
		tmpStateValue)
	respBody, err := s.doRequestRaw(ctx, requestConfig{Method: "GET", ProtoMethod: "GetConversations", Path: hydratedPath})
	if err != nil {
		return nil, err
	}
	resp, err := fixGetConversationsResponse(respBody)
	if err != nil {
		l := dlog.WithIncomingContext(ctx)
		l.Errorf("Could not unmarshal JSON for path %s: %v", hydratedPath, err)
		l.Errorf("Body failure: %v", string(respBody))
		return nil, err
	}
	return resp, nil
}

func (s *RedditHttpPlugin) CreateConversation(ctx context.Context, req *redditapi.CreateConversationRequest) (*redditapi.CreateConversationResponse, error) {
	resp := redditapi.CreateConversationResponse{}
	hydratedPath := `/api/mod/conversations?raw_json=1`
	body := url.Values{}
	body.Add("body", req.Body)
	body.Add("isAuthorHidden", strconv.FormatBool(req.IsAuthorHidden))
	body.Add("srName", req.SrName)
	body.Add("subject", req.Subject)
	if req.To.GetValue() != "" {
		body.Add("to", req.To.GetValue())
	}
	bodyBytes := []byte(body.Encode())
	err := s.doRequest(ctx, requestConfig{Method: "POST", ProtoMethod: "CreateConversation", BodyType: FORM_CAMEL, Body: bodyBytes, Path: hydratedPath}, &resp)
	if err != nil {
		return nil, err
	}
	return &resp, nil
}

func (s *RedditHttpPlugin) GetConversation(ctx context.Context, req *redditapi.GetConversationRequest) (*redditapi.GetConversationResponse, error) {
	hydratedPath := fmt.Sprintf(
		"/api/mod/conversations/%v?markRead=%v&raw_json=1",
		req.ConversationId,
		req.MarkRead)
	respBody, err := s.doRequestRaw(ctx, requestConfig{Method: "GET", ProtoMethod: "GetConversation", Path: hydratedPath})
	if err != nil {
		return nil, err
	}
	resp, err := fixGetConversationResponse(respBody)
	if err != nil {
		l := dlog.WithIncomingContext(ctx)
		l.Errorf("Could not unmarshal JSON for path %s: %v", hydratedPath, err)
		l.Errorf("Body failure: %v", string(respBody))
		return nil, err
	}
	return resp, nil
}

func (s *RedditHttpPlugin) CreateConversationMessage(ctx context.Context, req *redditapi.CreateConversationMessageRequest) (*redditapi.CreateConversationMessageResponse, error) {
	resp := redditapi.CreateConversationMessageResponse{}
	hydratedPath := fmt.Sprintf(
		"/api/mod/conversations/%v?raw_json=1",
		req.ConversationId)
	body := url.Values{}
	body.Add("body", req.Body)
	body.Add("conversationId", req.ConversationId)
	body.Add("isAuthorHidden", strconv.FormatBool(req.IsAuthorHidden))
	body.Add("isInternal", strconv.FormatBool(req.IsInternal))
	bodyBytes := []byte(body.Encode())
	err := s.doRequest(ctx, requestConfig{Method: "POST", ProtoMethod: "CreateConversationMessage", BodyType: FORM_CAMEL, Body: bodyBytes, Path: hydratedPath}, &resp)
	if err != nil {
		return nil, err
	}
	return &resp, nil
}

func (s *RedditHttpPlugin) ApproveConversation(ctx context.Context, req *redditapi.BasicConversationRequest) (*redditapi.ApproveConversationResponse, error) {
	resp := redditapi.ApproveConversationResponse{}
	hydratedPath := fmt.Sprintf(
		"/api/mod/conversations/%v/approve?raw_json=1",
		req.ConversationId)
	err := s.doRequest(ctx, requestConfig{Method: "POST", ProtoMethod: "ApproveConversation", Path: hydratedPath}, &resp)
	if err != nil {
		return nil, err
	}
	return &resp, nil
}

func (s *RedditHttpPlugin) ArchiveConversation(ctx context.Context, req *redditapi.BasicConversationRequest) (*redditapi.ArchiveConversationResponse, error) {
	resp := redditapi.ArchiveConversationResponse{}
	hydratedPath := fmt.Sprintf(
		"/api/mod/conversations/%v/archive?raw_json=1",
		req.ConversationId)
	err := s.doRequest(ctx, requestConfig{Method: "POST", ProtoMethod: "ArchiveConversation", Path: hydratedPath}, &resp)
	if err != nil {
		return nil, err
	}
	return &resp, nil
}

func (s *RedditHttpPlugin) DisapproveConversation(ctx context.Context, req *redditapi.BasicConversationRequest) (*redditapi.ApproveConversationResponse, error) {
	resp := redditapi.ApproveConversationResponse{}
	hydratedPath := fmt.Sprintf(
		"/api/mod/conversations/%v/disapprove?raw_json=1",
		req.ConversationId)
	err := s.doRequest(ctx, requestConfig{Method: "POST", ProtoMethod: "DisapproveConversation", Path: hydratedPath}, &resp)
	if err != nil {
		return nil, err
	}
	return &resp, nil
}

func (s *RedditHttpPlugin) UnhighlightConversation(ctx context.Context, req *redditapi.BasicConversationRequest) (*redditapi.HighlightConversationResponse, error) {
	resp := redditapi.HighlightConversationResponse{}
	hydratedPath := fmt.Sprintf(
		"/api/mod/conversations/%v/highlight?raw_json=1",
		req.ConversationId)
	err := s.doRequest(ctx, requestConfig{Method: "DELETE", ProtoMethod: "UnhighlightConversation", Path: hydratedPath}, &resp)
	if err != nil {
		return nil, err
	}
	return &resp, nil
}

func (s *RedditHttpPlugin) HighlightConversation(ctx context.Context, req *redditapi.BasicConversationRequest) (*redditapi.HighlightConversationResponse, error) {
	resp := redditapi.HighlightConversationResponse{}
	hydratedPath := fmt.Sprintf(
		"/api/mod/conversations/%v/highlight?raw_json=1",
		req.ConversationId)
	err := s.doRequest(ctx, requestConfig{Method: "POST", ProtoMethod: "HighlightConversation", Path: hydratedPath}, &resp)
	if err != nil {
		return nil, err
	}
	return &resp, nil
}

func (s *RedditHttpPlugin) MuteConversation(ctx context.Context, req *redditapi.MuteConversationRequest) (*redditapi.MuteConversationResponse, error) {
	resp := redditapi.MuteConversationResponse{}
	hydratedPath := fmt.Sprintf(
		"/api/mod/conversations/%v/mute?raw_json=1",
		req.ConversationId)
	body := url.Values{}
	body.Add("conversation_id", req.ConversationId)
	body.Add("num_hours", strconv.Itoa(int(req.NumHours)))
	bodyBytes := []byte(body.Encode())
	err := s.doRequest(ctx, requestConfig{Method: "POST", ProtoMethod: "MuteConversation", BodyType: FORM_SNAKE, Body: bodyBytes, Path: hydratedPath}, &resp)
	if err != nil {
		return nil, err
	}
	return &resp, nil
}

func (s *RedditHttpPlugin) TempBan(ctx context.Context, req *redditapi.TempBanRequest) (*redditapi.TempBanResponse, error) {
	resp := redditapi.TempBanResponse{}
	hydratedPath := fmt.Sprintf(
		"/api/mod/conversations/%v/temp_ban?raw_json=1",
		req.ConversationId)
	body := make(map[string]interface{})
	body["conversationId"] = req.ConversationId
	body["duration"] = req.Duration
	bodyBytes, _ := json.Marshal(body)
	err := s.doRequest(ctx, requestConfig{Method: "POST", ProtoMethod: "TempBan", BodyType: JSON_CAMEL, Body: bodyBytes, Path: hydratedPath}, &resp)
	if err != nil {
		return nil, err
	}
	return &resp, nil
}

func (s *RedditHttpPlugin) UnarchiveConversation(ctx context.Context, req *redditapi.BasicConversationRequest) (*redditapi.ArchiveConversationResponse, error) {
	resp := redditapi.ArchiveConversationResponse{}
	hydratedPath := fmt.Sprintf(
		"/api/mod/conversations/%v/unarchive?raw_json=1",
		req.ConversationId)
	err := s.doRequest(ctx, requestConfig{Method: "POST", ProtoMethod: "UnarchiveConversation", Path: hydratedPath}, &resp)
	if err != nil {
		return nil, err
	}
	return &resp, nil
}

func (s *RedditHttpPlugin) Unban(ctx context.Context, req *redditapi.BasicConversationRequest) (*redditapi.TempBanResponse, error) {
	resp := redditapi.TempBanResponse{}
	hydratedPath := fmt.Sprintf(
		"/api/mod/conversations/%v/unban?raw_json=1",
		req.ConversationId)
	err := s.doRequest(ctx, requestConfig{Method: "POST", ProtoMethod: "Unban", Path: hydratedPath}, &resp)
	if err != nil {
		return nil, err
	}
	return &resp, nil
}

func (s *RedditHttpPlugin) UnmuteConversation(ctx context.Context, req *redditapi.BasicConversationRequest) (*redditapi.MuteConversationResponse, error) {
	resp := redditapi.MuteConversationResponse{}
	hydratedPath := fmt.Sprintf(
		"/api/mod/conversations/%v/unmute?raw_json=1",
		req.ConversationId)
	err := s.doRequest(ctx, requestConfig{Method: "POST", ProtoMethod: "UnmuteConversation", Path: hydratedPath}, &resp)
	if err != nil {
		return nil, err
	}
	return &resp, nil
}

func (s *RedditHttpPlugin) UserConversations(ctx context.Context, req *redditapi.BasicConversationRequest) (*redditapi.ConversationUserData, error) {
	resp := redditapi.ConversationUserData{}
	hydratedPath := fmt.Sprintf(
		"/api/mod/conversations/%v/user?raw_json=1",
		req.ConversationId)
	err := s.doRequest(ctx, requestConfig{Method: "GET", ProtoMethod: "UserConversations", Path: hydratedPath}, &resp)
	if err != nil {
		return nil, err
	}
	return &resp, nil
}

func (s *RedditHttpPlugin) Read(ctx context.Context, req *redditapi.BasicConversationsRequest) (*emptypb.Empty, error) {
	resp := emptypb.Empty{}
	hydratedPath := `/api/mod/conversations/read?raw_json=1`
	body := url.Values{}
	body.Add("conversationIds", req.ConversationIds)
	bodyBytes := []byte(body.Encode())
	err := s.doRequest(ctx, requestConfig{Method: "POST", ProtoMethod: "Read", BodyType: FORM_CAMEL, Body: bodyBytes, Path: hydratedPath}, &resp)
	if err != nil {
		return nil, err
	}
	return &resp, nil
}

func (s *RedditHttpPlugin) Subreddits(ctx context.Context, req *emptypb.Empty) (*redditapi.SubredditsResponse, error) {
	resp := redditapi.SubredditsResponse{}
	hydratedPath := `/api/mod/conversations/subreddits?raw_json=1`
	err := s.doRequest(ctx, requestConfig{Method: "GET", ProtoMethod: "Subreddits", Path: hydratedPath}, &resp)
	if err != nil {
		return nil, err
	}
	return &resp, nil
}

func (s *RedditHttpPlugin) Unread(ctx context.Context, req *redditapi.BasicConversationsRequest) (*emptypb.Empty, error) {
	resp := emptypb.Empty{}
	hydratedPath := `/api/mod/conversations/unread?raw_json=1`
	body := url.Values{}
	body.Add("conversationIds", req.ConversationIds)
	bodyBytes := []byte(body.Encode())
	err := s.doRequest(ctx, requestConfig{Method: "POST", ProtoMethod: "Unread", BodyType: FORM_CAMEL, Body: bodyBytes, Path: hydratedPath}, &resp)
	if err != nil {
		return nil, err
	}
	return &resp, nil
}

func (s *RedditHttpPlugin) UnreadCount(ctx context.Context, req *emptypb.Empty) (*redditapi.UnreadCountResponse, error) {
	resp := redditapi.UnreadCountResponse{}
	hydratedPath := `/api/mod/conversations/unread/count?raw_json=1`
	err := s.doRequest(ctx, requestConfig{Method: "GET", ProtoMethod: "UnreadCount", Path: hydratedPath}, &resp)
	if err != nil {
		return nil, err
	}
	return &resp, nil
}
