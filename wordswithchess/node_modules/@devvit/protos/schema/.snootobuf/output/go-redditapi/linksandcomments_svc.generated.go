// Code generated by protoc-gen-go-redditapi. DO NOT EDIT.

package reddithttpplugin

import (
	context "context"
	fmt "fmt"
	dlog "github.snooguts.net/reddit/reddit-devplatform-monorepo/go-common/dlog"
	redditapi "github.snooguts.net/reddit/reddit-devplatform-monorepo/go-common/generated/protos/types/devvit/plugin/redditapi"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
	url "net/url"
	strconv "strconv"
	strings "strings"
)

func (s *RedditHttpPlugin) Comment(ctx context.Context, req *redditapi.CommentRequest) (*redditapi.JsonWrappedComment, error) {
	hydratedPath := `/api/comment?raw_json=1`
	body := url.Values{}
	body.Add("api_type", "json")
	if req.RichtextJson.GetValue() != "" {
		body.Add("richtext_json", req.RichtextJson.GetValue())
	}
	body.Add("run_as", req.RunAs.String())
	body.Add("run_as_user_scopes", "SUBMIT_COMMENT")
	body.Add("text", req.Text)
	body.Add("thing_id", req.ThingId)
	bodyBytes := []byte(body.Encode())
	respBody, err := s.doRequestRaw(ctx, requestConfig{Method: "POST", ProtoMethod: "Comment", BodyType: FORM_SNAKE, Body: bodyBytes, Path: hydratedPath})
	if err != nil {
		return nil, err
	}
	resp, err := fixCommentResponse(respBody)
	if err != nil {
		l := dlog.WithIncomingContext(ctx)
		l.Errorf("Could not unmarshal JSON for path %s: %v", hydratedPath, err)
		l.Errorf("Body failure: %v", string(respBody))
		return nil, err
	}
	return resp, nil
}

func (s *RedditHttpPlugin) Del(ctx context.Context, req *redditapi.BasicIdRequest) (*emptypb.Empty, error) {
	resp := emptypb.Empty{}
	hydratedPath := `/api/del?raw_json=1`
	body := url.Values{}
	body.Add("id", req.Id)
	bodyBytes := []byte(body.Encode())
	err := s.doRequest(ctx, requestConfig{Method: "POST", ProtoMethod: "Del", BodyType: FORM_SNAKE, Body: bodyBytes, Path: hydratedPath}, &resp)
	if err != nil {
		return nil, err
	}
	return &resp, nil
}

func (s *RedditHttpPlugin) EditUserText(ctx context.Context, req *redditapi.CommentRequest) (*redditapi.JsonWrappedComment, error) {
	hydratedPath := `/api/editusertext?raw_json=1`
	body := url.Values{}
	body.Add("api_type", "json")
	if req.RichtextJson.GetValue() != "" {
		body.Add("richtext_json", req.RichtextJson.GetValue())
	}
	body.Add("run_as", req.RunAs.String())
	body.Add("text", req.Text)
	body.Add("thing_id", req.ThingId)
	bodyBytes := []byte(body.Encode())
	respBody, err := s.doRequestRaw(ctx, requestConfig{Method: "POST", ProtoMethod: "EditUserText", BodyType: FORM_SNAKE, Body: bodyBytes, Path: hydratedPath})
	if err != nil {
		return nil, err
	}
	resp, err := fixEditUserTextResponse(respBody)
	if err != nil {
		l := dlog.WithIncomingContext(ctx)
		l.Errorf("Could not unmarshal JSON for path %s: %v", hydratedPath, err)
		l.Errorf("Body failure: %v", string(respBody))
		return nil, err
	}
	return resp, nil
}

func (s *RedditHttpPlugin) FollowPost(ctx context.Context, req *redditapi.FollowPostRequest) (*emptypb.Empty, error) {
	resp := emptypb.Empty{}
	hydratedPath := `/api/follow_post?raw_json=1`
	body := url.Values{}
	body.Add("follow", strconv.FormatBool(req.Follow))
	body.Add("fullname", req.Fullname)
	bodyBytes := []byte(body.Encode())
	err := s.doRequest(ctx, requestConfig{Method: "POST", ProtoMethod: "FollowPost", BodyType: FORM_SNAKE, Body: bodyBytes, Path: hydratedPath}, &resp)
	if err != nil {
		return nil, err
	}
	return &resp, nil
}

func (s *RedditHttpPlugin) Hide(ctx context.Context, req *redditapi.BasicIdRequest) (*emptypb.Empty, error) {
	resp := emptypb.Empty{}
	hydratedPath := `/api/hide?raw_json=1`
	body := url.Values{}
	body.Add("id", req.Id)
	bodyBytes := []byte(body.Encode())
	err := s.doRequest(ctx, requestConfig{Method: "POST", ProtoMethod: "Hide", BodyType: FORM_SNAKE, Body: bodyBytes, Path: hydratedPath}, &resp)
	if err != nil {
		return nil, err
	}
	return &resp, nil
}

func (s *RedditHttpPlugin) Info(ctx context.Context, req *redditapi.InfoRequest) (*redditapi.Listing, error) {
	resp := redditapi.Listing{}
	tmpUrlValue := ""
	if req.Url != nil {
		tmpUrlValue = fmt.Sprintf("%v", req.Url.Value)
	}
	hydratedPath := fmt.Sprintf(
		"/api/info.json?sr_name=%v&id=%v&url=%v&rtj=1&raw_json=1",
		strings.Join(req.Subreddits, ","),
		strings.Join(req.ThingIds, ","),
		tmpUrlValue)
	err := s.doRequest(ctx, requestConfig{Method: "GET", ProtoMethod: "Info", Path: hydratedPath}, &resp)
	if err != nil {
		return nil, err
	}
	return &resp, nil
}

func (s *RedditHttpPlugin) Lock(ctx context.Context, req *redditapi.BasicIdRequest) (*emptypb.Empty, error) {
	resp := emptypb.Empty{}
	hydratedPath := `/api/lock?raw_json=1`
	body := url.Values{}
	body.Add("id", req.Id)
	bodyBytes := []byte(body.Encode())
	err := s.doRequest(ctx, requestConfig{Method: "POST", ProtoMethod: "Lock", BodyType: FORM_SNAKE, Body: bodyBytes, Path: hydratedPath}, &resp)
	if err != nil {
		return nil, err
	}
	return &resp, nil
}

func (s *RedditHttpPlugin) MarkNSFW(ctx context.Context, req *redditapi.BasicIdRequest) (*emptypb.Empty, error) {
	resp := emptypb.Empty{}
	hydratedPath := `/api/marknsfw?raw_json=1`
	body := url.Values{}
	body.Add("id", req.Id)
	bodyBytes := []byte(body.Encode())
	err := s.doRequest(ctx, requestConfig{Method: "POST", ProtoMethod: "MarkNSFW", BodyType: FORM_SNAKE, Body: bodyBytes, Path: hydratedPath}, &resp)
	if err != nil {
		return nil, err
	}
	return &resp, nil
}

func (s *RedditHttpPlugin) MoreChildren(ctx context.Context, req *redditapi.MoreChildrenRequest) (*redditapi.JsonWrappedComment, error) {
	tmpDepthValue := ""
	if req.Depth != nil {
		tmpDepthValue = fmt.Sprintf("%v", req.Depth.Value)
	}
	tmpIdValue := ""
	if req.Id != nil {
		tmpIdValue = fmt.Sprintf("%v", req.Id.Value)
	}
	tmpLimitChildrenValue := ""
	if req.LimitChildren != nil {
		tmpLimitChildrenValue = fmt.Sprintf("%v", req.LimitChildren.Value)
	}
	tmpSortValue := ""
	if req.Sort != nil {
		tmpSortValue = fmt.Sprintf("%v", req.Sort.Value)
	}
	hydratedPath := fmt.Sprintf(
		"/api/morechildren?children=%v&depth=%v&id=%v&limit_children=%v&link_id=%v&sort=%v&api_type=json&raw_json=1",
		strings.Join(req.Children, ","),
		tmpDepthValue,
		tmpIdValue,
		tmpLimitChildrenValue,
		req.LinkId,
		tmpSortValue)
	respBody, err := s.doRequestRaw(ctx, requestConfig{Method: "GET", ProtoMethod: "MoreChildren", Path: hydratedPath})
	if err != nil {
		return nil, err
	}
	resp, err := fixMoreChildrenResponse(respBody)
	if err != nil {
		l := dlog.WithIncomingContext(ctx)
		l.Errorf("Could not unmarshal JSON for path %s: %v", hydratedPath, err)
		l.Errorf("Body failure: %v", string(respBody))
		return nil, err
	}
	return resp, nil
}

func (s *RedditHttpPlugin) Report(ctx context.Context, req *redditapi.ReportRequest) (*redditapi.JsonStatus, error) {
	resp := redditapi.JsonStatus{}
	hydratedPath := `/api/report?raw_json=1`
	body := url.Values{}
	if req.AdditionalInfo.GetValue() != "" {
		body.Add("additional_info", req.AdditionalInfo.GetValue())
	}
	body.Add("api_type", "json")
	if req.CustomText.GetValue() != "" {
		body.Add("custom_text", req.CustomText.GetValue())
	}
	if req.ModmailConvId.GetValue() != "" {
		body.Add("modmail_conv_id", req.ModmailConvId.GetValue())
	}
	if req.OtherReason.GetValue() != "" {
		body.Add("other_reason", req.OtherReason.GetValue())
	}
	body.Add("reason", req.Reason)
	if req.RuleReason.GetValue() != "" {
		body.Add("rule_reason", req.RuleReason.GetValue())
	}
	if req.SiteReason.GetValue() != "" {
		body.Add("site_reason", req.SiteReason.GetValue())
	}
	if req.SrName.GetValue() != "" {
		body.Add("sr_name", req.SrName.GetValue())
	}
	body.Add("thing_id", req.ThingId)
	if req.Usernames.GetValue() != "" {
		body.Add("usernames", req.Usernames.GetValue())
	}
	bodyBytes := []byte(body.Encode())
	err := s.doRequest(ctx, requestConfig{Method: "POST", ProtoMethod: "Report", BodyType: FORM_SNAKE, Body: bodyBytes, Path: hydratedPath}, &resp)
	if err != nil {
		return nil, err
	}
	return &resp, nil
}

func (s *RedditHttpPlugin) ReportAward(ctx context.Context, req *redditapi.ReportAwardRequest) (*emptypb.Empty, error) {
	resp := emptypb.Empty{}
	hydratedPath := `/api/report_award?raw_json=1`
	body := url.Values{}
	body.Add("award_id", req.AwardId)
	if req.Reason.GetValue() != "" {
		body.Add("reason", req.Reason.GetValue())
	}
	bodyBytes := []byte(body.Encode())
	err := s.doRequest(ctx, requestConfig{Method: "POST", ProtoMethod: "ReportAward", BodyType: FORM_SNAKE, Body: bodyBytes, Path: hydratedPath}, &resp)
	if err != nil {
		return nil, err
	}
	return &resp, nil
}

func (s *RedditHttpPlugin) Save(ctx context.Context, req *redditapi.SaveRequest) (*emptypb.Empty, error) {
	resp := emptypb.Empty{}
	hydratedPath := `/api/save?raw_json=1`
	body := url.Values{}
	body.Add("id", req.Id)
	bodyBytes := []byte(body.Encode())
	err := s.doRequest(ctx, requestConfig{Method: "POST", ProtoMethod: "Save", BodyType: FORM_SNAKE, Body: bodyBytes, Path: hydratedPath}, &resp)
	if err != nil {
		return nil, err
	}
	return &resp, nil
}

func (s *RedditHttpPlugin) SendReplies(ctx context.Context, req *redditapi.SendRepliesRequest) (*emptypb.Empty, error) {
	resp := emptypb.Empty{}
	hydratedPath := `/api/sendreplies?raw_json=1`
	body := url.Values{}
	body.Add("id", req.Id)
	body.Add("state", strconv.FormatBool(req.State))
	bodyBytes := []byte(body.Encode())
	err := s.doRequest(ctx, requestConfig{Method: "POST", ProtoMethod: "SendReplies", BodyType: FORM_SNAKE, Body: bodyBytes, Path: hydratedPath}, &resp)
	if err != nil {
		return nil, err
	}
	return &resp, nil
}

func (s *RedditHttpPlugin) SetContestMode(ctx context.Context, req *redditapi.SetContestModeRequest) (*redditapi.JsonStatus, error) {
	resp := redditapi.JsonStatus{}
	hydratedPath := `/api/set_contest_mode?raw_json=1`
	body := url.Values{}
	body.Add("api_type", "json")
	body.Add("id", req.Id)
	body.Add("state", strconv.FormatBool(req.State))
	bodyBytes := []byte(body.Encode())
	err := s.doRequest(ctx, requestConfig{Method: "POST", ProtoMethod: "SetContestMode", BodyType: FORM_SNAKE, Body: bodyBytes, Path: hydratedPath}, &resp)
	if err != nil {
		return nil, err
	}
	return &resp, nil
}

func (s *RedditHttpPlugin) SetSubredditSticky(ctx context.Context, req *redditapi.SetSubredditStickyRequest) (*redditapi.JsonStatus, error) {
	resp := redditapi.JsonStatus{}
	hydratedPath := `/api/set_subreddit_sticky?raw_json=1`
	body := url.Values{}
	body.Add("api_type", "json")
	body.Add("id", req.Id)
	if req.Num.GetValue() != 0 {
		body.Add("num", strconv.Itoa(int(req.Num.GetValue())))
	}
	body.Add("state", strconv.FormatBool(req.State))
	if req.ToProfile.GetValue() != false {
		body.Add("to_profile", strconv.FormatBool(req.ToProfile.GetValue()))
	}
	bodyBytes := []byte(body.Encode())
	err := s.doRequest(ctx, requestConfig{Method: "POST", ProtoMethod: "SetSubredditSticky", BodyType: FORM_SNAKE, Body: bodyBytes, Path: hydratedPath}, &resp)
	if err != nil {
		return nil, err
	}
	return &resp, nil
}

func (s *RedditHttpPlugin) SetSuggestedSort(ctx context.Context, req *redditapi.SetSuggestedSortRequest) (*redditapi.JsonStatus, error) {
	resp := redditapi.JsonStatus{}
	hydratedPath := `/api/set_suggested_sort?raw_json=1`
	body := url.Values{}
	body.Add("api_type", "json")
	body.Add("id", req.Id)
	body.Add("sort", req.Sort)
	bodyBytes := []byte(body.Encode())
	err := s.doRequest(ctx, requestConfig{Method: "POST", ProtoMethod: "SetSuggestedSort", BodyType: FORM_SNAKE, Body: bodyBytes, Path: hydratedPath}, &resp)
	if err != nil {
		return nil, err
	}
	return &resp, nil
}

func (s *RedditHttpPlugin) Spoiler(ctx context.Context, req *redditapi.BasicIdRequest) (*emptypb.Empty, error) {
	resp := emptypb.Empty{}
	hydratedPath := `/api/spoiler?raw_json=1`
	body := url.Values{}
	body.Add("id", req.Id)
	bodyBytes := []byte(body.Encode())
	err := s.doRequest(ctx, requestConfig{Method: "POST", ProtoMethod: "Spoiler", BodyType: FORM_SNAKE, Body: bodyBytes, Path: hydratedPath}, &resp)
	if err != nil {
		return nil, err
	}
	return &resp, nil
}

func (s *RedditHttpPlugin) Unhide(ctx context.Context, req *redditapi.BasicIdRequest) (*emptypb.Empty, error) {
	resp := emptypb.Empty{}
	hydratedPath := `/api/unhide?raw_json=1`
	body := url.Values{}
	body.Add("id", req.Id)
	bodyBytes := []byte(body.Encode())
	err := s.doRequest(ctx, requestConfig{Method: "POST", ProtoMethod: "Unhide", BodyType: FORM_SNAKE, Body: bodyBytes, Path: hydratedPath}, &resp)
	if err != nil {
		return nil, err
	}
	return &resp, nil
}

func (s *RedditHttpPlugin) Unlock(ctx context.Context, req *redditapi.BasicIdRequest) (*emptypb.Empty, error) {
	resp := emptypb.Empty{}
	hydratedPath := `/api/unlock?raw_json=1`
	body := url.Values{}
	body.Add("id", req.Id)
	bodyBytes := []byte(body.Encode())
	err := s.doRequest(ctx, requestConfig{Method: "POST", ProtoMethod: "Unlock", BodyType: FORM_SNAKE, Body: bodyBytes, Path: hydratedPath}, &resp)
	if err != nil {
		return nil, err
	}
	return &resp, nil
}

func (s *RedditHttpPlugin) UnmarkNSFW(ctx context.Context, req *redditapi.BasicIdRequest) (*emptypb.Empty, error) {
	resp := emptypb.Empty{}
	hydratedPath := `/api/unmarknsfw?raw_json=1`
	body := url.Values{}
	body.Add("id", req.Id)
	bodyBytes := []byte(body.Encode())
	err := s.doRequest(ctx, requestConfig{Method: "POST", ProtoMethod: "UnmarkNSFW", BodyType: FORM_SNAKE, Body: bodyBytes, Path: hydratedPath}, &resp)
	if err != nil {
		return nil, err
	}
	return &resp, nil
}

func (s *RedditHttpPlugin) Unsave(ctx context.Context, req *redditapi.BasicIdRequest) (*emptypb.Empty, error) {
	resp := emptypb.Empty{}
	hydratedPath := `/api/unsave?raw_json=1`
	body := url.Values{}
	body.Add("id", req.Id)
	bodyBytes := []byte(body.Encode())
	err := s.doRequest(ctx, requestConfig{Method: "POST", ProtoMethod: "Unsave", BodyType: FORM_SNAKE, Body: bodyBytes, Path: hydratedPath}, &resp)
	if err != nil {
		return nil, err
	}
	return &resp, nil
}

func (s *RedditHttpPlugin) Unspoiler(ctx context.Context, req *redditapi.BasicIdRequest) (*emptypb.Empty, error) {
	resp := emptypb.Empty{}
	hydratedPath := `/api/unspoiler?raw_json=1`
	body := url.Values{}
	body.Add("id", req.Id)
	bodyBytes := []byte(body.Encode())
	err := s.doRequest(ctx, requestConfig{Method: "POST", ProtoMethod: "Unspoiler", BodyType: FORM_SNAKE, Body: bodyBytes, Path: hydratedPath}, &resp)
	if err != nil {
		return nil, err
	}
	return &resp, nil
}

func (s *RedditHttpPlugin) Vote(ctx context.Context, req *redditapi.VoteRequest) (*emptypb.Empty, error) {
	resp := emptypb.Empty{}
	hydratedPath := `/api/vote?raw_json=1`
	body := url.Values{}
	body.Add("dir", strconv.Itoa(int(req.Dir)))
	body.Add("id", req.Id)
	bodyBytes := []byte(body.Encode())
	err := s.doRequest(ctx, requestConfig{Method: "POST", ProtoMethod: "Vote", BodyType: FORM_SNAKE, Body: bodyBytes, Path: hydratedPath}, &resp)
	if err != nil {
		return nil, err
	}
	return &resp, nil
}
