// Code generated by protoc-gen-go-redditapi. DO NOT EDIT.

package reddithttpplugin

import (
	context "context"
	fmt "fmt"
	dlog "github.snooguts.net/reddit/reddit-devplatform-monorepo/go-common/dlog"
	redditapi "github.snooguts.net/reddit/reddit-devplatform-monorepo/go-common/generated/protos/types/devvit/plugin/redditapi"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
	wrapperspb "google.golang.org/protobuf/types/known/wrapperspb"
	url "net/url"
	strconv "strconv"
)

func (s *RedditHttpPlugin) AboutLog(ctx context.Context, req *redditapi.AboutLogRequest) (*redditapi.AboutLogResponse, error) {
	resp := redditapi.AboutLogResponse{}
	tmpSubredditValue := ""
	if req.Subreddit != nil {
		tmpSubredditValue = fmt.Sprintf("%v", req.Subreddit.Value)
	}
	tmpAfterValue := ""
	if req.After != nil {
		tmpAfterValue = fmt.Sprintf("%v", req.After.Value)
	}
	tmpBeforeValue := ""
	if req.Before != nil {
		tmpBeforeValue = fmt.Sprintf("%v", req.Before.Value)
	}
	tmpCountValue := ""
	if req.Count != nil {
		tmpCountValue = fmt.Sprintf("%v", req.Count.Value)
	}
	tmpLimitValue := ""
	if req.Limit != nil {
		tmpLimitValue = fmt.Sprintf("%v", req.Limit.Value)
	}
	tmpShowValue := ""
	if req.Show != nil {
		tmpShowValue = fmt.Sprintf("%v", req.Show.Value)
	}
	tmpModValue := ""
	if req.Mod != nil {
		tmpModValue = fmt.Sprintf("%v", req.Mod.Value)
	}
	tmpTypeValue := ""
	if req.Type != nil {
		tmpTypeValue = fmt.Sprintf("%v", req.Type.Value)
	}
	hydratedPath := fmt.Sprintf(
		"/r/%v/about/log?after=%v&before=%v&count=%v&limit=%v&show=%v&mod=%v&type=%v&raw_json=1",
		tmpSubredditValue,
		tmpAfterValue,
		tmpBeforeValue,
		tmpCountValue,
		tmpLimitValue,
		tmpShowValue,
		tmpModValue,
		tmpTypeValue)
	subredditValidationErr := s.validateSubreddit(ctx, req.Subreddit.GetValue())
	if subredditValidationErr != nil {
		return nil, subredditValidationErr
	}
	err := s.doRequest(ctx, requestConfig{Method: "GET", ProtoMethod: "AboutLog", Path: hydratedPath}, &resp)
	if err != nil {
		return nil, err
	}
	return &resp, nil
}

func (s *RedditHttpPlugin) AboutLocation(ctx context.Context, req *redditapi.AboutLocationRequest) (*redditapi.Listing, error) {
	resp := redditapi.Listing{}
	tmpAfterValue := ""
	if req.After != nil {
		tmpAfterValue = fmt.Sprintf("%v", req.After.Value)
	}
	tmpBeforeValue := ""
	if req.Before != nil {
		tmpBeforeValue = fmt.Sprintf("%v", req.Before.Value)
	}
	tmpCountValue := ""
	if req.Count != nil {
		tmpCountValue = fmt.Sprintf("%v", req.Count.Value)
	}
	tmpLimitValue := ""
	if req.Limit != nil {
		tmpLimitValue = fmt.Sprintf("%v", req.Limit.Value)
	}
	tmpShowValue := ""
	if req.Show != nil {
		tmpShowValue = fmt.Sprintf("%v", req.Show.Value)
	}
	tmpOnlyValue := ""
	if req.Only != nil {
		tmpOnlyValue = fmt.Sprintf("%v", req.Only.Value)
	}
	hydratedPath := fmt.Sprintf(
		"/r/%v/about/%v?after=%v&before=%v&count=%v&limit=%v&show=%v&only=%v&raw_json=1",
		req.Subreddit,
		req.Location,
		tmpAfterValue,
		tmpBeforeValue,
		tmpCountValue,
		tmpLimitValue,
		tmpShowValue,
		tmpOnlyValue)
	subredditValidationErr := s.validateSubreddit(ctx, req.Subreddit)
	if subredditValidationErr != nil {
		return nil, subredditValidationErr
	}
	err := s.doRequest(ctx, requestConfig{Method: "GET", ProtoMethod: "AboutLocation", Path: hydratedPath}, &resp)
	if err != nil {
		return nil, err
	}
	return &resp, nil
}

func (s *RedditHttpPlugin) AboutReports(ctx context.Context, req *redditapi.AboutLocationRequest) (*redditapi.Listing, error) {
	resp := redditapi.Listing{}
	tmpAfterValue := ""
	if req.After != nil {
		tmpAfterValue = fmt.Sprintf("%v", req.After.Value)
	}
	tmpBeforeValue := ""
	if req.Before != nil {
		tmpBeforeValue = fmt.Sprintf("%v", req.Before.Value)
	}
	tmpCountValue := ""
	if req.Count != nil {
		tmpCountValue = fmt.Sprintf("%v", req.Count.Value)
	}
	tmpLimitValue := ""
	if req.Limit != nil {
		tmpLimitValue = fmt.Sprintf("%v", req.Limit.Value)
	}
	tmpShowValue := ""
	if req.Show != nil {
		tmpShowValue = fmt.Sprintf("%v", req.Show.Value)
	}
	tmpOnlyValue := ""
	if req.Only != nil {
		tmpOnlyValue = fmt.Sprintf("%v", req.Only.Value)
	}
	hydratedPath := fmt.Sprintf(
		"/r/%v/about/reports?after=%v&before=%v&count=%v&limit=%v&show=%v&only=%v&raw_json=1",
		req.Subreddit,
		tmpAfterValue,
		tmpBeforeValue,
		tmpCountValue,
		tmpLimitValue,
		tmpShowValue,
		tmpOnlyValue)
	subredditValidationErr := s.validateSubreddit(ctx, req.Subreddit)
	if subredditValidationErr != nil {
		return nil, subredditValidationErr
	}
	err := s.doRequest(ctx, requestConfig{Method: "GET", ProtoMethod: "AboutReports", Path: hydratedPath}, &resp)
	if err != nil {
		return nil, err
	}
	return &resp, nil
}

func (s *RedditHttpPlugin) AboutSpam(ctx context.Context, req *redditapi.AboutLocationRequest) (*redditapi.Listing, error) {
	resp := redditapi.Listing{}
	tmpAfterValue := ""
	if req.After != nil {
		tmpAfterValue = fmt.Sprintf("%v", req.After.Value)
	}
	tmpBeforeValue := ""
	if req.Before != nil {
		tmpBeforeValue = fmt.Sprintf("%v", req.Before.Value)
	}
	tmpCountValue := ""
	if req.Count != nil {
		tmpCountValue = fmt.Sprintf("%v", req.Count.Value)
	}
	tmpLimitValue := ""
	if req.Limit != nil {
		tmpLimitValue = fmt.Sprintf("%v", req.Limit.Value)
	}
	tmpShowValue := ""
	if req.Show != nil {
		tmpShowValue = fmt.Sprintf("%v", req.Show.Value)
	}
	tmpOnlyValue := ""
	if req.Only != nil {
		tmpOnlyValue = fmt.Sprintf("%v", req.Only.Value)
	}
	hydratedPath := fmt.Sprintf(
		"/r/%v/about/spam?after=%v&before=%v&count=%v&limit=%v&show=%v&only=%v&raw_json=1",
		req.Subreddit,
		tmpAfterValue,
		tmpBeforeValue,
		tmpCountValue,
		tmpLimitValue,
		tmpShowValue,
		tmpOnlyValue)
	subredditValidationErr := s.validateSubreddit(ctx, req.Subreddit)
	if subredditValidationErr != nil {
		return nil, subredditValidationErr
	}
	err := s.doRequest(ctx, requestConfig{Method: "GET", ProtoMethod: "AboutSpam", Path: hydratedPath}, &resp)
	if err != nil {
		return nil, err
	}
	return &resp, nil
}

func (s *RedditHttpPlugin) AboutModqueue(ctx context.Context, req *redditapi.AboutLocationRequest) (*redditapi.Listing, error) {
	resp := redditapi.Listing{}
	tmpAfterValue := ""
	if req.After != nil {
		tmpAfterValue = fmt.Sprintf("%v", req.After.Value)
	}
	tmpBeforeValue := ""
	if req.Before != nil {
		tmpBeforeValue = fmt.Sprintf("%v", req.Before.Value)
	}
	tmpCountValue := ""
	if req.Count != nil {
		tmpCountValue = fmt.Sprintf("%v", req.Count.Value)
	}
	tmpLimitValue := ""
	if req.Limit != nil {
		tmpLimitValue = fmt.Sprintf("%v", req.Limit.Value)
	}
	tmpShowValue := ""
	if req.Show != nil {
		tmpShowValue = fmt.Sprintf("%v", req.Show.Value)
	}
	tmpOnlyValue := ""
	if req.Only != nil {
		tmpOnlyValue = fmt.Sprintf("%v", req.Only.Value)
	}
	hydratedPath := fmt.Sprintf(
		"/r/%v/about/modqueue?after=%v&before=%v&count=%v&limit=%v&show=%v&only=%v&raw_json=1",
		req.Subreddit,
		tmpAfterValue,
		tmpBeforeValue,
		tmpCountValue,
		tmpLimitValue,
		tmpShowValue,
		tmpOnlyValue)
	subredditValidationErr := s.validateSubreddit(ctx, req.Subreddit)
	if subredditValidationErr != nil {
		return nil, subredditValidationErr
	}
	err := s.doRequest(ctx, requestConfig{Method: "GET", ProtoMethod: "AboutModqueue", Path: hydratedPath}, &resp)
	if err != nil {
		return nil, err
	}
	return &resp, nil
}

func (s *RedditHttpPlugin) AboutUnmoderated(ctx context.Context, req *redditapi.AboutLocationRequest) (*redditapi.Listing, error) {
	resp := redditapi.Listing{}
	tmpAfterValue := ""
	if req.After != nil {
		tmpAfterValue = fmt.Sprintf("%v", req.After.Value)
	}
	tmpBeforeValue := ""
	if req.Before != nil {
		tmpBeforeValue = fmt.Sprintf("%v", req.Before.Value)
	}
	tmpCountValue := ""
	if req.Count != nil {
		tmpCountValue = fmt.Sprintf("%v", req.Count.Value)
	}
	tmpLimitValue := ""
	if req.Limit != nil {
		tmpLimitValue = fmt.Sprintf("%v", req.Limit.Value)
	}
	tmpShowValue := ""
	if req.Show != nil {
		tmpShowValue = fmt.Sprintf("%v", req.Show.Value)
	}
	tmpOnlyValue := ""
	if req.Only != nil {
		tmpOnlyValue = fmt.Sprintf("%v", req.Only.Value)
	}
	hydratedPath := fmt.Sprintf(
		"/r/%v/about/unmoderated?after=%v&before=%v&count=%v&limit=%v&show=%v&only=%v&raw_json=1",
		req.Subreddit,
		tmpAfterValue,
		tmpBeforeValue,
		tmpCountValue,
		tmpLimitValue,
		tmpShowValue,
		tmpOnlyValue)
	subredditValidationErr := s.validateSubreddit(ctx, req.Subreddit)
	if subredditValidationErr != nil {
		return nil, subredditValidationErr
	}
	err := s.doRequest(ctx, requestConfig{Method: "GET", ProtoMethod: "AboutUnmoderated", Path: hydratedPath}, &resp)
	if err != nil {
		return nil, err
	}
	return &resp, nil
}

func (s *RedditHttpPlugin) AboutEdited(ctx context.Context, req *redditapi.AboutLocationRequest) (*redditapi.Listing, error) {
	resp := redditapi.Listing{}
	tmpAfterValue := ""
	if req.After != nil {
		tmpAfterValue = fmt.Sprintf("%v", req.After.Value)
	}
	tmpBeforeValue := ""
	if req.Before != nil {
		tmpBeforeValue = fmt.Sprintf("%v", req.Before.Value)
	}
	tmpCountValue := ""
	if req.Count != nil {
		tmpCountValue = fmt.Sprintf("%v", req.Count.Value)
	}
	tmpLimitValue := ""
	if req.Limit != nil {
		tmpLimitValue = fmt.Sprintf("%v", req.Limit.Value)
	}
	tmpShowValue := ""
	if req.Show != nil {
		tmpShowValue = fmt.Sprintf("%v", req.Show.Value)
	}
	tmpOnlyValue := ""
	if req.Only != nil {
		tmpOnlyValue = fmt.Sprintf("%v", req.Only.Value)
	}
	hydratedPath := fmt.Sprintf(
		"/r/%v/about/edited?after=%v&before=%v&count=%v&limit=%v&show=%v&only=%v&raw_json=1",
		req.Subreddit,
		tmpAfterValue,
		tmpBeforeValue,
		tmpCountValue,
		tmpLimitValue,
		tmpShowValue,
		tmpOnlyValue)
	subredditValidationErr := s.validateSubreddit(ctx, req.Subreddit)
	if subredditValidationErr != nil {
		return nil, subredditValidationErr
	}
	err := s.doRequest(ctx, requestConfig{Method: "GET", ProtoMethod: "AboutEdited", Path: hydratedPath}, &resp)
	if err != nil {
		return nil, err
	}
	return &resp, nil
}

func (s *RedditHttpPlugin) AcceptModeratorInvite(ctx context.Context, req *redditapi.AcceptModeratorInviteRequest) (*redditapi.JsonStatus, error) {
	resp := redditapi.JsonStatus{}
	hydratedPath := fmt.Sprintf(
		"/r/%v/api/accept_moderator_invite?raw_json=1",
		req.Subreddit)
	subredditValidationErr := s.validateSubreddit(ctx, req.Subreddit)
	if subredditValidationErr != nil {
		return nil, subredditValidationErr
	}
	err := s.doRequest(ctx, requestConfig{Method: "POST", ProtoMethod: "AcceptModeratorInvite", Path: hydratedPath}, &resp)
	if err != nil {
		return nil, err
	}
	return &resp, nil
}

func (s *RedditHttpPlugin) Approve(ctx context.Context, req *redditapi.BasicModerationIdRequest) (*emptypb.Empty, error) {
	resp := emptypb.Empty{}
	hydratedPath := `/api/approve?raw_json=1`
	contextValidationErr := s.validateContextId(ctx, req.Id)
	if contextValidationErr != nil {
		return nil, contextValidationErr
	}
	body := url.Values{}
	body.Add("id", req.Id)
	bodyBytes := []byte(body.Encode())
	err := s.doRequest(ctx, requestConfig{Method: "POST", ProtoMethod: "Approve", BodyType: FORM_CAMEL, Body: bodyBytes, Path: hydratedPath}, &resp)
	if err != nil {
		return nil, err
	}
	return &resp, nil
}

func (s *RedditHttpPlugin) Distinguish(ctx context.Context, req *redditapi.DistinguishRequest) (*redditapi.JsonRedditObjects, error) {
	resp := redditapi.JsonRedditObjects{}
	hydratedPath := `/api/distinguish?raw_json=1`
	contextValidationErr := s.validateContextId(ctx, req.Id)
	if contextValidationErr != nil {
		return nil, contextValidationErr
	}
	body := url.Values{}
	body.Add("api_type", "json")
	body.Add("how", req.How)
	body.Add("id", req.Id)
	body.Add("sticky", strconv.FormatBool(req.Sticky))
	bodyBytes := []byte(body.Encode())
	err := s.doRequest(ctx, requestConfig{Method: "POST", ProtoMethod: "Distinguish", BodyType: FORM_SNAKE, Body: bodyBytes, Path: hydratedPath}, &resp)
	if err != nil {
		return nil, err
	}
	return &resp, nil
}

func (s *RedditHttpPlugin) IgnoreReports(ctx context.Context, req *redditapi.BasicModerationIdRequest) (*emptypb.Empty, error) {
	resp := emptypb.Empty{}
	hydratedPath := `/api/ignore_reports?raw_json=1`
	contextValidationErr := s.validateContextId(ctx, req.Id)
	if contextValidationErr != nil {
		return nil, contextValidationErr
	}
	body := url.Values{}
	body.Add("id", req.Id)
	bodyBytes := []byte(body.Encode())
	err := s.doRequest(ctx, requestConfig{Method: "POST", ProtoMethod: "IgnoreReports", BodyType: FORM_CAMEL, Body: bodyBytes, Path: hydratedPath}, &resp)
	if err != nil {
		return nil, err
	}
	return &resp, nil
}

func (s *RedditHttpPlugin) LeaveContributor(ctx context.Context, req *redditapi.BasicModerationIdRequest) (*emptypb.Empty, error) {
	resp := emptypb.Empty{}
	hydratedPath := `/api/leavecontributor?raw_json=1`
	body := url.Values{}
	body.Add("id", req.Id)
	bodyBytes := []byte(body.Encode())
	err := s.doRequest(ctx, requestConfig{Method: "POST", ProtoMethod: "LeaveContributor", BodyType: FORM_CAMEL, Body: bodyBytes, Path: hydratedPath}, &resp)
	if err != nil {
		return nil, err
	}
	return &resp, nil
}

func (s *RedditHttpPlugin) LeaveModerator(ctx context.Context, req *redditapi.BasicModerationIdRequest) (*emptypb.Empty, error) {
	resp := emptypb.Empty{}
	hydratedPath := `/api/leavemoderator?raw_json=1`
	body := url.Values{}
	body.Add("id", req.Id)
	bodyBytes := []byte(body.Encode())
	err := s.doRequest(ctx, requestConfig{Method: "POST", ProtoMethod: "LeaveModerator", BodyType: FORM_CAMEL, Body: bodyBytes, Path: hydratedPath}, &resp)
	if err != nil {
		return nil, err
	}
	return &resp, nil
}

func (s *RedditHttpPlugin) MuteMessageAuthor(ctx context.Context, req *redditapi.BasicModerationIdRequest) (*emptypb.Empty, error) {
	resp := emptypb.Empty{}
	hydratedPath := `/api/mute_message_author?raw_json=1`
	body := url.Values{}
	body.Add("id", req.Id)
	bodyBytes := []byte(body.Encode())
	err := s.doRequest(ctx, requestConfig{Method: "POST", ProtoMethod: "MuteMessageAuthor", BodyType: FORM_CAMEL, Body: bodyBytes, Path: hydratedPath}, &resp)
	if err != nil {
		return nil, err
	}
	return &resp, nil
}

func (s *RedditHttpPlugin) Remove(ctx context.Context, req *redditapi.RemoveRequest) (*emptypb.Empty, error) {
	resp := emptypb.Empty{}
	hydratedPath := `/api/remove?raw_json=1`
	contextValidationErr := s.validateContextId(ctx, req.Id)
	if contextValidationErr != nil {
		return nil, contextValidationErr
	}
	body := url.Values{}
	body.Add("id", req.Id)
	body.Add("spam", strconv.FormatBool(req.Spam))
	bodyBytes := []byte(body.Encode())
	err := s.doRequest(ctx, requestConfig{Method: "POST", ProtoMethod: "Remove", BodyType: FORM_CAMEL, Body: bodyBytes, Path: hydratedPath}, &resp)
	if err != nil {
		return nil, err
	}
	return &resp, nil
}

func (s *RedditHttpPlugin) ShowComment(ctx context.Context, req *redditapi.BasicModerationIdRequest) (*emptypb.Empty, error) {
	resp := emptypb.Empty{}
	hydratedPath := `/api/show_comment?raw_json=1`
	contextValidationErr := s.validateContextId(ctx, req.Id)
	if contextValidationErr != nil {
		return nil, contextValidationErr
	}
	body := url.Values{}
	body.Add("id", req.Id)
	bodyBytes := []byte(body.Encode())
	err := s.doRequest(ctx, requestConfig{Method: "POST", ProtoMethod: "ShowComment", BodyType: FORM_CAMEL, Body: bodyBytes, Path: hydratedPath}, &resp)
	if err != nil {
		return nil, err
	}
	return &resp, nil
}

func (s *RedditHttpPlugin) SnoozeReports(ctx context.Context, req *redditapi.SnoozeReportsRequest) (*emptypb.Empty, error) {
	resp := emptypb.Empty{}
	hydratedPath := `/api/snooze_reports?raw_json=1`
	contextValidationErr := s.validateContextId(ctx, req.Id)
	if contextValidationErr != nil {
		return nil, contextValidationErr
	}
	body := url.Values{}
	body.Add("id", req.Id)
	body.Add("reason", req.Reason)
	bodyBytes := []byte(body.Encode())
	err := s.doRequest(ctx, requestConfig{Method: "POST", ProtoMethod: "SnoozeReports", BodyType: FORM_CAMEL, Body: bodyBytes, Path: hydratedPath}, &resp)
	if err != nil {
		return nil, err
	}
	return &resp, nil
}

func (s *RedditHttpPlugin) UnignoreReports(ctx context.Context, req *redditapi.BasicModerationIdRequest) (*emptypb.Empty, error) {
	resp := emptypb.Empty{}
	hydratedPath := `/api/unignore_reports?raw_json=1`
	contextValidationErr := s.validateContextId(ctx, req.Id)
	if contextValidationErr != nil {
		return nil, contextValidationErr
	}
	body := url.Values{}
	body.Add("id", req.Id)
	bodyBytes := []byte(body.Encode())
	err := s.doRequest(ctx, requestConfig{Method: "POST", ProtoMethod: "UnignoreReports", BodyType: FORM_CAMEL, Body: bodyBytes, Path: hydratedPath}, &resp)
	if err != nil {
		return nil, err
	}
	return &resp, nil
}

func (s *RedditHttpPlugin) UnmuteMessageAuthor(ctx context.Context, req *redditapi.BasicModerationIdRequest) (*emptypb.Empty, error) {
	resp := emptypb.Empty{}
	hydratedPath := `/api/unmute_message_author?raw_json=1`
	body := url.Values{}
	body.Add("id", req.Id)
	bodyBytes := []byte(body.Encode())
	err := s.doRequest(ctx, requestConfig{Method: "POST", ProtoMethod: "UnmuteMessageAuthor", BodyType: FORM_CAMEL, Body: bodyBytes, Path: hydratedPath}, &resp)
	if err != nil {
		return nil, err
	}
	return &resp, nil
}

func (s *RedditHttpPlugin) UnsnoozeReports(ctx context.Context, req *redditapi.SnoozeReportsRequest) (*emptypb.Empty, error) {
	resp := emptypb.Empty{}
	hydratedPath := `/api/unsnooze_reports?raw_json=1`
	contextValidationErr := s.validateContextId(ctx, req.Id)
	if contextValidationErr != nil {
		return nil, contextValidationErr
	}
	body := url.Values{}
	body.Add("id", req.Id)
	body.Add("reason", req.Reason)
	bodyBytes := []byte(body.Encode())
	err := s.doRequest(ctx, requestConfig{Method: "POST", ProtoMethod: "UnsnoozeReports", BodyType: FORM_CAMEL, Body: bodyBytes, Path: hydratedPath}, &resp)
	if err != nil {
		return nil, err
	}
	return &resp, nil
}

func (s *RedditHttpPlugin) UpdateCrowdControlLevel(ctx context.Context, req *redditapi.UpdateCrowdControlLevelRequest) (*emptypb.Empty, error) {
	resp := emptypb.Empty{}
	hydratedPath := `/api/update_crowd_control_level?raw_json=1`
	contextValidationErr := s.validateContextId(ctx, req.Id)
	if contextValidationErr != nil {
		return nil, contextValidationErr
	}
	body := url.Values{}
	body.Add("id", req.Id)
	body.Add("level", strconv.Itoa(int(req.Level)))
	bodyBytes := []byte(body.Encode())
	err := s.doRequest(ctx, requestConfig{Method: "POST", ProtoMethod: "UpdateCrowdControlLevel", BodyType: FORM_CAMEL, Body: bodyBytes, Path: hydratedPath}, &resp)
	if err != nil {
		return nil, err
	}
	return &resp, nil
}

func (s *RedditHttpPlugin) Stylesheet(ctx context.Context, req *redditapi.StylesheetRequest) (*wrapperspb.StringValue, error) {
	hydratedPath := fmt.Sprintf(
		"/r/%v/stylesheet?raw_json=1",
		req.Subreddit)
	respBody, err := s.doRequestRaw(ctx, requestConfig{Method: "GET", ProtoMethod: "Stylesheet", Path: hydratedPath})
	if err != nil {
		return nil, err
	}
	resp, err := fixStylesheetResponse(respBody)
	if err != nil {
		l := dlog.WithIncomingContext(ctx)
		l.Errorf("Could not unmarshal JSON for path %s: %v", hydratedPath, err)
		l.Errorf("Body failure: %v", string(respBody))
		return nil, err
	}
	return resp, nil
}
