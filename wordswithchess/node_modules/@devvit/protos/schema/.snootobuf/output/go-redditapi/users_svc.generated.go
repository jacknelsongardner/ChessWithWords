// Code generated by protoc-gen-go-redditapi. DO NOT EDIT.

package reddithttpplugin

import (
	context "context"
	json "encoding/json"
	fmt "fmt"
	dlog "github.snooguts.net/reddit/reddit-devplatform-monorepo/go-common/dlog"
	redditapi "github.snooguts.net/reddit/reddit-devplatform-monorepo/go-common/generated/protos/types/devvit/plugin/redditapi"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
	wrapperspb "google.golang.org/protobuf/types/known/wrapperspb"
	url "net/url"
	strconv "strconv"
)

func (s *RedditHttpPlugin) BlockUser(ctx context.Context, req *redditapi.BlockUserRequest) (*redditapi.BlockUserResponse, error) {
	resp := redditapi.BlockUserResponse{}
	hydratedPath := `/api/block_user?raw_json=1`
	body := url.Values{}
	if req.AccountId.GetValue() != "" {
		body.Add("account_id", req.AccountId.GetValue())
	}
	body.Add("api_type", "json")
	if req.Name.GetValue() != "" {
		body.Add("name", req.Name.GetValue())
	}
	bodyBytes := []byte(body.Encode())
	err := s.doRequest(ctx, requestConfig{Method: "POST", ProtoMethod: "BlockUser", BodyType: FORM_SNAKE, Body: bodyBytes, Path: hydratedPath}, &resp)
	if err != nil {
		return nil, err
	}
	return &resp, nil
}

func (s *RedditHttpPlugin) Friend(ctx context.Context, req *redditapi.FriendRequest) (*redditapi.JsonStatus, error) {
	resp := redditapi.JsonStatus{}
	tmpSubredditValue := ""
	if req.Subreddit != nil {
		tmpSubredditValue = fmt.Sprintf("%v", req.Subreddit.Value)
	}
	hydratedPath := fmt.Sprintf(
		"/r/%v/api/friend?raw_json=1",
		tmpSubredditValue)
	body := url.Values{}
	body.Add("api_type", "json")
	if req.BanContext.GetValue() != "" {
		body.Add("ban_context", req.BanContext.GetValue())
	}
	if req.BanMessage.GetValue() != "" {
		body.Add("ban_message", req.BanMessage.GetValue())
	}
	if req.BanReason.GetValue() != "" {
		body.Add("ban_reason", req.BanReason.GetValue())
	}
	if req.Duration.GetValue() != 0 {
		body.Add("duration", strconv.Itoa(int(req.Duration.GetValue())))
	}
	body.Add("name", req.Name)
	if req.Note.GetValue() != "" {
		body.Add("note", req.Note.GetValue())
	}
	if req.Permissions.GetValue() != "" {
		body.Add("permissions", req.Permissions.GetValue())
	}
	if req.Subreddit.GetValue() != "" {
		body.Add("subreddit", req.Subreddit.GetValue())
	}
	body.Add("type", req.Type)
	bodyBytes := []byte(body.Encode())
	err := s.doRequest(ctx, requestConfig{Method: "POST", ProtoMethod: "Friend", BodyType: FORM_SNAKE, Body: bodyBytes, Path: hydratedPath}, &resp)
	if err != nil {
		return nil, err
	}
	return &resp, nil
}

func (s *RedditHttpPlugin) ReportUser(ctx context.Context, req *redditapi.ReportUserRequest) (*emptypb.Empty, error) {
	resp := emptypb.Empty{}
	hydratedPath := `/api/report_user?raw_json=1`
	body := url.Values{}
	body.Add("details", req.Details)
	body.Add("reason", req.Reason)
	body.Add("user", req.User)
	bodyBytes := []byte(body.Encode())
	err := s.doRequest(ctx, requestConfig{Method: "POST", ProtoMethod: "ReportUser", BodyType: FORM_SNAKE, Body: bodyBytes, Path: hydratedPath}, &resp)
	if err != nil {
		return nil, err
	}
	return &resp, nil
}

func (s *RedditHttpPlugin) SetPermissions(ctx context.Context, req *redditapi.SetPermissionsRequest) (*redditapi.JsonStatus, error) {
	resp := redditapi.JsonStatus{}
	hydratedPath := fmt.Sprintf(
		"/r/%v/api/setpermissions?raw_json=1",
		req.Subreddit)
	body := url.Values{}
	body.Add("api_type", "json")
	body.Add("name", req.Name)
	body.Add("permissions", req.Permissions)
	body.Add("subreddit", req.Subreddit)
	body.Add("type", req.Type)
	bodyBytes := []byte(body.Encode())
	err := s.doRequest(ctx, requestConfig{Method: "POST", ProtoMethod: "SetPermissions", BodyType: FORM_SNAKE, Body: bodyBytes, Path: hydratedPath}, &resp)
	if err != nil {
		return nil, err
	}
	return &resp, nil
}

func (s *RedditHttpPlugin) Unfriend(ctx context.Context, req *redditapi.UnfriendRequest) (*emptypb.Empty, error) {
	resp := emptypb.Empty{}
	tmpSubredditValue := ""
	if req.Subreddit != nil {
		tmpSubredditValue = fmt.Sprintf("%v", req.Subreddit.Value)
	}
	hydratedPath := fmt.Sprintf(
		"/r/%v/api/unfriend?raw_json=1",
		tmpSubredditValue)
	body := url.Values{}
	if req.Id.GetValue() != "" {
		body.Add("id", req.Id.GetValue())
	}
	if req.Name.GetValue() != "" {
		body.Add("name", req.Name.GetValue())
	}
	if req.Subreddit.GetValue() != "" {
		body.Add("subreddit", req.Subreddit.GetValue())
	}
	body.Add("type", req.Type)
	bodyBytes := []byte(body.Encode())
	err := s.doRequest(ctx, requestConfig{Method: "POST", ProtoMethod: "Unfriend", BodyType: FORM_SNAKE, Body: bodyBytes, Path: hydratedPath}, &resp)
	if err != nil {
		return nil, err
	}
	return &resp, nil
}

func (s *RedditHttpPlugin) UsernameAvailable(ctx context.Context, req *redditapi.UsernameAvailableRequest) (*wrapperspb.BoolValue, error) {
	hydratedPath := fmt.Sprintf(
		"/api/username_available?user=%v&raw_json=1",
		req.User)
	respBody, err := s.doRequestRaw(ctx, requestConfig{Method: "GET", ProtoMethod: "UsernameAvailable", Path: hydratedPath})
	if err != nil {
		return nil, err
	}
	resp, err := fixUsernameAvailableResponse(respBody)
	if err != nil {
		l := dlog.WithIncomingContext(ctx)
		l.Errorf("Could not unmarshal JSON for path %s: %v", hydratedPath, err)
		l.Errorf("Body failure: %v", string(respBody))
		return nil, err
	}
	return resp, nil
}

func (s *RedditHttpPlugin) UnfriendUser(ctx context.Context, req *redditapi.GenericUsersRequest) (*emptypb.Empty, error) {
	resp := emptypb.Empty{}
	tmpIdValue := ""
	if req.Id != nil {
		tmpIdValue = fmt.Sprintf("%v", req.Id.Value)
	}
	hydratedPath := fmt.Sprintf(
		"/api/v1/me/friends/%v?id=%v&raw_json=1",
		req.Username,
		tmpIdValue)
	err := s.doRequest(ctx, requestConfig{Method: "DELETE", ProtoMethod: "UnfriendUser", Path: hydratedPath}, &resp)
	if err != nil {
		return nil, err
	}
	return &resp, nil
}

func (s *RedditHttpPlugin) GetFriendInformation(ctx context.Context, req *redditapi.GenericUsersRequest) (*redditapi.GeneralFriendResponse, error) {
	resp := redditapi.GeneralFriendResponse{}
	tmpIdValue := ""
	if req.Id != nil {
		tmpIdValue = fmt.Sprintf("%v", req.Id.Value)
	}
	hydratedPath := fmt.Sprintf(
		"/api/v1/me/friends/%v?id=%v&raw_json=1",
		req.Username,
		tmpIdValue)
	err := s.doRequest(ctx, requestConfig{Method: "GET", ProtoMethod: "GetFriendInformation", Path: hydratedPath}, &resp)
	if err != nil {
		return nil, err
	}
	return &resp, nil
}

func (s *RedditHttpPlugin) UpdateFriendRelationship(ctx context.Context, req *redditapi.UpdateFriendRelationshipRequest) (*redditapi.GeneralFriendResponse, error) {
	resp := redditapi.GeneralFriendResponse{}
	hydratedPath := fmt.Sprintf(
		"/api/v1/me/friends/%v?raw_json=1",
		req.Name)
	body := make(map[string]interface{})
	body["name"] = req.Name
	body["note"] = req.Note
	bodyBytes, _ := json.Marshal(body)
	err := s.doRequest(ctx, requestConfig{Method: "PUT", ProtoMethod: "UpdateFriendRelationship", BodyType: JSON_CAMEL, Body: bodyBytes, Path: hydratedPath}, &resp)
	if err != nil {
		return nil, err
	}
	return &resp, nil
}

func (s *RedditHttpPlugin) UserTrophies(ctx context.Context, req *redditapi.GenericUsersRequest) (*redditapi.UserTrophiesResponse, error) {
	resp := redditapi.UserTrophiesResponse{}
	tmpIdValue := ""
	if req.Id != nil {
		tmpIdValue = fmt.Sprintf("%v", req.Id.Value)
	}
	hydratedPath := fmt.Sprintf(
		"/api/v1/user/%v/trophies?id=%v&raw_json=1",
		req.Username,
		tmpIdValue)
	err := s.doRequest(ctx, requestConfig{Method: "GET", ProtoMethod: "UserTrophies", Path: hydratedPath}, &resp)
	if err != nil {
		return nil, err
	}
	return &resp, nil
}

func (s *RedditHttpPlugin) UserAbout(ctx context.Context, req *redditapi.UserAboutRequest) (*redditapi.UserAboutResponse, error) {
	resp := redditapi.UserAboutResponse{}
	hydratedPath := fmt.Sprintf(
		"/user/%v/about?raw_json=1",
		req.Username)
	err := s.doRequest(ctx, requestConfig{Method: "GET", ProtoMethod: "UserAbout", Path: hydratedPath}, &resp)
	if err != nil {
		return nil, err
	}
	return &resp, nil
}

func (s *RedditHttpPlugin) UserWhere(ctx context.Context, req *redditapi.UserWhereRequest) (*redditapi.Listing, error) {
	resp := redditapi.Listing{}
	tmpUsernameValue := ""
	if req.Username != nil {
		tmpUsernameValue = fmt.Sprintf("%v", req.Username.Value)
	}
	tmpContextValue := ""
	if req.Context != nil {
		tmpContextValue = fmt.Sprintf("%v", req.Context.Value)
	}
	tmpShowValue := ""
	if req.Show != nil {
		tmpShowValue = fmt.Sprintf("%v", req.Show.Value)
	}
	tmpSortValue := ""
	if req.Sort != nil {
		tmpSortValue = fmt.Sprintf("%v", req.Sort.Value)
	}
	tmpTValue := ""
	if req.T != nil {
		tmpTValue = fmt.Sprintf("%v", req.T.Value)
	}
	tmpTypeValue := ""
	if req.Type != nil {
		tmpTypeValue = fmt.Sprintf("%v", req.Type.Value)
	}
	tmpAfterValue := ""
	if req.After != nil {
		tmpAfterValue = fmt.Sprintf("%v", req.After.Value)
	}
	tmpBeforeValue := ""
	if req.Before != nil {
		tmpBeforeValue = fmt.Sprintf("%v", req.Before.Value)
	}
	tmpCountValue := ""
	if req.Count != nil {
		tmpCountValue = fmt.Sprintf("%v", req.Count.Value)
	}
	tmpLimitValue := ""
	if req.Limit != nil {
		tmpLimitValue = fmt.Sprintf("%v", req.Limit.Value)
	}
	hydratedPath := fmt.Sprintf(
		"/user/%v/%v?context=%v&show=%v&sort=%v&t=%v&type=%v&after=%v&before=%v&count=%v&limit=%v&raw_json=1",
		tmpUsernameValue,
		req.Where,
		tmpContextValue,
		tmpShowValue,
		tmpSortValue,
		tmpTValue,
		tmpTypeValue,
		tmpAfterValue,
		tmpBeforeValue,
		tmpCountValue,
		tmpLimitValue)
	err := s.doRequest(ctx, requestConfig{Method: "GET", ProtoMethod: "UserWhere", Path: hydratedPath}, &resp)
	if err != nil {
		return nil, err
	}
	return &resp, nil
}
