// Code generated by protoc-gen-go-redditapi. DO NOT EDIT.

package reddithttpplugin

import (
	context "context"
	json "encoding/json"
	fmt "fmt"
	redditapi "github.snooguts.net/reddit/reddit-devplatform-monorepo/go-common/generated/protos/types/devvit/plugin/redditapi"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
	url "net/url"
)

func (s *RedditHttpPlugin) Block(ctx context.Context, req *redditapi.GenericPrivateMessagesRequest) (*emptypb.Empty, error) {
	resp := emptypb.Empty{}
	hydratedPath := `/api/block?raw_json=1`
	body := url.Values{}
	body.Add("id", req.Id)
	bodyBytes := []byte(body.Encode())
	err := s.doRequest(ctx, requestConfig{Method: "POST", ProtoMethod: "Block", BodyType: FORM_CAMEL, Body: bodyBytes, Path: hydratedPath}, &resp)
	if err != nil {
		return nil, err
	}
	return &resp, nil
}

func (s *RedditHttpPlugin) CollapseMessage(ctx context.Context, req *redditapi.GenericPrivateMessagesRequest) (*emptypb.Empty, error) {
	resp := emptypb.Empty{}
	hydratedPath := `/api/collapse_message.json?raw_json=1`
	body := make(map[string]interface{})
	body["id"] = req.Id
	bodyBytes, _ := json.Marshal(body)
	err := s.doRequest(ctx, requestConfig{Method: "POST", ProtoMethod: "CollapseMessage", BodyType: JSON_CAMEL, Body: bodyBytes, Path: hydratedPath}, &resp)
	if err != nil {
		return nil, err
	}
	return &resp, nil
}

func (s *RedditHttpPlugin) Compose(ctx context.Context, req *redditapi.ComposeRequest) (*emptypb.Empty, error) {
	resp := emptypb.Empty{}
	hydratedPath := `/api/compose?raw_json=1`
	body := url.Values{}
	body.Add("api_type", "json")
	body.Add("from_sr", req.FromSr)
	body.Add("subject", req.Subject)
	body.Add("text", req.Text)
	body.Add("to", req.To)
	bodyBytes := []byte(body.Encode())
	err := s.doRequest(ctx, requestConfig{Method: "POST", ProtoMethod: "Compose", BodyType: FORM_SNAKE, Body: bodyBytes, Path: hydratedPath}, &resp)
	if err != nil {
		return nil, err
	}
	return &resp, nil
}

func (s *RedditHttpPlugin) DelMsg(ctx context.Context, req *redditapi.GenericPrivateMessagesRequest) (*emptypb.Empty, error) {
	resp := emptypb.Empty{}
	hydratedPath := `/api/del_msg.json?raw_json=1`
	body := make(map[string]interface{})
	body["id"] = req.Id
	bodyBytes, _ := json.Marshal(body)
	err := s.doRequest(ctx, requestConfig{Method: "POST", ProtoMethod: "DelMsg", BodyType: JSON_CAMEL, Body: bodyBytes, Path: hydratedPath}, &resp)
	if err != nil {
		return nil, err
	}
	return &resp, nil
}

func (s *RedditHttpPlugin) ReadAllMessages(ctx context.Context, req *redditapi.ReadAllMessagesRequest) (*emptypb.Empty, error) {
	resp := emptypb.Empty{}
	hydratedPath := `/api/read_all_messages.json?raw_json=1`
	body := make(map[string]interface{})
	body["filterTypes"] = req.FilterTypes
	bodyBytes, _ := json.Marshal(body)
	err := s.doRequest(ctx, requestConfig{Method: "POST", ProtoMethod: "ReadAllMessages", BodyType: JSON_CAMEL, Body: bodyBytes, Path: hydratedPath}, &resp)
	if err != nil {
		return nil, err
	}
	return &resp, nil
}

func (s *RedditHttpPlugin) ReadMessage(ctx context.Context, req *redditapi.GenericPrivateMessagesRequest) (*emptypb.Empty, error) {
	resp := emptypb.Empty{}
	hydratedPath := `/api/read_message.json?raw_json=1`
	body := make(map[string]interface{})
	body["id"] = req.Id
	bodyBytes, _ := json.Marshal(body)
	err := s.doRequest(ctx, requestConfig{Method: "POST", ProtoMethod: "ReadMessage", BodyType: JSON_CAMEL, Body: bodyBytes, Path: hydratedPath}, &resp)
	if err != nil {
		return nil, err
	}
	return &resp, nil
}

func (s *RedditHttpPlugin) UnblockSubreddit(ctx context.Context, req *redditapi.GenericPrivateMessagesRequest) (*emptypb.Empty, error) {
	resp := emptypb.Empty{}
	hydratedPath := `/api/unblock_subreddit.json?raw_json=1`
	body := make(map[string]interface{})
	body["id"] = req.Id
	bodyBytes, _ := json.Marshal(body)
	err := s.doRequest(ctx, requestConfig{Method: "POST", ProtoMethod: "UnblockSubreddit", BodyType: JSON_CAMEL, Body: bodyBytes, Path: hydratedPath}, &resp)
	if err != nil {
		return nil, err
	}
	return &resp, nil
}

func (s *RedditHttpPlugin) UncollapseMessage(ctx context.Context, req *redditapi.GenericPrivateMessagesRequest) (*emptypb.Empty, error) {
	resp := emptypb.Empty{}
	hydratedPath := `/api/uncollapse_message.json?raw_json=1`
	body := make(map[string]interface{})
	body["id"] = req.Id
	bodyBytes, _ := json.Marshal(body)
	err := s.doRequest(ctx, requestConfig{Method: "POST", ProtoMethod: "UncollapseMessage", BodyType: JSON_CAMEL, Body: bodyBytes, Path: hydratedPath}, &resp)
	if err != nil {
		return nil, err
	}
	return &resp, nil
}

func (s *RedditHttpPlugin) UnreadMessage(ctx context.Context, req *redditapi.GenericPrivateMessagesRequest) (*emptypb.Empty, error) {
	resp := emptypb.Empty{}
	hydratedPath := `/api/unread_message.json?raw_json=1`
	body := make(map[string]interface{})
	body["id"] = req.Id
	bodyBytes, _ := json.Marshal(body)
	err := s.doRequest(ctx, requestConfig{Method: "POST", ProtoMethod: "UnreadMessage", BodyType: JSON_CAMEL, Body: bodyBytes, Path: hydratedPath}, &resp)
	if err != nil {
		return nil, err
	}
	return &resp, nil
}

func (s *RedditHttpPlugin) MessageWhere(ctx context.Context, req *redditapi.MessageWhereRequest) (*redditapi.Listing, error) {
	resp := redditapi.Listing{}
	tmpMarkValue := ""
	if req.Mark != nil {
		tmpMarkValue = fmt.Sprintf("%v", req.Mark.Value)
	}
	tmpMidValue := ""
	if req.Mid != nil {
		tmpMidValue = fmt.Sprintf("%v", req.Mid.Value)
	}
	tmpAfterValue := ""
	if req.After != nil {
		tmpAfterValue = fmt.Sprintf("%v", req.After.Value)
	}
	tmpBeforeValue := ""
	if req.Before != nil {
		tmpBeforeValue = fmt.Sprintf("%v", req.Before.Value)
	}
	tmpCountValue := ""
	if req.Count != nil {
		tmpCountValue = fmt.Sprintf("%v", req.Count.Value)
	}
	tmpLimitValue := ""
	if req.Limit != nil {
		tmpLimitValue = fmt.Sprintf("%v", req.Limit.Value)
	}
	tmpShowValue := ""
	if req.Show != nil {
		tmpShowValue = fmt.Sprintf("%v", req.Show.Value)
	}
	hydratedPath := fmt.Sprintf(
		"/message/%v.json?mark=%v&mid=%v&after=%v&before=%v&count=%v&limit=%v&show=%v&raw_json=1",
		req.Where,
		tmpMarkValue,
		tmpMidValue,
		tmpAfterValue,
		tmpBeforeValue,
		tmpCountValue,
		tmpLimitValue,
		tmpShowValue)
	err := s.doRequest(ctx, requestConfig{Method: "GET", ProtoMethod: "MessageWhere", Path: hydratedPath}, &resp)
	if err != nil {
		return nil, err
	}
	return &resp, nil
}
