syntax = "proto3";

package reddit.coreplatform.cloudroutines.workerpool.v1;

import "google/protobuf/any.proto";
import "google/protobuf/timestamp.proto";
import "google/rpc/status.proto";
import "reddit/coreplatform/cloudroutines/experimental/v1/experimental.proto";
import "reddit/coreplatform/cloudroutines/scheduling/v1/offsets.proto";
import "validate/validate.proto";

option go_package = "github.snooguts.net/reddit/cloudroutines/go/workerpoolpb/v1;workerpoolpb";

service WorkerPoolService {
  // RegisterWorkerPoolVersion handles the registration of new workers to a given pool.
  // Responses contain a mapping of callback names to corresponding error statuses encountered during registration.
  // Problematic callbacks will be omitted from registration and returned in the response errors map.
  rpc RegisterWorkerPoolVersion(RegisterWorkerPoolVersionRequest) returns (RegisterWorkerPoolVersionResponse) {
    option idempotency_level = IDEMPOTENT;
  }

  // ReplayCallbackWithWindow will trigger Cloudroutines to redeliver messages published within the specified time
  // window to the specified callback. If the time window falls outside of the topic retention window, then no messages will
  // be delivered and an error is returned.
  rpc ReplayCallbackWithWindow(ReplayCallbackWithWindowRequest) returns (ReplayCallbackWithWindowResponse) {
    option idempotency_level = IDEMPOTENT;
  }
}

message ReplayWindow {
  google.protobuf.Timestamp start = 1;
  google.protobuf.Timestamp end = 2;
}

message ReplayCallbackWithWindowRequest {
  string callback_namespace = 1 [(validate.rules).string = {
    pattern: "^[-a-zA-Z0-9]+$"
    min_len: 1
    max_len: 255
  }];
  string callback_name = 2 [(validate.rules).string = {
    pattern: "^[_a-zA-Z0-9]+$"
    min_len: 1
    max_len: 255
  }];

  ReplayWindow replay_window = 3;
}

message ReplayCallbackWithWindowResponse {
  reddit.coreplatform.cloudroutines.scheduling.v1.DataSourceOffsetRange window_offset_range = 1;
}

message RegisterWorkerPoolVersionRequest {
  // Reference to the worker pool that the worker is registering to.
  WorkerPool.Source worker_pool_source = 1;

  WorkerPool.Version worker_pool_version = 2;

  // Unique ID of the worker instance.
  // This must match the pod name of the caller.
  string worker_id = 3 [(validate.rules).string = {
    pattern: "^[-_.a-zA-Z0-9]+$"
    min_len: 1
    max_len: 255
  }];
}

message CallbackInfo {
  // The name of the callback
  string name = 1 [(validate.rules).string = {
    pattern: "^[_a-zA-Z0-9]+$"
    min_len: 1
    max_len: 255
  }];

  string request_full_name = 2;

  // The kafka topic that the callback wants to handle.
  // If empty, the kafka topic will default to the fullname of the message descriptor.
  string source_topic = 3 [(validate.rules).string = {
    ignore_empty: true
    pattern: "^[-_.a-zA-Z0-9]+$"
    max_len: 255
  }];

  // Configuration for experimental callback settings and features.
  // Not recommended for general usage.
  experimental.v1.ExperimentalCallbackOptions experimental_options = 4;

  // A list of extensions which influence the scheduling decisions and consumer behavior. This
  // field is meant to be populated only by the Cloudroutines scheduler. Attempts to configure this
  // outside of the scheduler should fail immediately.
  repeated google.protobuf.Any internal_scheduling_extensions = 5;
}

message RegisterWorkerPoolVersionResponse {
  // Mapping of callback names to error statuses encountered during registration.
  map<string, google.rpc.Status> errors = 1;
}

// Used internally within Cloudroutines to asynchronously update worker discovery information.
message WorkerPoolEvent {
  message RegisterVersion {
    WorkerPool.Source source = 1;
    WorkerPool.Version version = 2;

    // The unique identifier for the member of the worker pool which triggered this registration event. If blank,
    // this the event was triggered by internal automation or a state resync. This value is usually the pod name.
    string worker_id = 3;
  }

  message EvictVersion {
    WorkerPool.Source source = 1;
    WorkerPool.Version version = 2;
  }

  message EvictPool {
    WorkerPool.Source source = 1;
  }

  oneof event {
    RegisterVersion register_version = 1;
    EvictVersion evict_version = 2;
    EvictPool evict_pool = 3;
  }
}

message WorkerPool {
  message Source {
    oneof source {
      // Reference to the deployment that the worker pool is associated with.
      // Contains separate fields for the deployment name and namespace.
      DeploymentReference deployment_reference = 1;
    }
  }

  message Version {
    // The version of the worker pool. By default this is the pod template hash which we use as the
    // version identifier for a set of pods. When dynamic reloading is enabled, we have to use the
    // computed hash of the callback contents.
    string id = 1 [(validate.rules).string = {
      pattern: "^[-_.a-zA-Z0-9]+$"
      min_len: 1
      max_len: 255
    }];

    // The port that the workers are listening on.
    int32 port = 3 [(validate.rules).int32 = {
      gte: 1
      lte: 65535
    }];
    // The list of callbacks that the worker pool is able to handle.
    map<string, CallbackInfo> callbacks = 4 [(validate.rules).map = {min_pairs: 1}];

    google.protobuf.Any workload_extension = 5;

    // Optional version id of the deployment or workload this version struct is associated with. This field is
    // used when dynamic reloading of callbacks is configured.
    string workload_version_id = 6;
  }

  Source source = 1;

  map<string, Version> versions = 2;
}

message DeploymentReference {
  // The name of the deployment.
  string name = 1 [(validate.rules).string = {
    pattern: "^[-_.a-zA-Z0-9]+$"
    min_len: 1
    max_len: 255
  }];
  // The namespace of the deployment.
  string namespace = 2 [(validate.rules).string = {
    pattern: "^[-_.a-zA-Z0-9]+$"
    min_len: 1
    max_len: 255
  }];
}

message EinhornWorkloadExtension {
  message PortRange {
    int32 start = 1 [(validate.rules).int32 = {
      gte: 1
      lte: 65535
    }];
    int32 end = 2 [(validate.rules).int32 = {
      gte: 1
      lte: 65535
    }];
  }

  // The port range that the worker pool is listening on.
  PortRange port_range = 1;
}

message MonocerosWorkloadExtension {
  message PortRange {
    int32 start = 1 [(validate.rules).int32 = {
      gte: 1
      lte: 65535
    }];
    int32 end = 2 [(validate.rules).int32 = {
      gte: 1
      lte: 65535
    }];
  }

  // The port range that the worker pool is listening on.
  PortRange port_range = 1;
}
