syntax = "proto3";

package reddit.coreplatform.subreddit.v1;

import "google/protobuf/field_mask.proto";
import "google/rpc/status.proto";
import "reddit/coreplatform/subreddit/v1/subreddit.proto";
import "validate/validate.proto";

option go_package = "github.snooguts.net/reddit/thing-api/go/grpc/subreddit/v1;subreddit";
option java_multiple_files = true;
option java_outer_classname = "SubredditServiceProto";
option java_package = "com.reddit.coreplatform.api.subreddit.v1";

// RPC Service for working with core Subreddit data
service SubredditService {
  // Checks whether or not an account has access to view a subreddit
  rpc CanAccountViewSubreddit(CanAccountViewSubredditRequest) returns (CanAccountViewSubredditResponse) {
    option idempotency_level = NO_SIDE_EFFECTS;
  }
  // Checks accounts related to a subreddit, e.g. moderators, invited moderators, contributors, or banned
  rpc AccountRelationsForSubreddits(AccountRelationsForSubredditsRequest) returns (AccountRelationsForSubredditsResponse) {
    option idempotency_level = NO_SIDE_EFFECTS;
  }

  // Subscribes a given account to a given subreddit, asynchronous
  rpc SubscribeToSubreddit(SubscribeToSubredditRequest) returns (SubscribeToSubredditResponse) {
    option idempotency_level = IDEMPOTENT;
  }

  // Unsubscribes a given account from a given subreddit, asynchronous
  rpc UnsubscribeFromSubreddit(UnsubscribeFromSubredditRequest) returns (UnsubscribeFromSubredditResponse) {
    option idempotency_level = IDEMPOTENT;
  }

  // Get the list of accounts banned from this subreddit, with metadata
  rpc GetBannedUsersBySubreddit(GetBannedUsersBySubredditRequest) returns (GetBannedUsersBySubredditResponse) {
    option idempotency_level = NO_SIDE_EFFECTS;
  }

  // Get a count of subreddits each member in a list of users is banned from.
  // Restricted to admin and service actors
  rpc SubredditBanCountForAccountIDs(SubredditBanCountForAccountIDsRequest) returns (SubredditBanCountForAccountIDsResponse) {
    option idempotency_level = NO_SIDE_EFFECTS;
  }

  // Get a map of Account ID to active ban information for the specified Subreddit and Account IDs
  rpc GetBansForAccountIDsForSubreddit(GetBansForAccountIDsForSubredditRequest) returns (GetBansForAccountIDsForSubredditResponse) {
    option idempotency_level = NO_SIDE_EFFECTS;
  }

  // Retrieve AMA Settings for a given subreddit
  rpc GetAMASettings(GetAMASettingsRequest) returns (GetAMASettingsResponse) {
    option idempotency_level = NO_SIDE_EFFECTS;
  }

  // Update AMA Settings for a given subreddit
  rpc UpdateAMASettings(UpdateAMASettingsRequest) returns (UpdateAMASettingsResponse) {
    option idempotency_level = IDEMPOTENT;
  }
}

// Request arguments for subreddit access checks.
message CanAccountViewSubredditRequest {
  // The account id of the user we are checking visibility permissions against.
  // The id must be in a valid `t2_{}` thing id format.
  string account_id = 1 [(validate.rules).string = {
    pattern: "^t2_[a-zA-Z0-9]+$"
    ignore_empty: true
  }];

  // A list of subreddit ids to check if the supplied account id has permission to view
  // Each subreddit id must be in a valid `t5_{}` thing id format.
  repeated string subreddit_ids = 2 [(validate.rules).repeated = {
    min_items: 1
    max_items: 100
    items: {
      string: {pattern: "^t5_[a-zA-Z0-9]+$"}
    }
  }];
}

// Response payload for a subreddit visibility check.
message CanAccountViewSubredditResponse {
  // A list which is a subset of subreddits the requested account has permission to view.
  repeated string visible_subreddit_ids = 1;
}

// Request arguments for a subreddit account relations check.
message AccountRelationsForSubredditsRequest {
  // The account ID of the user we're checking account relations for.
  // The id must be in a valid `t2_{}` thing id format.
  string account_id = 1 [(validate.rules).string = {pattern: "^t2_[a-zA-Z0-9]+$"}];

  // An optional list of relation types to check against for the supplied account and subreddits.
  // Each relation type must be a valid SrRelationType enum value, excluding "UNKNOWN".
  repeated RelationType relation_types = 2 [(validate.rules).repeated = {
    min_items: 0
    max_items: 6
    items: {
      enum: {
        defined_only: true
        not_in: [0]
      }
    }
  }];

  // A list of subreddit ids to check relations against for the supplied account id.
  // Each subreddit id must be in a valid `t5_{}` thing id format.
  repeated string subreddit_ids = 3 [(validate.rules).repeated = {
    min_items: 1
    max_items: 1000
    items: {
      string: {pattern: "^t5_[a-zA-Z0-9]+$"}
    }
  }];
}

// Response payload for a subreddit account relations check.
message AccountRelationsForSubredditsResponse {
  // A map of subreddit IDs to relations that the user has with that subreddit.
  map<string, RelationTypeList> relations = 1;
}

// Request payload to subscribe to a subreddit
// The account must be able to view a subreddit in order to subscribe to it,
//  otherwise, a `FAILED_PRECONDITION` status is returned to the caller.
// If the account is already subscribed to the subreddit, an operation_id is returned in this response too.
message SubscribeToSubredditRequest {
  // The account ID of the user requesting to subscribe to the given subreddit.
  // The ID must be in a valid `t2_{}` thing ID format.
  string account_id = 1 [(validate.rules).string = {pattern: "^t2_[a-zA-Z0-9]+$"}];

  // The subreddit ID being subscribed to.
  // The ID must be in a valid `t5_{}` thing ID format.
  string subreddit_id = 2 [(validate.rules).string = {pattern: "^t5_[a-zA-Z0-9]+$"}];
}

// Response payload to subscribe to a subreddit
message SubscribeToSubredditResponse {
  // The operation ID, a unique identifier of the subscribe request that the client can use to track progress.
  // A valid UUID (via RFC 4122)
  string operation_id = 1 [(validate.rules).string.uuid = true];
}

// Request payload to unsubscribe to a subreddit
// The account must be able to view a subreddit in order to unsubscribe from it,
// otherwise, a `FAILED_PRECONDITION` status is returned to the caller.
// If the account is already unsubscribed from the subreddit, an operation_id is returned in this response too.
message UnsubscribeFromSubredditRequest {
  // The account ID of the user requesting to unsubscribe from the given subreddit.
  // The id must be in a valid `t2_{}` thing id format.
  string account_id = 1 [(validate.rules).string = {pattern: "^t2_[a-zA-Z0-9]+$"}];

  // The subreddit ID being unsubscribed from.
  // The ID must be in a valid `t5_{}` thing ID format.
  string subreddit_id = 2 [(validate.rules).string = {pattern: "^t5_[a-zA-Z0-9]+$"}];
}

// Response payload to unsubscribe to a subreddit
message UnsubscribeFromSubredditResponse {
  // The operation ID, a unique identifier of the unsubscribe request that the client can use to track progress.
  // A valid UUID (via RFC 4122)
  string operation_id = 1 [(validate.rules).string.uuid = true];
}

// Request the list of users that are banned from a given subreddit, with metadata
message GetBannedUsersBySubredditRequest {
  // Subreddit identifier to request list of banned users from.
  // Specified subreddit id should be a valid thing identifier with t5 prefix.
  string subreddit_id = 1 [(validate.rules).string = {pattern: "^t5_[a-zA-Z0-9]+$"}];

  // Cursor for the start index of the result set. When empty, the results start from the first page.
  // The sort order is descending, so the first page will be the most recently banned users.
  // This API may be updated to allow that sort order to be specified, but the default will remain as descending.
  string cursor = 2 [(validate.rules).string = {
    ignore_empty: true
    min_len: 1
  }];

  // Optional maximum page size limit (defaults to and capped at 1000).
  optional int32 limit = 3 [(validate.rules).int32 = {
    gte: 1
    lte: 1000
  }];
}

// The response message for querying users banned from a subreddit
message GetBannedUsersBySubredditResponse {
  // The list of users banned from the subreddit.
  repeated BannedUser banned_user = 1;

  // The cursor for the next page of results. If empty, then the end of the result set has been reached.
  string cursor = 2;
}

// Request payload specifying which account IDs to get ban counts for
message SubredditBanCountForAccountIDsRequest {
  // A list of up to 100 account IDs to get ban counts for.
  // Each account ID must be in a valid `t2_{}` thing ID format.
  // Note that this endpoint does not check for an account's existence before querying bans.
  repeated string account_ids = 1 [(validate.rules).repeated = {
    min_items: 1
    max_items: 100
    items: {
      string: {pattern: "^t2_[a-zA-Z0-9]+$"}
    }
  }];
}

// The response message for querying subreddit ban counts for account IDs
message SubredditBanCountForAccountIDsResponse {
  // A map of account IDs to the number of subreddits each user is banned from.
  // If an account ID shows a ban count of 0, that either means no ban relations were found
  // or the user does not exist.
  map<string, int32> ban_counts = 1;
}

// Request active ban information for the provided account IDs in the specified subreddit.
message GetBansForAccountIDsForSubredditRequest {
  // Subreddit ID to query account bans from.
  // Specified subreddit ID should be a valid thing identifier with a t5 prefix.
  string subreddit_id = 1 [(validate.rules).string = {pattern: "^t5_[a-zA-Z0-9]+$"}];

  // Account identifiers to request bans against.
  // Specified account IDs should be valid thing identifiers with a t2 prefix.
  // There should be between 1 and 100 account IDs specified.
  repeated string account_ids = 2 [(validate.rules).repeated = {
    min_items: 1
    max_items: 100
    items: {
      string: {pattern: "^t2_[a-zA-Z0-9]+$"}
    }
  }];
}

// A map of all requested account IDs with active ban information for the requested subreddit.
// A request with a non-existent subreddit ID will return an empty map.
message GetBansForAccountIDsForSubredditResponse {
  // Map of account ID to active ban information for the requested subreddit.
  // A missing account ID indicates the account does not exist or the account is not actively banned from the subreddit.
  map<string, BannedUser> bans_by_account_id = 1;
}

// Request to get AMA settings for a given subreddit
message GetAMASettingsRequest {
  // Subreddit Identifier
  repeated string subreddit_ids = 1 [(validate.rules).repeated = {
    min_items: 1
    max_items: 100
    items: {
      string: {pattern: "^t5_[a-zA-Z0-9]+$"}
    }
  }];
}

// Response of AMA settings for a given Subreddit
message GetAMASettingsResponse {
  // A map of the requested AMA Settings keyed by Subreddit ID.
  // Subreddit IDs present in this map will never be present in the errors_by_subreddit_id field.
  map<string, AMASettings> ama_settings_by_subreddit_id = 1;

  // A map of errors produced when looking up AMA Settings for given Subreddit IDs.
  // Subreddit IDs present in this map will never be present in the ama_settings_by_subreddit_id field.
  // The status can be set to NotFound, indicating that we do not have AMASettings set for the indicated subreddit
  map<string, google.rpc.Status> errors_by_subreddit_id = 2;
}

// Request to update AMA Settings for a given subreddit
message UpdateAMASettingsRequest {
  // Subreddit Identifier
  string subreddit_id = 1 [(validate.rules).string = {pattern: "^t5_[a-zA-Z0-9]+$"}];
  // AMA Settings to be updated for the given subreddit
  AMASettings ama_settings = 2;
  // The list of fields to be updated with the values found in ama_settings.
  // This is REQUIRED and an error will be returned if it is not set.
  // * is a special value that indicates that ALL fields are to be updated, setting them to their empty value if not set in ama_settings.
  google.protobuf.FieldMask update_mask = 3;
}

// Response from updating AMA settings for a subreddit
message UpdateAMASettingsResponse {}

// This message describes AMA settings for a Subreddit
message AMASettings {
  // List of permission settings describing which groups of users can create AMA posts on a subreddit
  // An empty list indicates that there are no Permissions for this subreddit, indicating that no one can make AMA posts
  repeated PostPermissions post_permissions = 1;

  // Enum describing which types of user can create AMA posts on a subreddit
  enum PostPermissions {
    // Default value, should not be used directly
    POST_PERMISSIONS_UNSPECIFIED = 0;
    // Logged-in users can create AMA posts
    POST_PERMISSIONS_USERS = 1;
    // Contributors can create AMA posts
    POST_PERMISSIONS_CONTRIBUTORS = 2;
    // Mods can create AMA posts
    POST_PERMISSIONS_MODS = 3;
  }
}
