syntax = "proto3";

package reddit.xpaymentsplatform.paypayments.v1;

import "google/protobuf/timestamp.proto";
import "reddit/xpaymentsplatform/paycommon/v1/order_status_reason.proto";
import "reddit/xpaymentsplatform/payproducts/v1/payproducts.proto";

option go_package = "github.snooguts.net/reddit/reddit-service-pay-payments/payments-api/api/xpaymentsplatform/paypaymentspb/v1;paypaymentspb";

message CreatePaymentEventRequest {
  reddit.xpaymentsplatform.payproducts.v1.Environment environment = 1;
  string order_id = 2;
  string buyer_id = 3;
  repeated PaymentUnit units = 4;
  ClientInfo client_info = 5;
}

message PaymentUnit {
  PaymentMode mode = 1;
  reddit.xpaymentsplatform.payproducts.v1.PaymentProvider provider = 2;
  string seller_id = 3;
  reddit.xpaymentsplatform.payproducts.v1.ProductPrice checkout_price = 4;
  reddit.xpaymentsplatform.payproducts.v1.Product product = 5;
}

message ClientInfo {
  string app_name = 1;
  string app_version = 2;
  string request_ip = 3;
  string country_code = 4;
  string subdivision_code = 5;
  string city_code = 6;
}

message CreatePaymentEventResponse {
  string order_id = 1;
  PaymentEventStatus status = 2;
  repeated PaymentUnitResponse units = 3;
}

message PaymentUnitResponse {
  PaymentMode mode = 1;
  reddit.xpaymentsplatform.payproducts.v1.PaymentProvider provider = 2;
  PaymentAction action = 3;
}

message PaymentAction {
  PaymentUnitStatus status = 1;
  string client_token = 2;
}

message CreatePaymentRefundRequest {
  string order_id = 1;
  RefundReason old_refund_reason = 2 [deprecated = true]; // replaced by field #5

  // One of the below fields must be present
  string initiator_user_id = 3; // The user who initiated the refund request, if present.
  string initiator_service_id = 4; // The service that initiated the refund request, if present.
  reddit.xpaymentsplatform.paycommon.v1.StatusReason reason = 5;
  bool synchronous = 10; // If true, the refund will be processed synchronously. If false, the refund will be processed asynchronously.
}

message CreatePaymentRefundResponse {}

message GetGoldBalancesRequest {
  reddit.xpaymentsplatform.payproducts.v1.Environment environment = 1;
  string user_id = 2;
  bool include_earned_gold = 3;
  bool include_earned_gold_devvit = 20;
  bool include_spendable_gold = 4;
  bool include_earned_gold_transactions = 5;
  bool include_earned_gold_devvit_transactions = 21;
  bool include_spendable_gold_transactions = 6;
}

message GetGoldBalancesResponse {
  GoldBalance earned_gold = 1;
  GoldBalance earned_gold_devvit = 20;
  GoldBalance spendable_gold = 2;
}

message GoldBalance {
  int32 available = 1;
  int32 total = 2;
  GoldTransactionsConnection transactions_connection = 3;
}

message GoldTransactionsConnection {
  repeated GoldTransaction transactions = 1;
  PageInfo page_info = 2;
}

message GoldTransaction {
  string transaction_id = 1; // order_id
  string product_id = 2; // Required to support atomic checkout. Not required to be populated at MVP
  reddit.xpaymentsplatform.payproducts.v1.ProductPrice checkout_price = 3;
  string from_user_id = 4; // If empty, user was removed from the system
  string to_user_id = 5; // If empty, user was removed from the system
  google.protobuf.Timestamp date = 6;
}

// Required to support pagination of GoldTransactions.
// Pagination will not be required at MVP.
message PageInfo {
  string start_cursor = 1; // if empty, start from the most recent transaction
  int32 page_size = 2;
  bool has_next_page = 3;
}

message AcknowledgeOrderDeliveryRequest {
  string order_id = 1;
  string package_name = 2;
  string product_id = 3;
  string purchase_token = 4;
  reddit.xpaymentsplatform.payproducts.v1.Environment environment = 5;
}

message AcknowledgeOrderDeliveryResponse {}

message AcknowledgeRecurringPaymentRequest {
  string order_id = 1;
  reddit.xpaymentsplatform.payproducts.v1.Environment environment = 2;
}

message AcknowledgeRecurringPaymentResponse {}

message ProcessPaymentNotificationRequest {
  reddit.xpaymentsplatform.payproducts.v1.Environment environment = 1;
  string order_id = 2;
  // Maps to payment_events.external_payment_id for one-time purchases and to recurring_payments.external_id for recurring payments
  string external_payment_id = 3;
  payproducts.v1.PaymentProvider payment_provider = 4;
  PaymentNotificationType notification_type = 5;
  payproducts.v1.ProductPrice price = 6; // The price paid by the buyer, it must be the localised price.
  google.protobuf.Timestamp notification_date = 7; // The date and time of the payment notification, as show inside the payment provider's system.
  string external_product_id = 8; // The product id for the payment
  RecurringPaymentState recurring_payment = 9;
  string external_payment_token = 10; // Provider-specific data required to manage payment
  // Leaving some space in case we find other mandatory fields to add

  string raw_notification = 50; // JSON string of the raw notification. Stored for debugging purposes.
  GoogleInAppPurchaseNotification google_in_app_purchase_notification = 51;
}

message RecurringPaymentState {
  google.protobuf.Timestamp starts_at = 1;
  google.protobuf.Timestamp trial_ends_at = 2;
  google.protobuf.Timestamp next_renewal_at = 3;
  google.protobuf.Timestamp grace_ends_at = 4;
  google.protobuf.Timestamp ends_at = 5;
  string renewal_payment_id = 6; // Maps to payment_events.external_payment_id for recurring payments
}

message GoogleInAppPurchaseNotification {
  string package_name = 1; // Android app's package name
  string purchase_token = 2; // unique identifier that can be used to acknowledge the android in-app purchase
}

message ProcessPaymentNotificationResponse {}

message GetUserProfilesRequest {
  repeated string user_ids = 1;
}

message UserProfileList {
  repeated UserProfile user_profiles = 1;
}

message UserProfile {
  reddit.xpaymentsplatform.payproducts.v1.Environment environment = 1;
  StripeProfile stripe_profile = 2;
}

message StripeProfile {
  string stripe_account_id = 1;
}

message GetUserProfilesResponse {
  map<string, UserProfileList> user_profiles = 1;
}

enum RefundReason {
  option deprecated = true; // Use pay-common's StatusReason instead
  REFUND_REASON_UNSPECIFIED = 0;

  REFUND_REASON_DUPLICATED = 1;
  REFUND_REASON_FRAUDULENT = 2;
  REFUND_REASON_CHARGEBACK = 3;
  REFUND_REASON_REQUESTED_BY_USER = 4;
  REFUND_REASON_REQUESTED_BY_REDDIT_ADMIN = 5;
  REFUND_REASON_REVERTED = 6;
}

// Indicates where the payment will be executed
enum PaymentMode {
  PAYMENT_MODE_UNSPECIFIED = 0;

  PAYMENT_MODE_CLIENT_SIDE = 1;
  PAYMENT_MODE_CLIENT_SIDE_REDIRECT = 2;
  PAYMENT_MODE_SERVER_SIDE = 3;
}

enum PaymentEventStatus {
  PAYMENT_EVENT_STATUS_UNSPECIFIED = 0;

  PAYMENT_EVENT_STATUS_NEW = 1;
  PAYMENT_EVENT_STATUS_SUCCEEDED = 2;
  PAYMENT_EVENT_STATUS_FAILED = 3;

  PAYMENT_EVENT_STATUS_REVERTED_CREATED = 4;
  PAYMENT_EVENT_STATUS_REVERTED_COMPLETED = 5;
  PAYMENT_EVENT_STATUS_REVERTED_FAILED = 6;

  PAYMENT_EVENT_STATUS_ACKNOWLEDGED = 7;
}

enum PaymentUnitStatus {
  PAYMENT_UNIT_STATUS_UNSPECIFIED = 0;

  PAYMENT_UNIT_STATUS_NEW = 1;
  PAYMENT_UNIT_STATUS_ACTION_REQUIRED = 2;
  PAYMENT_UNIT_STATUS_SUCCEEDED = 3;
  PAYMENT_UNIT_STATUS_FAILED = 4;

  PAYMENT_UNIT_STATUS_REVERTED_CREATED = 5;
  PAYMENT_UNIT_STATUS_REVERTED_COMPLETED = 6;
  PAYMENT_UNIT_STATUS_REVERTED_FAILED = 7;
}

enum PaymentNotificationType {
  PAYMENT_NOTIFICATION_TYPE_UNSPECIFIED = 0;

  PAYMENT_NOTIFICATION_TYPE_SUCCEEDED = 1;
  PAYMENT_NOTIFICATION_TYPE_FAILED = 2;
  PAYMENT_NOTIFICATION_TYPE_REFUNDED = 3;
  PAYMENT_NOTIFICATION_TYPE_DISPUTE = 4;
  PAYMENT_NOTIFICATION_TYPE_CANCELED = 5;
}

message CancelRecurringPaymentRequest {
  string order_id = 1;
  string buyer_id = 2;
  reddit.xpaymentsplatform.payproducts.v1.Environment environment = 3;
}

message CancelRecurringPaymentResponse {}

message ChangePaymentMethodRequest {
  string user_id = 1;
  string order_id = 2;
  payproducts.v1.Environment environment = 3;
  ClientInfo client_info = 4;
  optional string success_url = 5;
  optional string cancel_url = 6;
}

message ChangePaymentMethodResponse {
  payproducts.v1.PaymentProvider payment_provider = 1;
  string session_id = 2;
}

message TransferRecurringPaymentRequest {
  string order_id = 1;
  payproducts.v1.Environment environment = 2;
  string from_user_id = 3;
  string to_user_id = 4;
}

message TransferRecurringPaymentResponse {}

service PayPaymentsService {
  rpc AcknowledgeOrderDelivery(AcknowledgeOrderDeliveryRequest) returns (AcknowledgeOrderDeliveryResponse) {}

  rpc AcknowledgeRecurringPayment(AcknowledgeRecurringPaymentRequest) returns (AcknowledgeRecurringPaymentResponse) {}

  rpc CreatePaymentEvent(CreatePaymentEventRequest) returns (CreatePaymentEventResponse) {}

  rpc CreatePaymentRefund(CreatePaymentRefundRequest) returns (CreatePaymentRefundResponse) {}

  rpc GetGoldBalances(GetGoldBalancesRequest) returns (GetGoldBalancesResponse) {}

  rpc ProcessPaymentNotification(ProcessPaymentNotificationRequest) returns (ProcessPaymentNotificationResponse) {}

  rpc GetUserProfiles(GetUserProfilesRequest) returns (GetUserProfilesResponse) {}

  // CancelRecurringPayment cancels a recurring payment.
  rpc CancelRecurringPayment(CancelRecurringPaymentRequest) returns (CancelRecurringPaymentResponse) {}
  // ChangePaymentMethod changes the payment method for an order.
  rpc ChangePaymentMethod(ChangePaymentMethodRequest) returns (ChangePaymentMethodResponse) {}
  // TransferRecurringPayment transfers a recurring payment between users.
  rpc TransferRecurringPayment(TransferRecurringPaymentRequest) returns (TransferRecurringPaymentResponse) {}
}
