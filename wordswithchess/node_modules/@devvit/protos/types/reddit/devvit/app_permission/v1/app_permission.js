/**
 * #app_permission.ts
 *
 * Code generated by ts-proto. DO NOT EDIT.
 * @packageDocumentation
 */
/* eslint-disable */
import _m0 from "protobufjs/minimal.js";
import { Timestamp } from "../../../../google/protobuf/timestamp.js";
import { messageTypeRegistry } from "../../../../typeRegistry.js";
/** This enum is used to represent the consent status of an app permission. */
export var ConsentStatus;
(function (ConsentStatus) {
    /** CONSENT_STATUS_UNKNOWN - The consent status is unknown, which means it has not been set or is not applicable. */
    ConsentStatus[ConsentStatus["CONSENT_STATUS_UNKNOWN"] = 0] = "CONSENT_STATUS_UNKNOWN";
    /** REVOKED - The user has explicitly denied consent for the app permissions. */
    ConsentStatus[ConsentStatus["REVOKED"] = 1] = "REVOKED";
    /** GRANTED - The user has granted consent for the app permissions. */
    ConsentStatus[ConsentStatus["GRANTED"] = 2] = "GRANTED";
    ConsentStatus[ConsentStatus["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(ConsentStatus || (ConsentStatus = {}));
export function consentStatusFromJSON(object) {
    switch (object) {
        case 0:
        case "CONSENT_STATUS_UNKNOWN":
            return ConsentStatus.CONSENT_STATUS_UNKNOWN;
        case 1:
        case "REVOKED":
            return ConsentStatus.REVOKED;
        case 2:
        case "GRANTED":
            return ConsentStatus.GRANTED;
        case -1:
        case "UNRECOGNIZED":
        default:
            return ConsentStatus.UNRECOGNIZED;
    }
}
export function consentStatusToJSON(object) {
    switch (object) {
        case ConsentStatus.CONSENT_STATUS_UNKNOWN:
            return 0;
        case ConsentStatus.REVOKED:
            return 1;
        case ConsentStatus.GRANTED:
            return 2;
        case ConsentStatus.UNRECOGNIZED:
        default:
            return -1;
    }
}
/** This enum is used to represent the scopes of permissions that can be granted to an app. */
export var Scope;
(function (Scope) {
    /** SCOPE_UNKNOWN - The scope is unknown, which means it has not been set or is not applicable. */
    Scope[Scope["SCOPE_UNKNOWN"] = 0] = "SCOPE_UNKNOWN";
    /** SUBMIT_POST - Allows the app to submit posts on behalf of the user. */
    Scope[Scope["SUBMIT_POST"] = 1] = "SUBMIT_POST";
    /** SUBMIT_COMMENT - Allows the app to submit comments on behalf of the user. */
    Scope[Scope["SUBMIT_COMMENT"] = 2] = "SUBMIT_COMMENT";
    /** SUBSCRIBE_TO_SUBREDDIT - Allows the app to subscribe the user to a subreddit. */
    Scope[Scope["SUBSCRIBE_TO_SUBREDDIT"] = 3] = "SUBSCRIBE_TO_SUBREDDIT";
    Scope[Scope["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(Scope || (Scope = {}));
export function scopeFromJSON(object) {
    switch (object) {
        case 0:
        case "SCOPE_UNKNOWN":
            return Scope.SCOPE_UNKNOWN;
        case 1:
        case "SUBMIT_POST":
            return Scope.SUBMIT_POST;
        case 2:
        case "SUBMIT_COMMENT":
            return Scope.SUBMIT_COMMENT;
        case 3:
        case "SUBSCRIBE_TO_SUBREDDIT":
            return Scope.SUBSCRIBE_TO_SUBREDDIT;
        case -1:
        case "UNRECOGNIZED":
        default:
            return Scope.UNRECOGNIZED;
    }
}
export function scopeToJSON(object) {
    switch (object) {
        case Scope.SCOPE_UNKNOWN:
            return 0;
        case Scope.SUBMIT_POST:
            return 1;
        case Scope.SUBMIT_COMMENT:
            return 2;
        case Scope.SUBSCRIBE_TO_SUBREDDIT:
            return 3;
        case Scope.UNRECOGNIZED:
        default:
            return -1;
    }
}
function createBaseAppPermission() {
    return { appSlug: "", subredditId: "", scopes: [], consentStatus: 0, updatedAt: undefined };
}
export const AppPermission = {
    $type: "reddit.devvit.app_permission.v1.AppPermission",
    encode(message, writer = _m0.Writer.create()) {
        if (message.appSlug !== "") {
            writer.uint32(10).string(message.appSlug);
        }
        if (message.subredditId !== "") {
            writer.uint32(18).string(message.subredditId);
        }
        writer.uint32(26).fork();
        for (const v of message.scopes) {
            writer.int32(v);
        }
        writer.ldelim();
        if (message.consentStatus !== 0) {
            writer.uint32(32).int32(message.consentStatus);
        }
        if (message.updatedAt !== undefined) {
            Timestamp.encode(toTimestamp(message.updatedAt), writer.uint32(42).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAppPermission();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.appSlug = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.subredditId = reader.string();
                    continue;
                case 3:
                    if (tag === 24) {
                        message.scopes.push(reader.int32());
                        continue;
                    }
                    if (tag === 26) {
                        const end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2) {
                            message.scopes.push(reader.int32());
                        }
                        continue;
                    }
                    break;
                case 4:
                    if (tag !== 32) {
                        break;
                    }
                    message.consentStatus = reader.int32();
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.updatedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            appSlug: isSet(object.appSlug) ? globalThis.String(object.appSlug) : "",
            subredditId: isSet(object.subredditId) ? globalThis.String(object.subredditId) : "",
            scopes: globalThis.Array.isArray(object?.scopes) ? object.scopes.map((e) => scopeFromJSON(e)) : [],
            consentStatus: isSet(object.consentStatus) ? consentStatusFromJSON(object.consentStatus) : 0,
            updatedAt: isSet(object.updatedAt) ? fromJsonTimestamp(object.updatedAt) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.appSlug !== "") {
            obj.appSlug = message.appSlug;
        }
        if (message.subredditId !== "") {
            obj.subredditId = message.subredditId;
        }
        if (message.scopes?.length) {
            obj.scopes = message.scopes.map((e) => scopeToJSON(e));
        }
        if (message.consentStatus !== 0) {
            obj.consentStatus = consentStatusToJSON(message.consentStatus);
        }
        if (message.updatedAt !== undefined) {
            obj.updatedAt = message.updatedAt.toISOString();
        }
        return obj;
    },
    create(base) {
        return AppPermission.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseAppPermission();
        message.appSlug = object.appSlug ?? "";
        message.subredditId = object.subredditId ?? "";
        message.scopes = object.scopes?.map((e) => e) || [];
        message.consentStatus = object.consentStatus ?? 0;
        message.updatedAt = object.updatedAt ?? undefined;
        return message;
    },
};
messageTypeRegistry.set(AppPermission.$type, AppPermission);
function createBaseDevvitApp() {
    return { appSlug: "", appName: "" };
}
export const DevvitApp = {
    $type: "reddit.devvit.app_permission.v1.DevvitApp",
    encode(message, writer = _m0.Writer.create()) {
        if (message.appSlug !== "") {
            writer.uint32(10).string(message.appSlug);
        }
        if (message.appName !== "") {
            writer.uint32(18).string(message.appName);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseDevvitApp();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.appSlug = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.appName = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            appSlug: isSet(object.appSlug) ? globalThis.String(object.appSlug) : "",
            appName: isSet(object.appName) ? globalThis.String(object.appName) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.appSlug !== "") {
            obj.appSlug = message.appSlug;
        }
        if (message.appName !== "") {
            obj.appName = message.appName;
        }
        return obj;
    },
    create(base) {
        return DevvitApp.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseDevvitApp();
        message.appSlug = object.appSlug ?? "";
        message.appName = object.appName ?? "";
        return message;
    },
};
messageTypeRegistry.set(DevvitApp.$type, DevvitApp);
function createBaseGetAppPermissionsByUserIdRequest() {
    return { userId: "" };
}
export const GetAppPermissionsByUserIdRequest = {
    $type: "reddit.devvit.app_permission.v1.GetAppPermissionsByUserIdRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.userId !== "") {
            writer.uint32(10).string(message.userId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetAppPermissionsByUserIdRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.userId = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { userId: isSet(object.userId) ? globalThis.String(object.userId) : "" };
    },
    toJSON(message) {
        const obj = {};
        if (message.userId !== "") {
            obj.userId = message.userId;
        }
        return obj;
    },
    create(base) {
        return GetAppPermissionsByUserIdRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseGetAppPermissionsByUserIdRequest();
        message.userId = object.userId ?? "";
        return message;
    },
};
messageTypeRegistry.set(GetAppPermissionsByUserIdRequest.$type, GetAppPermissionsByUserIdRequest);
function createBaseGetAppPermissionsByUserIdResponse() {
    return { appPermissions: [], devvitApps: [] };
}
export const GetAppPermissionsByUserIdResponse = {
    $type: "reddit.devvit.app_permission.v1.GetAppPermissionsByUserIdResponse",
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.appPermissions) {
            AppPermission.encode(v, writer.uint32(10).fork()).ldelim();
        }
        for (const v of message.devvitApps) {
            DevvitApp.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetAppPermissionsByUserIdResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.appPermissions.push(AppPermission.decode(reader, reader.uint32()));
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.devvitApps.push(DevvitApp.decode(reader, reader.uint32()));
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            appPermissions: globalThis.Array.isArray(object?.appPermissions)
                ? object.appPermissions.map((e) => AppPermission.fromJSON(e))
                : [],
            devvitApps: globalThis.Array.isArray(object?.devvitApps)
                ? object.devvitApps.map((e) => DevvitApp.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.appPermissions?.length) {
            obj.appPermissions = message.appPermissions.map((e) => AppPermission.toJSON(e));
        }
        if (message.devvitApps?.length) {
            obj.devvitApps = message.devvitApps.map((e) => DevvitApp.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return GetAppPermissionsByUserIdResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseGetAppPermissionsByUserIdResponse();
        message.appPermissions = object.appPermissions?.map((e) => AppPermission.fromPartial(e)) || [];
        message.devvitApps = object.devvitApps?.map((e) => DevvitApp.fromPartial(e)) || [];
        return message;
    },
};
messageTypeRegistry.set(GetAppPermissionsByUserIdResponse.$type, GetAppPermissionsByUserIdResponse);
function createBaseGrantAppPermissionRequest() {
    return { userId: "", appSlug: "", subredditId: "", scopes: [] };
}
export const GrantAppPermissionRequest = {
    $type: "reddit.devvit.app_permission.v1.GrantAppPermissionRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.userId !== "") {
            writer.uint32(10).string(message.userId);
        }
        if (message.appSlug !== "") {
            writer.uint32(18).string(message.appSlug);
        }
        if (message.subredditId !== "") {
            writer.uint32(26).string(message.subredditId);
        }
        writer.uint32(34).fork();
        for (const v of message.scopes) {
            writer.int32(v);
        }
        writer.ldelim();
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGrantAppPermissionRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.userId = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.appSlug = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.subredditId = reader.string();
                    continue;
                case 4:
                    if (tag === 32) {
                        message.scopes.push(reader.int32());
                        continue;
                    }
                    if (tag === 34) {
                        const end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2) {
                            message.scopes.push(reader.int32());
                        }
                        continue;
                    }
                    break;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
            appSlug: isSet(object.appSlug) ? globalThis.String(object.appSlug) : "",
            subredditId: isSet(object.subredditId) ? globalThis.String(object.subredditId) : "",
            scopes: globalThis.Array.isArray(object?.scopes) ? object.scopes.map((e) => scopeFromJSON(e)) : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.userId !== "") {
            obj.userId = message.userId;
        }
        if (message.appSlug !== "") {
            obj.appSlug = message.appSlug;
        }
        if (message.subredditId !== "") {
            obj.subredditId = message.subredditId;
        }
        if (message.scopes?.length) {
            obj.scopes = message.scopes.map((e) => scopeToJSON(e));
        }
        return obj;
    },
    create(base) {
        return GrantAppPermissionRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseGrantAppPermissionRequest();
        message.userId = object.userId ?? "";
        message.appSlug = object.appSlug ?? "";
        message.subredditId = object.subredditId ?? "";
        message.scopes = object.scopes?.map((e) => e) || [];
        return message;
    },
};
messageTypeRegistry.set(GrantAppPermissionRequest.$type, GrantAppPermissionRequest);
function createBaseGrantAppPermissionResponse() {
    return { error: undefined };
}
export const GrantAppPermissionResponse = {
    $type: "reddit.devvit.app_permission.v1.GrantAppPermissionResponse",
    encode(message, writer = _m0.Writer.create()) {
        if (message.error !== undefined) {
            ErrorMessage.encode(message.error, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGrantAppPermissionResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.error = ErrorMessage.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { error: isSet(object.error) ? ErrorMessage.fromJSON(object.error) : undefined };
    },
    toJSON(message) {
        const obj = {};
        if (message.error !== undefined) {
            obj.error = ErrorMessage.toJSON(message.error);
        }
        return obj;
    },
    create(base) {
        return GrantAppPermissionResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseGrantAppPermissionResponse();
        message.error = (object.error !== undefined && object.error !== null)
            ? ErrorMessage.fromPartial(object.error)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set(GrantAppPermissionResponse.$type, GrantAppPermissionResponse);
function createBaseRevokeAppPermissionRequest() {
    return { appSlug: "", userId: "", subredditId: "" };
}
export const RevokeAppPermissionRequest = {
    $type: "reddit.devvit.app_permission.v1.RevokeAppPermissionRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.appSlug !== "") {
            writer.uint32(10).string(message.appSlug);
        }
        if (message.userId !== "") {
            writer.uint32(18).string(message.userId);
        }
        if (message.subredditId !== "") {
            writer.uint32(26).string(message.subredditId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRevokeAppPermissionRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.appSlug = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.userId = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.subredditId = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            appSlug: isSet(object.appSlug) ? globalThis.String(object.appSlug) : "",
            userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
            subredditId: isSet(object.subredditId) ? globalThis.String(object.subredditId) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.appSlug !== "") {
            obj.appSlug = message.appSlug;
        }
        if (message.userId !== "") {
            obj.userId = message.userId;
        }
        if (message.subredditId !== "") {
            obj.subredditId = message.subredditId;
        }
        return obj;
    },
    create(base) {
        return RevokeAppPermissionRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseRevokeAppPermissionRequest();
        message.appSlug = object.appSlug ?? "";
        message.userId = object.userId ?? "";
        message.subredditId = object.subredditId ?? "";
        return message;
    },
};
messageTypeRegistry.set(RevokeAppPermissionRequest.$type, RevokeAppPermissionRequest);
function createBaseRevokeAppPermissionResponse() {
    return { error: undefined };
}
export const RevokeAppPermissionResponse = {
    $type: "reddit.devvit.app_permission.v1.RevokeAppPermissionResponse",
    encode(message, writer = _m0.Writer.create()) {
        if (message.error !== undefined) {
            ErrorMessage.encode(message.error, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRevokeAppPermissionResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.error = ErrorMessage.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { error: isSet(object.error) ? ErrorMessage.fromJSON(object.error) : undefined };
    },
    toJSON(message) {
        const obj = {};
        if (message.error !== undefined) {
            obj.error = ErrorMessage.toJSON(message.error);
        }
        return obj;
    },
    create(base) {
        return RevokeAppPermissionResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseRevokeAppPermissionResponse();
        message.error = (object.error !== undefined && object.error !== null)
            ? ErrorMessage.fromPartial(object.error)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set(RevokeAppPermissionResponse.$type, RevokeAppPermissionResponse);
function createBaseErrorMessage() {
    return { message: "" };
}
export const ErrorMessage = {
    $type: "reddit.devvit.app_permission.v1.ErrorMessage",
    encode(message, writer = _m0.Writer.create()) {
        if (message.message !== "") {
            writer.uint32(10).string(message.message);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseErrorMessage();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.message = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { message: isSet(object.message) ? globalThis.String(object.message) : "" };
    },
    toJSON(message) {
        const obj = {};
        if (message.message !== "") {
            obj.message = message.message;
        }
        return obj;
    },
    create(base) {
        return ErrorMessage.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseErrorMessage();
        message.message = object.message ?? "";
        return message;
    },
};
messageTypeRegistry.set(ErrorMessage.$type, ErrorMessage);
function toTimestamp(date) {
    const seconds = Math.trunc(date.getTime() / 1000);
    const nanos = (date.getTime() % 1000) * 1000000;
    return { seconds, nanos };
}
function fromTimestamp(t) {
    let millis = (t.seconds || 0) * 1000;
    millis += (t.nanos || 0) / 1000000;
    return new globalThis.Date(millis);
}
function fromJsonTimestamp(o) {
    if (o instanceof globalThis.Date) {
        return o;
    }
    else if (typeof o === "string") {
        return new globalThis.Date(o);
    }
    else {
        return fromTimestamp(Timestamp.fromJSON(o));
    }
}
function isSet(value) {
    return value !== null && value !== undefined;
}
