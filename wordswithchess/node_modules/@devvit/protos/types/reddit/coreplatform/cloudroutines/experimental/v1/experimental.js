/**
 * #experimental.ts
 *
 * Code generated by ts-proto. DO NOT EDIT.
 * @packageDocumentation
 */
/* eslint-disable */
import Long from "long";
import _m0 from "protobufjs/minimal.js";
import { Duration } from "../../../../../google/protobuf/duration.js";
import { messageTypeRegistry } from "../../../../../typeRegistry.js";
function createBaseStrictMessageOrdering() {
    return {};
}
export const StrictMessageOrdering = {
    $type: "reddit.coreplatform.cloudroutines.experimental.v1.StrictMessageOrdering",
    encode(_, writer = _m0.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseStrictMessageOrdering();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    create(base) {
        return StrictMessageOrdering.fromPartial(base ?? {});
    },
    fromPartial(_) {
        const message = createBaseStrictMessageOrdering();
        return message;
    },
};
messageTypeRegistry.set(StrictMessageOrdering.$type, StrictMessageOrdering);
function createBaseLooseMessageOrdering() {
    return {};
}
export const LooseMessageOrdering = {
    $type: "reddit.coreplatform.cloudroutines.experimental.v1.LooseMessageOrdering",
    encode(_, writer = _m0.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseLooseMessageOrdering();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    create(base) {
        return LooseMessageOrdering.fromPartial(base ?? {});
    },
    fromPartial(_) {
        const message = createBaseLooseMessageOrdering();
        return message;
    },
};
messageTypeRegistry.set(LooseMessageOrdering.$type, LooseMessageOrdering);
function createBaseKeyMessageOrdering() {
    return {};
}
export const KeyMessageOrdering = {
    $type: "reddit.coreplatform.cloudroutines.experimental.v1.KeyMessageOrdering",
    encode(_, writer = _m0.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseKeyMessageOrdering();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    create(base) {
        return KeyMessageOrdering.fromPartial(base ?? {});
    },
    fromPartial(_) {
        const message = createBaseKeyMessageOrdering();
        return message;
    },
};
messageTypeRegistry.set(KeyMessageOrdering.$type, KeyMessageOrdering);
function createBaseAlertConfig() {
    return { sdkVersion: "", consumerLagAlertConfig: undefined };
}
export const AlertConfig = {
    $type: "reddit.coreplatform.cloudroutines.experimental.v1.AlertConfig",
    encode(message, writer = _m0.Writer.create()) {
        if (message.sdkVersion !== "") {
            writer.uint32(10).string(message.sdkVersion);
        }
        if (message.consumerLagAlertConfig !== undefined) {
            ConsumerLagAlertConfig.encode(message.consumerLagAlertConfig, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAlertConfig();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.sdkVersion = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.consumerLagAlertConfig = ConsumerLagAlertConfig.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            sdkVersion: isSet(object.sdkVersion) ? globalThis.String(object.sdkVersion) : "",
            consumerLagAlertConfig: isSet(object.consumerLagAlertConfig)
                ? ConsumerLagAlertConfig.fromJSON(object.consumerLagAlertConfig)
                : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.sdkVersion !== "") {
            obj.sdkVersion = message.sdkVersion;
        }
        if (message.consumerLagAlertConfig !== undefined) {
            obj.consumerLagAlertConfig = ConsumerLagAlertConfig.toJSON(message.consumerLagAlertConfig);
        }
        return obj;
    },
    create(base) {
        return AlertConfig.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseAlertConfig();
        message.sdkVersion = object.sdkVersion ?? "";
        message.consumerLagAlertConfig =
            (object.consumerLagAlertConfig !== undefined && object.consumerLagAlertConfig !== null)
                ? ConsumerLagAlertConfig.fromPartial(object.consumerLagAlertConfig)
                : undefined;
        return message;
    },
};
messageTypeRegistry.set(AlertConfig.$type, AlertConfig);
function createBaseConsumerLagAlertConfig() {
    return { disabled: false, threshold: 0, thresholdDuration: undefined, componentName: "" };
}
export const ConsumerLagAlertConfig = {
    $type: "reddit.coreplatform.cloudroutines.experimental.v1.ConsumerLagAlertConfig",
    encode(message, writer = _m0.Writer.create()) {
        if (message.disabled !== false) {
            writer.uint32(8).bool(message.disabled);
        }
        if (message.threshold !== 0) {
            writer.uint32(16).int64(message.threshold);
        }
        if (message.thresholdDuration !== undefined) {
            Duration.encode(message.thresholdDuration, writer.uint32(26).fork()).ldelim();
        }
        if (message.componentName !== "") {
            writer.uint32(34).string(message.componentName);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseConsumerLagAlertConfig();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.disabled = reader.bool();
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.threshold = longToNumber(reader.int64());
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.thresholdDuration = Duration.decode(reader, reader.uint32());
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.componentName = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            disabled: isSet(object.disabled) ? globalThis.Boolean(object.disabled) : false,
            threshold: isSet(object.threshold) ? globalThis.Number(object.threshold) : 0,
            thresholdDuration: isSet(object.thresholdDuration) ? Duration.fromJSON(object.thresholdDuration) : undefined,
            componentName: isSet(object.componentName) ? globalThis.String(object.componentName) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.disabled !== false) {
            obj.disabled = message.disabled;
        }
        if (message.threshold !== 0) {
            obj.threshold = Math.round(message.threshold);
        }
        if (message.thresholdDuration !== undefined) {
            obj.thresholdDuration = Duration.toJSON(message.thresholdDuration);
        }
        if (message.componentName !== "") {
            obj.componentName = message.componentName;
        }
        return obj;
    },
    create(base) {
        return ConsumerLagAlertConfig.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseConsumerLagAlertConfig();
        message.disabled = object.disabled ?? false;
        message.threshold = object.threshold ?? 0;
        message.thresholdDuration = (object.thresholdDuration !== undefined && object.thresholdDuration !== null)
            ? Duration.fromPartial(object.thresholdDuration)
            : undefined;
        message.componentName = object.componentName ?? "";
        return message;
    },
};
messageTypeRegistry.set(ConsumerLagAlertConfig.$type, ConsumerLagAlertConfig);
function createBaseExperimentalCallbackOptions() {
    return {
        strictOrdering: undefined,
        looseOrdering: undefined,
        keyOrdering: undefined,
        alertConfig: undefined,
        dataSourceUri: undefined,
    };
}
export const ExperimentalCallbackOptions = {
    $type: "reddit.coreplatform.cloudroutines.experimental.v1.ExperimentalCallbackOptions",
    encode(message, writer = _m0.Writer.create()) {
        if (message.strictOrdering !== undefined) {
            StrictMessageOrdering.encode(message.strictOrdering, writer.uint32(10).fork()).ldelim();
        }
        if (message.looseOrdering !== undefined) {
            LooseMessageOrdering.encode(message.looseOrdering, writer.uint32(18).fork()).ldelim();
        }
        if (message.keyOrdering !== undefined) {
            KeyMessageOrdering.encode(message.keyOrdering, writer.uint32(26).fork()).ldelim();
        }
        if (message.alertConfig !== undefined) {
            AlertConfig.encode(message.alertConfig, writer.uint32(34).fork()).ldelim();
        }
        if (message.dataSourceUri !== undefined) {
            writer.uint32(42).string(message.dataSourceUri);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseExperimentalCallbackOptions();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.strictOrdering = StrictMessageOrdering.decode(reader, reader.uint32());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.looseOrdering = LooseMessageOrdering.decode(reader, reader.uint32());
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.keyOrdering = KeyMessageOrdering.decode(reader, reader.uint32());
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.alertConfig = AlertConfig.decode(reader, reader.uint32());
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.dataSourceUri = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            strictOrdering: isSet(object.strictOrdering) ? StrictMessageOrdering.fromJSON(object.strictOrdering) : undefined,
            looseOrdering: isSet(object.looseOrdering) ? LooseMessageOrdering.fromJSON(object.looseOrdering) : undefined,
            keyOrdering: isSet(object.keyOrdering) ? KeyMessageOrdering.fromJSON(object.keyOrdering) : undefined,
            alertConfig: isSet(object.alertConfig) ? AlertConfig.fromJSON(object.alertConfig) : undefined,
            dataSourceUri: isSet(object.dataSourceUri) ? globalThis.String(object.dataSourceUri) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.strictOrdering !== undefined) {
            obj.strictOrdering = StrictMessageOrdering.toJSON(message.strictOrdering);
        }
        if (message.looseOrdering !== undefined) {
            obj.looseOrdering = LooseMessageOrdering.toJSON(message.looseOrdering);
        }
        if (message.keyOrdering !== undefined) {
            obj.keyOrdering = KeyMessageOrdering.toJSON(message.keyOrdering);
        }
        if (message.alertConfig !== undefined) {
            obj.alertConfig = AlertConfig.toJSON(message.alertConfig);
        }
        if (message.dataSourceUri !== undefined) {
            obj.dataSourceUri = message.dataSourceUri;
        }
        return obj;
    },
    create(base) {
        return ExperimentalCallbackOptions.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseExperimentalCallbackOptions();
        message.strictOrdering = (object.strictOrdering !== undefined && object.strictOrdering !== null)
            ? StrictMessageOrdering.fromPartial(object.strictOrdering)
            : undefined;
        message.looseOrdering = (object.looseOrdering !== undefined && object.looseOrdering !== null)
            ? LooseMessageOrdering.fromPartial(object.looseOrdering)
            : undefined;
        message.keyOrdering = (object.keyOrdering !== undefined && object.keyOrdering !== null)
            ? KeyMessageOrdering.fromPartial(object.keyOrdering)
            : undefined;
        message.alertConfig = (object.alertConfig !== undefined && object.alertConfig !== null)
            ? AlertConfig.fromPartial(object.alertConfig)
            : undefined;
        message.dataSourceUri = object.dataSourceUri ?? undefined;
        return message;
    },
};
messageTypeRegistry.set(ExperimentalCallbackOptions.$type, ExperimentalCallbackOptions);
function longToNumber(long) {
    if (long.gt(globalThis.Number.MAX_SAFE_INTEGER)) {
        throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
    }
    return long.toNumber();
}
if (_m0.util.Long !== Long) {
    _m0.util.Long = Long;
    _m0.configure();
}
function isSet(value) {
    return value !== null && value !== undefined;
}
