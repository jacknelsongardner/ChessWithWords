/**
 * #experimental.ts
 *
 * Code generated by ts-proto. DO NOT EDIT.
 * @packageDocumentation
 */
import _m0 from "protobufjs/minimal.js";
import { Duration } from "../../../../../google/protobuf/duration.js";
/**
 * Ensures that messages are processed in the strict order they are received.
 * This guarantees the sequence of message execution but may reduce throughput.
 * This is the default ordering if not specified, so it is not necessary to set this explicitly.
 *
 * *Note: If you're using the Python SDK, then KeyMessageOrdering is the default ordering.
 */
export interface StrictMessageOrdering {
}
/**
 * Enables out-of-order message execution.
 * Messages are batched and processed concurrently, increasing throughput but not guaranteeing order of receipt.
 */
export interface LooseMessageOrdering {
}
/**
 * Messages are processed concurrently, similar to LooseMessageOrdering, improving throughput.
 * However, messages with the same Kafka partitioning key will be processed in the order they arrive in.
 * This allows for controlled parallel processing with guarantees on order based on specific keys.
 *
 * *Note: This is the default ordering if not specified when using the Python SDK.
 */
export interface KeyMessageOrdering {
}
/** Wrapper struct for all client alert configurations. */
export interface AlertConfig {
    sdkVersion: string;
    consumerLagAlertConfig?: ConsumerLagAlertConfig | undefined;
}
/**
 * Alert configuration for consumer lag. If the entire struct is left blank, the stated defaults are applied; otherwise, all fields must be set.
 * Currently, this is based off of Burrow's consumer lag metric.
 */
export interface ConsumerLagAlertConfig {
    /**
     * Whether or not the alert is disabled.
     * Defaults to false.
     */
    disabled: boolean;
    /**
     * The number of messages the consumer group needs to lag by for the alert to fire.
     * Defaults to 25000.
     */
    threshold: number;
    /**
     * How long the alert threshold must be sustained for the alert to fire.
     * Defaults to 5 minutes. Maximum of 30 minutes.
     */
    thresholdDuration?: Duration | undefined;
    /**
     * Infrared v2 reddit-component name to route the alert to (see https://atlas.snooguts.net/catalog/default/component).
     * Defaults to an empty value, which will route the alert based on the client namespace.
     */
    componentName: string;
}
export interface ExperimentalCallbackOptions {
    strictOrdering?: StrictMessageOrdering | undefined;
    looseOrdering?: LooseMessageOrdering | undefined;
    keyOrdering?: KeyMessageOrdering | undefined;
    /** Wrapper type containing configuration for all client alerts. */
    alertConfig?: AlertConfig | undefined;
    /** URI representing an arbitrary data source to consume messages from. */
    dataSourceUri?: string | undefined;
}
export declare const StrictMessageOrdering: {
    $type: "reddit.coreplatform.cloudroutines.experimental.v1.StrictMessageOrdering";
    encode(_: StrictMessageOrdering, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): StrictMessageOrdering;
    fromJSON(_: any): StrictMessageOrdering;
    toJSON(_: StrictMessageOrdering): unknown;
    create(base?: DeepPartial<StrictMessageOrdering>): StrictMessageOrdering;
    fromPartial(_: DeepPartial<StrictMessageOrdering>): StrictMessageOrdering;
};
export declare const LooseMessageOrdering: {
    $type: "reddit.coreplatform.cloudroutines.experimental.v1.LooseMessageOrdering";
    encode(_: LooseMessageOrdering, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): LooseMessageOrdering;
    fromJSON(_: any): LooseMessageOrdering;
    toJSON(_: LooseMessageOrdering): unknown;
    create(base?: DeepPartial<LooseMessageOrdering>): LooseMessageOrdering;
    fromPartial(_: DeepPartial<LooseMessageOrdering>): LooseMessageOrdering;
};
export declare const KeyMessageOrdering: {
    $type: "reddit.coreplatform.cloudroutines.experimental.v1.KeyMessageOrdering";
    encode(_: KeyMessageOrdering, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): KeyMessageOrdering;
    fromJSON(_: any): KeyMessageOrdering;
    toJSON(_: KeyMessageOrdering): unknown;
    create(base?: DeepPartial<KeyMessageOrdering>): KeyMessageOrdering;
    fromPartial(_: DeepPartial<KeyMessageOrdering>): KeyMessageOrdering;
};
export declare const AlertConfig: {
    $type: "reddit.coreplatform.cloudroutines.experimental.v1.AlertConfig";
    encode(message: AlertConfig, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): AlertConfig;
    fromJSON(object: any): AlertConfig;
    toJSON(message: AlertConfig): unknown;
    create(base?: DeepPartial<AlertConfig>): AlertConfig;
    fromPartial(object: DeepPartial<AlertConfig>): AlertConfig;
};
export declare const ConsumerLagAlertConfig: {
    $type: "reddit.coreplatform.cloudroutines.experimental.v1.ConsumerLagAlertConfig";
    encode(message: ConsumerLagAlertConfig, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ConsumerLagAlertConfig;
    fromJSON(object: any): ConsumerLagAlertConfig;
    toJSON(message: ConsumerLagAlertConfig): unknown;
    create(base?: DeepPartial<ConsumerLagAlertConfig>): ConsumerLagAlertConfig;
    fromPartial(object: DeepPartial<ConsumerLagAlertConfig>): ConsumerLagAlertConfig;
};
export declare const ExperimentalCallbackOptions: {
    $type: "reddit.coreplatform.cloudroutines.experimental.v1.ExperimentalCallbackOptions";
    encode(message: ExperimentalCallbackOptions, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ExperimentalCallbackOptions;
    fromJSON(object: any): ExperimentalCallbackOptions;
    toJSON(message: ExperimentalCallbackOptions): unknown;
    create(base?: DeepPartial<ExperimentalCallbackOptions>): ExperimentalCallbackOptions;
    fromPartial(object: DeepPartial<ExperimentalCallbackOptions>): ExperimentalCallbackOptions;
};
type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;
type DeepPartial<T> = T extends Builtin ? T : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial<T[K]>;
} : Partial<T>;
export {};
//# sourceMappingURL=experimental.d.ts.map