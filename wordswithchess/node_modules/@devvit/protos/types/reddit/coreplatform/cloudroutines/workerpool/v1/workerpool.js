/**
 * #workerpool.ts
 *
 * Code generated by ts-proto. DO NOT EDIT.
 * @packageDocumentation
 */
/* eslint-disable */
import _m0 from "protobufjs/minimal.js";
import { Any } from "../../../../../google/protobuf/any.js";
import { Timestamp } from "../../../../../google/protobuf/timestamp.js";
import { Status } from "../../../../../google/rpc/status.js";
import { messageTypeRegistry } from "../../../../../typeRegistry.js";
import { ExperimentalCallbackOptions } from "../../experimental/v1/experimental.js";
import { DataSourceOffsetRange } from "../../scheduling/v1/offsets.js";
function createBaseReplayWindow() {
    return { start: undefined, end: undefined };
}
export const ReplayWindow = {
    $type: "reddit.coreplatform.cloudroutines.workerpool.v1.ReplayWindow",
    encode(message, writer = _m0.Writer.create()) {
        if (message.start !== undefined) {
            Timestamp.encode(toTimestamp(message.start), writer.uint32(10).fork()).ldelim();
        }
        if (message.end !== undefined) {
            Timestamp.encode(toTimestamp(message.end), writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseReplayWindow();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.start = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.end = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            start: isSet(object.start) ? fromJsonTimestamp(object.start) : undefined,
            end: isSet(object.end) ? fromJsonTimestamp(object.end) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.start !== undefined) {
            obj.start = message.start.toISOString();
        }
        if (message.end !== undefined) {
            obj.end = message.end.toISOString();
        }
        return obj;
    },
    create(base) {
        return ReplayWindow.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseReplayWindow();
        message.start = object.start ?? undefined;
        message.end = object.end ?? undefined;
        return message;
    },
};
messageTypeRegistry.set(ReplayWindow.$type, ReplayWindow);
function createBaseReplayCallbackWithWindowRequest() {
    return { callbackNamespace: "", callbackName: "", replayWindow: undefined };
}
export const ReplayCallbackWithWindowRequest = {
    $type: "reddit.coreplatform.cloudroutines.workerpool.v1.ReplayCallbackWithWindowRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.callbackNamespace !== "") {
            writer.uint32(10).string(message.callbackNamespace);
        }
        if (message.callbackName !== "") {
            writer.uint32(18).string(message.callbackName);
        }
        if (message.replayWindow !== undefined) {
            ReplayWindow.encode(message.replayWindow, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseReplayCallbackWithWindowRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.callbackNamespace = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.callbackName = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.replayWindow = ReplayWindow.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            callbackNamespace: isSet(object.callbackNamespace) ? globalThis.String(object.callbackNamespace) : "",
            callbackName: isSet(object.callbackName) ? globalThis.String(object.callbackName) : "",
            replayWindow: isSet(object.replayWindow) ? ReplayWindow.fromJSON(object.replayWindow) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.callbackNamespace !== "") {
            obj.callbackNamespace = message.callbackNamespace;
        }
        if (message.callbackName !== "") {
            obj.callbackName = message.callbackName;
        }
        if (message.replayWindow !== undefined) {
            obj.replayWindow = ReplayWindow.toJSON(message.replayWindow);
        }
        return obj;
    },
    create(base) {
        return ReplayCallbackWithWindowRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseReplayCallbackWithWindowRequest();
        message.callbackNamespace = object.callbackNamespace ?? "";
        message.callbackName = object.callbackName ?? "";
        message.replayWindow = (object.replayWindow !== undefined && object.replayWindow !== null)
            ? ReplayWindow.fromPartial(object.replayWindow)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set(ReplayCallbackWithWindowRequest.$type, ReplayCallbackWithWindowRequest);
function createBaseReplayCallbackWithWindowResponse() {
    return { windowOffsetRange: undefined };
}
export const ReplayCallbackWithWindowResponse = {
    $type: "reddit.coreplatform.cloudroutines.workerpool.v1.ReplayCallbackWithWindowResponse",
    encode(message, writer = _m0.Writer.create()) {
        if (message.windowOffsetRange !== undefined) {
            DataSourceOffsetRange.encode(message.windowOffsetRange, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseReplayCallbackWithWindowResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.windowOffsetRange = DataSourceOffsetRange.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            windowOffsetRange: isSet(object.windowOffsetRange)
                ? DataSourceOffsetRange.fromJSON(object.windowOffsetRange)
                : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.windowOffsetRange !== undefined) {
            obj.windowOffsetRange = DataSourceOffsetRange.toJSON(message.windowOffsetRange);
        }
        return obj;
    },
    create(base) {
        return ReplayCallbackWithWindowResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseReplayCallbackWithWindowResponse();
        message.windowOffsetRange = (object.windowOffsetRange !== undefined && object.windowOffsetRange !== null)
            ? DataSourceOffsetRange.fromPartial(object.windowOffsetRange)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set(ReplayCallbackWithWindowResponse.$type, ReplayCallbackWithWindowResponse);
function createBaseRegisterWorkerPoolVersionRequest() {
    return { workerPoolSource: undefined, workerPoolVersion: undefined, workerId: "" };
}
export const RegisterWorkerPoolVersionRequest = {
    $type: "reddit.coreplatform.cloudroutines.workerpool.v1.RegisterWorkerPoolVersionRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.workerPoolSource !== undefined) {
            WorkerPool_Source.encode(message.workerPoolSource, writer.uint32(10).fork()).ldelim();
        }
        if (message.workerPoolVersion !== undefined) {
            WorkerPool_Version.encode(message.workerPoolVersion, writer.uint32(18).fork()).ldelim();
        }
        if (message.workerId !== "") {
            writer.uint32(26).string(message.workerId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRegisterWorkerPoolVersionRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.workerPoolSource = WorkerPool_Source.decode(reader, reader.uint32());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.workerPoolVersion = WorkerPool_Version.decode(reader, reader.uint32());
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.workerId = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            workerPoolSource: isSet(object.workerPoolSource)
                ? WorkerPool_Source.fromJSON(object.workerPoolSource)
                : undefined,
            workerPoolVersion: isSet(object.workerPoolVersion)
                ? WorkerPool_Version.fromJSON(object.workerPoolVersion)
                : undefined,
            workerId: isSet(object.workerId) ? globalThis.String(object.workerId) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.workerPoolSource !== undefined) {
            obj.workerPoolSource = WorkerPool_Source.toJSON(message.workerPoolSource);
        }
        if (message.workerPoolVersion !== undefined) {
            obj.workerPoolVersion = WorkerPool_Version.toJSON(message.workerPoolVersion);
        }
        if (message.workerId !== "") {
            obj.workerId = message.workerId;
        }
        return obj;
    },
    create(base) {
        return RegisterWorkerPoolVersionRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseRegisterWorkerPoolVersionRequest();
        message.workerPoolSource = (object.workerPoolSource !== undefined && object.workerPoolSource !== null)
            ? WorkerPool_Source.fromPartial(object.workerPoolSource)
            : undefined;
        message.workerPoolVersion = (object.workerPoolVersion !== undefined && object.workerPoolVersion !== null)
            ? WorkerPool_Version.fromPartial(object.workerPoolVersion)
            : undefined;
        message.workerId = object.workerId ?? "";
        return message;
    },
};
messageTypeRegistry.set(RegisterWorkerPoolVersionRequest.$type, RegisterWorkerPoolVersionRequest);
function createBaseCallbackInfo() {
    return {
        name: "",
        requestFullName: "",
        sourceTopic: "",
        experimentalOptions: undefined,
        internalSchedulingExtensions: [],
    };
}
export const CallbackInfo = {
    $type: "reddit.coreplatform.cloudroutines.workerpool.v1.CallbackInfo",
    encode(message, writer = _m0.Writer.create()) {
        if (message.name !== "") {
            writer.uint32(10).string(message.name);
        }
        if (message.requestFullName !== "") {
            writer.uint32(18).string(message.requestFullName);
        }
        if (message.sourceTopic !== "") {
            writer.uint32(26).string(message.sourceTopic);
        }
        if (message.experimentalOptions !== undefined) {
            ExperimentalCallbackOptions.encode(message.experimentalOptions, writer.uint32(34).fork()).ldelim();
        }
        for (const v of message.internalSchedulingExtensions) {
            Any.encode(v, writer.uint32(42).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCallbackInfo();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.name = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.requestFullName = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.sourceTopic = reader.string();
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.experimentalOptions = ExperimentalCallbackOptions.decode(reader, reader.uint32());
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.internalSchedulingExtensions.push(Any.decode(reader, reader.uint32()));
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            name: isSet(object.name) ? globalThis.String(object.name) : "",
            requestFullName: isSet(object.requestFullName) ? globalThis.String(object.requestFullName) : "",
            sourceTopic: isSet(object.sourceTopic) ? globalThis.String(object.sourceTopic) : "",
            experimentalOptions: isSet(object.experimentalOptions)
                ? ExperimentalCallbackOptions.fromJSON(object.experimentalOptions)
                : undefined,
            internalSchedulingExtensions: globalThis.Array.isArray(object?.internalSchedulingExtensions)
                ? object.internalSchedulingExtensions.map((e) => Any.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.name !== "") {
            obj.name = message.name;
        }
        if (message.requestFullName !== "") {
            obj.requestFullName = message.requestFullName;
        }
        if (message.sourceTopic !== "") {
            obj.sourceTopic = message.sourceTopic;
        }
        if (message.experimentalOptions !== undefined) {
            obj.experimentalOptions = ExperimentalCallbackOptions.toJSON(message.experimentalOptions);
        }
        if (message.internalSchedulingExtensions?.length) {
            obj.internalSchedulingExtensions = message.internalSchedulingExtensions.map((e) => Any.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return CallbackInfo.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseCallbackInfo();
        message.name = object.name ?? "";
        message.requestFullName = object.requestFullName ?? "";
        message.sourceTopic = object.sourceTopic ?? "";
        message.experimentalOptions = (object.experimentalOptions !== undefined && object.experimentalOptions !== null)
            ? ExperimentalCallbackOptions.fromPartial(object.experimentalOptions)
            : undefined;
        message.internalSchedulingExtensions = object.internalSchedulingExtensions?.map((e) => Any.fromPartial(e)) || [];
        return message;
    },
};
messageTypeRegistry.set(CallbackInfo.$type, CallbackInfo);
function createBaseRegisterWorkerPoolVersionResponse() {
    return { errors: {} };
}
export const RegisterWorkerPoolVersionResponse = {
    $type: "reddit.coreplatform.cloudroutines.workerpool.v1.RegisterWorkerPoolVersionResponse",
    encode(message, writer = _m0.Writer.create()) {
        Object.entries(message.errors).forEach(([key, value]) => {
            RegisterWorkerPoolVersionResponse_ErrorsEntry.encode({ key: key, value }, writer.uint32(10).fork())
                .ldelim();
        });
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRegisterWorkerPoolVersionResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    const entry1 = RegisterWorkerPoolVersionResponse_ErrorsEntry.decode(reader, reader.uint32());
                    if (entry1.value !== undefined) {
                        message.errors[entry1.key] = entry1.value;
                    }
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            errors: isObject(object.errors)
                ? Object.entries(object.errors).reduce((acc, [key, value]) => {
                    acc[key] = Status.fromJSON(value);
                    return acc;
                }, {})
                : {},
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.errors) {
            const entries = Object.entries(message.errors);
            if (entries.length > 0) {
                obj.errors = {};
                entries.forEach(([k, v]) => {
                    obj.errors[k] = Status.toJSON(v);
                });
            }
        }
        return obj;
    },
    create(base) {
        return RegisterWorkerPoolVersionResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseRegisterWorkerPoolVersionResponse();
        message.errors = Object.entries(object.errors ?? {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = Status.fromPartial(value);
            }
            return acc;
        }, {});
        return message;
    },
};
messageTypeRegistry.set(RegisterWorkerPoolVersionResponse.$type, RegisterWorkerPoolVersionResponse);
function createBaseRegisterWorkerPoolVersionResponse_ErrorsEntry() {
    return { key: "", value: undefined };
}
export const RegisterWorkerPoolVersionResponse_ErrorsEntry = {
    $type: "reddit.coreplatform.cloudroutines.workerpool.v1.RegisterWorkerPoolVersionResponse.ErrorsEntry",
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== undefined) {
            Status.encode(message.value, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRegisterWorkerPoolVersionResponse_ErrorsEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.key = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.value = Status.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? globalThis.String(object.key) : "",
            value: isSet(object.value) ? Status.fromJSON(object.value) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.key !== "") {
            obj.key = message.key;
        }
        if (message.value !== undefined) {
            obj.value = Status.toJSON(message.value);
        }
        return obj;
    },
    create(base) {
        return RegisterWorkerPoolVersionResponse_ErrorsEntry.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseRegisterWorkerPoolVersionResponse_ErrorsEntry();
        message.key = object.key ?? "";
        message.value = (object.value !== undefined && object.value !== null)
            ? Status.fromPartial(object.value)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set(RegisterWorkerPoolVersionResponse_ErrorsEntry.$type, RegisterWorkerPoolVersionResponse_ErrorsEntry);
function createBaseWorkerPoolEvent() {
    return { registerVersion: undefined, evictVersion: undefined, evictPool: undefined };
}
export const WorkerPoolEvent = {
    $type: "reddit.coreplatform.cloudroutines.workerpool.v1.WorkerPoolEvent",
    encode(message, writer = _m0.Writer.create()) {
        if (message.registerVersion !== undefined) {
            WorkerPoolEvent_RegisterVersion.encode(message.registerVersion, writer.uint32(10).fork()).ldelim();
        }
        if (message.evictVersion !== undefined) {
            WorkerPoolEvent_EvictVersion.encode(message.evictVersion, writer.uint32(18).fork()).ldelim();
        }
        if (message.evictPool !== undefined) {
            WorkerPoolEvent_EvictPool.encode(message.evictPool, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseWorkerPoolEvent();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.registerVersion = WorkerPoolEvent_RegisterVersion.decode(reader, reader.uint32());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.evictVersion = WorkerPoolEvent_EvictVersion.decode(reader, reader.uint32());
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.evictPool = WorkerPoolEvent_EvictPool.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            registerVersion: isSet(object.registerVersion)
                ? WorkerPoolEvent_RegisterVersion.fromJSON(object.registerVersion)
                : undefined,
            evictVersion: isSet(object.evictVersion) ? WorkerPoolEvent_EvictVersion.fromJSON(object.evictVersion) : undefined,
            evictPool: isSet(object.evictPool) ? WorkerPoolEvent_EvictPool.fromJSON(object.evictPool) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.registerVersion !== undefined) {
            obj.registerVersion = WorkerPoolEvent_RegisterVersion.toJSON(message.registerVersion);
        }
        if (message.evictVersion !== undefined) {
            obj.evictVersion = WorkerPoolEvent_EvictVersion.toJSON(message.evictVersion);
        }
        if (message.evictPool !== undefined) {
            obj.evictPool = WorkerPoolEvent_EvictPool.toJSON(message.evictPool);
        }
        return obj;
    },
    create(base) {
        return WorkerPoolEvent.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseWorkerPoolEvent();
        message.registerVersion = (object.registerVersion !== undefined && object.registerVersion !== null)
            ? WorkerPoolEvent_RegisterVersion.fromPartial(object.registerVersion)
            : undefined;
        message.evictVersion = (object.evictVersion !== undefined && object.evictVersion !== null)
            ? WorkerPoolEvent_EvictVersion.fromPartial(object.evictVersion)
            : undefined;
        message.evictPool = (object.evictPool !== undefined && object.evictPool !== null)
            ? WorkerPoolEvent_EvictPool.fromPartial(object.evictPool)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set(WorkerPoolEvent.$type, WorkerPoolEvent);
function createBaseWorkerPoolEvent_RegisterVersion() {
    return { source: undefined, version: undefined, workerId: "" };
}
export const WorkerPoolEvent_RegisterVersion = {
    $type: "reddit.coreplatform.cloudroutines.workerpool.v1.WorkerPoolEvent.RegisterVersion",
    encode(message, writer = _m0.Writer.create()) {
        if (message.source !== undefined) {
            WorkerPool_Source.encode(message.source, writer.uint32(10).fork()).ldelim();
        }
        if (message.version !== undefined) {
            WorkerPool_Version.encode(message.version, writer.uint32(18).fork()).ldelim();
        }
        if (message.workerId !== "") {
            writer.uint32(26).string(message.workerId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseWorkerPoolEvent_RegisterVersion();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.source = WorkerPool_Source.decode(reader, reader.uint32());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.version = WorkerPool_Version.decode(reader, reader.uint32());
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.workerId = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            source: isSet(object.source) ? WorkerPool_Source.fromJSON(object.source) : undefined,
            version: isSet(object.version) ? WorkerPool_Version.fromJSON(object.version) : undefined,
            workerId: isSet(object.workerId) ? globalThis.String(object.workerId) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.source !== undefined) {
            obj.source = WorkerPool_Source.toJSON(message.source);
        }
        if (message.version !== undefined) {
            obj.version = WorkerPool_Version.toJSON(message.version);
        }
        if (message.workerId !== "") {
            obj.workerId = message.workerId;
        }
        return obj;
    },
    create(base) {
        return WorkerPoolEvent_RegisterVersion.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseWorkerPoolEvent_RegisterVersion();
        message.source = (object.source !== undefined && object.source !== null)
            ? WorkerPool_Source.fromPartial(object.source)
            : undefined;
        message.version = (object.version !== undefined && object.version !== null)
            ? WorkerPool_Version.fromPartial(object.version)
            : undefined;
        message.workerId = object.workerId ?? "";
        return message;
    },
};
messageTypeRegistry.set(WorkerPoolEvent_RegisterVersion.$type, WorkerPoolEvent_RegisterVersion);
function createBaseWorkerPoolEvent_EvictVersion() {
    return { source: undefined, version: undefined };
}
export const WorkerPoolEvent_EvictVersion = {
    $type: "reddit.coreplatform.cloudroutines.workerpool.v1.WorkerPoolEvent.EvictVersion",
    encode(message, writer = _m0.Writer.create()) {
        if (message.source !== undefined) {
            WorkerPool_Source.encode(message.source, writer.uint32(10).fork()).ldelim();
        }
        if (message.version !== undefined) {
            WorkerPool_Version.encode(message.version, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseWorkerPoolEvent_EvictVersion();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.source = WorkerPool_Source.decode(reader, reader.uint32());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.version = WorkerPool_Version.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            source: isSet(object.source) ? WorkerPool_Source.fromJSON(object.source) : undefined,
            version: isSet(object.version) ? WorkerPool_Version.fromJSON(object.version) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.source !== undefined) {
            obj.source = WorkerPool_Source.toJSON(message.source);
        }
        if (message.version !== undefined) {
            obj.version = WorkerPool_Version.toJSON(message.version);
        }
        return obj;
    },
    create(base) {
        return WorkerPoolEvent_EvictVersion.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseWorkerPoolEvent_EvictVersion();
        message.source = (object.source !== undefined && object.source !== null)
            ? WorkerPool_Source.fromPartial(object.source)
            : undefined;
        message.version = (object.version !== undefined && object.version !== null)
            ? WorkerPool_Version.fromPartial(object.version)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set(WorkerPoolEvent_EvictVersion.$type, WorkerPoolEvent_EvictVersion);
function createBaseWorkerPoolEvent_EvictPool() {
    return { source: undefined };
}
export const WorkerPoolEvent_EvictPool = {
    $type: "reddit.coreplatform.cloudroutines.workerpool.v1.WorkerPoolEvent.EvictPool",
    encode(message, writer = _m0.Writer.create()) {
        if (message.source !== undefined) {
            WorkerPool_Source.encode(message.source, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseWorkerPoolEvent_EvictPool();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.source = WorkerPool_Source.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { source: isSet(object.source) ? WorkerPool_Source.fromJSON(object.source) : undefined };
    },
    toJSON(message) {
        const obj = {};
        if (message.source !== undefined) {
            obj.source = WorkerPool_Source.toJSON(message.source);
        }
        return obj;
    },
    create(base) {
        return WorkerPoolEvent_EvictPool.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseWorkerPoolEvent_EvictPool();
        message.source = (object.source !== undefined && object.source !== null)
            ? WorkerPool_Source.fromPartial(object.source)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set(WorkerPoolEvent_EvictPool.$type, WorkerPoolEvent_EvictPool);
function createBaseWorkerPool() {
    return { source: undefined, versions: {} };
}
export const WorkerPool = {
    $type: "reddit.coreplatform.cloudroutines.workerpool.v1.WorkerPool",
    encode(message, writer = _m0.Writer.create()) {
        if (message.source !== undefined) {
            WorkerPool_Source.encode(message.source, writer.uint32(10).fork()).ldelim();
        }
        Object.entries(message.versions).forEach(([key, value]) => {
            WorkerPool_VersionsEntry.encode({ key: key, value }, writer.uint32(18).fork()).ldelim();
        });
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseWorkerPool();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.source = WorkerPool_Source.decode(reader, reader.uint32());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    const entry2 = WorkerPool_VersionsEntry.decode(reader, reader.uint32());
                    if (entry2.value !== undefined) {
                        message.versions[entry2.key] = entry2.value;
                    }
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            source: isSet(object.source) ? WorkerPool_Source.fromJSON(object.source) : undefined,
            versions: isObject(object.versions)
                ? Object.entries(object.versions).reduce((acc, [key, value]) => {
                    acc[key] = WorkerPool_Version.fromJSON(value);
                    return acc;
                }, {})
                : {},
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.source !== undefined) {
            obj.source = WorkerPool_Source.toJSON(message.source);
        }
        if (message.versions) {
            const entries = Object.entries(message.versions);
            if (entries.length > 0) {
                obj.versions = {};
                entries.forEach(([k, v]) => {
                    obj.versions[k] = WorkerPool_Version.toJSON(v);
                });
            }
        }
        return obj;
    },
    create(base) {
        return WorkerPool.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseWorkerPool();
        message.source = (object.source !== undefined && object.source !== null)
            ? WorkerPool_Source.fromPartial(object.source)
            : undefined;
        message.versions = Object.entries(object.versions ?? {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = WorkerPool_Version.fromPartial(value);
            }
            return acc;
        }, {});
        return message;
    },
};
messageTypeRegistry.set(WorkerPool.$type, WorkerPool);
function createBaseWorkerPool_Source() {
    return { deploymentReference: undefined };
}
export const WorkerPool_Source = {
    $type: "reddit.coreplatform.cloudroutines.workerpool.v1.WorkerPool.Source",
    encode(message, writer = _m0.Writer.create()) {
        if (message.deploymentReference !== undefined) {
            DeploymentReference.encode(message.deploymentReference, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseWorkerPool_Source();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.deploymentReference = DeploymentReference.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            deploymentReference: isSet(object.deploymentReference)
                ? DeploymentReference.fromJSON(object.deploymentReference)
                : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.deploymentReference !== undefined) {
            obj.deploymentReference = DeploymentReference.toJSON(message.deploymentReference);
        }
        return obj;
    },
    create(base) {
        return WorkerPool_Source.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseWorkerPool_Source();
        message.deploymentReference = (object.deploymentReference !== undefined && object.deploymentReference !== null)
            ? DeploymentReference.fromPartial(object.deploymentReference)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set(WorkerPool_Source.$type, WorkerPool_Source);
function createBaseWorkerPool_Version() {
    return { id: "", port: 0, callbacks: {}, workloadExtension: undefined, workloadVersionId: "" };
}
export const WorkerPool_Version = {
    $type: "reddit.coreplatform.cloudroutines.workerpool.v1.WorkerPool.Version",
    encode(message, writer = _m0.Writer.create()) {
        if (message.id !== "") {
            writer.uint32(10).string(message.id);
        }
        if (message.port !== 0) {
            writer.uint32(24).int32(message.port);
        }
        Object.entries(message.callbacks).forEach(([key, value]) => {
            WorkerPool_Version_CallbacksEntry.encode({ key: key, value }, writer.uint32(34).fork()).ldelim();
        });
        if (message.workloadExtension !== undefined) {
            Any.encode(message.workloadExtension, writer.uint32(42).fork()).ldelim();
        }
        if (message.workloadVersionId !== "") {
            writer.uint32(50).string(message.workloadVersionId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseWorkerPool_Version();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.id = reader.string();
                    continue;
                case 3:
                    if (tag !== 24) {
                        break;
                    }
                    message.port = reader.int32();
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    const entry4 = WorkerPool_Version_CallbacksEntry.decode(reader, reader.uint32());
                    if (entry4.value !== undefined) {
                        message.callbacks[entry4.key] = entry4.value;
                    }
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.workloadExtension = Any.decode(reader, reader.uint32());
                    continue;
                case 6:
                    if (tag !== 50) {
                        break;
                    }
                    message.workloadVersionId = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            id: isSet(object.id) ? globalThis.String(object.id) : "",
            port: isSet(object.port) ? globalThis.Number(object.port) : 0,
            callbacks: isObject(object.callbacks)
                ? Object.entries(object.callbacks).reduce((acc, [key, value]) => {
                    acc[key] = CallbackInfo.fromJSON(value);
                    return acc;
                }, {})
                : {},
            workloadExtension: isSet(object.workloadExtension) ? Any.fromJSON(object.workloadExtension) : undefined,
            workloadVersionId: isSet(object.workloadVersionId) ? globalThis.String(object.workloadVersionId) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.id !== "") {
            obj.id = message.id;
        }
        if (message.port !== 0) {
            obj.port = Math.round(message.port);
        }
        if (message.callbacks) {
            const entries = Object.entries(message.callbacks);
            if (entries.length > 0) {
                obj.callbacks = {};
                entries.forEach(([k, v]) => {
                    obj.callbacks[k] = CallbackInfo.toJSON(v);
                });
            }
        }
        if (message.workloadExtension !== undefined) {
            obj.workloadExtension = Any.toJSON(message.workloadExtension);
        }
        if (message.workloadVersionId !== "") {
            obj.workloadVersionId = message.workloadVersionId;
        }
        return obj;
    },
    create(base) {
        return WorkerPool_Version.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseWorkerPool_Version();
        message.id = object.id ?? "";
        message.port = object.port ?? 0;
        message.callbacks = Object.entries(object.callbacks ?? {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = CallbackInfo.fromPartial(value);
            }
            return acc;
        }, {});
        message.workloadExtension = (object.workloadExtension !== undefined && object.workloadExtension !== null)
            ? Any.fromPartial(object.workloadExtension)
            : undefined;
        message.workloadVersionId = object.workloadVersionId ?? "";
        return message;
    },
};
messageTypeRegistry.set(WorkerPool_Version.$type, WorkerPool_Version);
function createBaseWorkerPool_Version_CallbacksEntry() {
    return { key: "", value: undefined };
}
export const WorkerPool_Version_CallbacksEntry = {
    $type: "reddit.coreplatform.cloudroutines.workerpool.v1.WorkerPool.Version.CallbacksEntry",
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== undefined) {
            CallbackInfo.encode(message.value, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseWorkerPool_Version_CallbacksEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.key = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.value = CallbackInfo.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? globalThis.String(object.key) : "",
            value: isSet(object.value) ? CallbackInfo.fromJSON(object.value) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.key !== "") {
            obj.key = message.key;
        }
        if (message.value !== undefined) {
            obj.value = CallbackInfo.toJSON(message.value);
        }
        return obj;
    },
    create(base) {
        return WorkerPool_Version_CallbacksEntry.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseWorkerPool_Version_CallbacksEntry();
        message.key = object.key ?? "";
        message.value = (object.value !== undefined && object.value !== null)
            ? CallbackInfo.fromPartial(object.value)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set(WorkerPool_Version_CallbacksEntry.$type, WorkerPool_Version_CallbacksEntry);
function createBaseWorkerPool_VersionsEntry() {
    return { key: "", value: undefined };
}
export const WorkerPool_VersionsEntry = {
    $type: "reddit.coreplatform.cloudroutines.workerpool.v1.WorkerPool.VersionsEntry",
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== undefined) {
            WorkerPool_Version.encode(message.value, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseWorkerPool_VersionsEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.key = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.value = WorkerPool_Version.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? globalThis.String(object.key) : "",
            value: isSet(object.value) ? WorkerPool_Version.fromJSON(object.value) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.key !== "") {
            obj.key = message.key;
        }
        if (message.value !== undefined) {
            obj.value = WorkerPool_Version.toJSON(message.value);
        }
        return obj;
    },
    create(base) {
        return WorkerPool_VersionsEntry.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseWorkerPool_VersionsEntry();
        message.key = object.key ?? "";
        message.value = (object.value !== undefined && object.value !== null)
            ? WorkerPool_Version.fromPartial(object.value)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set(WorkerPool_VersionsEntry.$type, WorkerPool_VersionsEntry);
function createBaseDeploymentReference() {
    return { name: "", namespace: "" };
}
export const DeploymentReference = {
    $type: "reddit.coreplatform.cloudroutines.workerpool.v1.DeploymentReference",
    encode(message, writer = _m0.Writer.create()) {
        if (message.name !== "") {
            writer.uint32(10).string(message.name);
        }
        if (message.namespace !== "") {
            writer.uint32(18).string(message.namespace);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseDeploymentReference();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.name = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.namespace = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            name: isSet(object.name) ? globalThis.String(object.name) : "",
            namespace: isSet(object.namespace) ? globalThis.String(object.namespace) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.name !== "") {
            obj.name = message.name;
        }
        if (message.namespace !== "") {
            obj.namespace = message.namespace;
        }
        return obj;
    },
    create(base) {
        return DeploymentReference.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseDeploymentReference();
        message.name = object.name ?? "";
        message.namespace = object.namespace ?? "";
        return message;
    },
};
messageTypeRegistry.set(DeploymentReference.$type, DeploymentReference);
function createBaseEinhornWorkloadExtension() {
    return { portRange: undefined };
}
export const EinhornWorkloadExtension = {
    $type: "reddit.coreplatform.cloudroutines.workerpool.v1.EinhornWorkloadExtension",
    encode(message, writer = _m0.Writer.create()) {
        if (message.portRange !== undefined) {
            EinhornWorkloadExtension_PortRange.encode(message.portRange, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseEinhornWorkloadExtension();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.portRange = EinhornWorkloadExtension_PortRange.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            portRange: isSet(object.portRange) ? EinhornWorkloadExtension_PortRange.fromJSON(object.portRange) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.portRange !== undefined) {
            obj.portRange = EinhornWorkloadExtension_PortRange.toJSON(message.portRange);
        }
        return obj;
    },
    create(base) {
        return EinhornWorkloadExtension.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseEinhornWorkloadExtension();
        message.portRange = (object.portRange !== undefined && object.portRange !== null)
            ? EinhornWorkloadExtension_PortRange.fromPartial(object.portRange)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set(EinhornWorkloadExtension.$type, EinhornWorkloadExtension);
function createBaseEinhornWorkloadExtension_PortRange() {
    return { start: 0, end: 0 };
}
export const EinhornWorkloadExtension_PortRange = {
    $type: "reddit.coreplatform.cloudroutines.workerpool.v1.EinhornWorkloadExtension.PortRange",
    encode(message, writer = _m0.Writer.create()) {
        if (message.start !== 0) {
            writer.uint32(8).int32(message.start);
        }
        if (message.end !== 0) {
            writer.uint32(16).int32(message.end);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseEinhornWorkloadExtension_PortRange();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.start = reader.int32();
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.end = reader.int32();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            start: isSet(object.start) ? globalThis.Number(object.start) : 0,
            end: isSet(object.end) ? globalThis.Number(object.end) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.start !== 0) {
            obj.start = Math.round(message.start);
        }
        if (message.end !== 0) {
            obj.end = Math.round(message.end);
        }
        return obj;
    },
    create(base) {
        return EinhornWorkloadExtension_PortRange.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseEinhornWorkloadExtension_PortRange();
        message.start = object.start ?? 0;
        message.end = object.end ?? 0;
        return message;
    },
};
messageTypeRegistry.set(EinhornWorkloadExtension_PortRange.$type, EinhornWorkloadExtension_PortRange);
function createBaseMonocerosWorkloadExtension() {
    return { portRange: undefined };
}
export const MonocerosWorkloadExtension = {
    $type: "reddit.coreplatform.cloudroutines.workerpool.v1.MonocerosWorkloadExtension",
    encode(message, writer = _m0.Writer.create()) {
        if (message.portRange !== undefined) {
            MonocerosWorkloadExtension_PortRange.encode(message.portRange, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMonocerosWorkloadExtension();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.portRange = MonocerosWorkloadExtension_PortRange.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            portRange: isSet(object.portRange) ? MonocerosWorkloadExtension_PortRange.fromJSON(object.portRange) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.portRange !== undefined) {
            obj.portRange = MonocerosWorkloadExtension_PortRange.toJSON(message.portRange);
        }
        return obj;
    },
    create(base) {
        return MonocerosWorkloadExtension.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseMonocerosWorkloadExtension();
        message.portRange = (object.portRange !== undefined && object.portRange !== null)
            ? MonocerosWorkloadExtension_PortRange.fromPartial(object.portRange)
            : undefined;
        return message;
    },
};
messageTypeRegistry.set(MonocerosWorkloadExtension.$type, MonocerosWorkloadExtension);
function createBaseMonocerosWorkloadExtension_PortRange() {
    return { start: 0, end: 0 };
}
export const MonocerosWorkloadExtension_PortRange = {
    $type: "reddit.coreplatform.cloudroutines.workerpool.v1.MonocerosWorkloadExtension.PortRange",
    encode(message, writer = _m0.Writer.create()) {
        if (message.start !== 0) {
            writer.uint32(8).int32(message.start);
        }
        if (message.end !== 0) {
            writer.uint32(16).int32(message.end);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMonocerosWorkloadExtension_PortRange();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.start = reader.int32();
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.end = reader.int32();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            start: isSet(object.start) ? globalThis.Number(object.start) : 0,
            end: isSet(object.end) ? globalThis.Number(object.end) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.start !== 0) {
            obj.start = Math.round(message.start);
        }
        if (message.end !== 0) {
            obj.end = Math.round(message.end);
        }
        return obj;
    },
    create(base) {
        return MonocerosWorkloadExtension_PortRange.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseMonocerosWorkloadExtension_PortRange();
        message.start = object.start ?? 0;
        message.end = object.end ?? 0;
        return message;
    },
};
messageTypeRegistry.set(MonocerosWorkloadExtension_PortRange.$type, MonocerosWorkloadExtension_PortRange);
export const WorkerPoolServiceServiceName = "reddit.coreplatform.cloudroutines.workerpool.v1.WorkerPoolService";
export class WorkerPoolServiceClientImpl {
    constructor(rpc, opts) {
        this.service = opts?.service || WorkerPoolServiceServiceName;
        this.rpc = rpc;
        this.RegisterWorkerPoolVersion = this.RegisterWorkerPoolVersion.bind(this);
        this.ReplayCallbackWithWindow = this.ReplayCallbackWithWindow.bind(this);
    }
    RegisterWorkerPoolVersion(request, metadata) {
        const data = RegisterWorkerPoolVersionRequest.encode(request).finish();
        const promise = this.rpc.request(this.service, "RegisterWorkerPoolVersion", data, metadata);
        return promise.then((data) => RegisterWorkerPoolVersionResponse.decode(_m0.Reader.create(data)));
    }
    ReplayCallbackWithWindow(request, metadata) {
        const data = ReplayCallbackWithWindowRequest.encode(request).finish();
        const promise = this.rpc.request(this.service, "ReplayCallbackWithWindow", data, metadata);
        return promise.then((data) => ReplayCallbackWithWindowResponse.decode(_m0.Reader.create(data)));
    }
}
export const WorkerPoolServiceDefinition = {
    name: "WorkerPoolService",
    fullName: "reddit.coreplatform.cloudroutines.workerpool.v1.WorkerPoolService",
    methods: {
        /**
         * RegisterWorkerPoolVersion handles the registration of new workers to a given pool.
         * Responses contain a mapping of callback names to corresponding error statuses encountered during registration.
         * Problematic callbacks will be omitted from registration and returned in the response errors map.
         */
        registerWorkerPoolVersion: {
            name: "RegisterWorkerPoolVersion",
            requestType: RegisterWorkerPoolVersionRequest,
            requestStream: false,
            responseType: RegisterWorkerPoolVersionResponse,
            responseStream: false,
            options: { idempotencyLevel: "IDEMPOTENT" },
        },
        /**
         * ReplayCallbackWithWindow will trigger Cloudroutines to redeliver messages published within the specified time
         * window to the specified callback. If the time window falls outside of the topic retention window, then no messages will
         * be delivered and an error is returned.
         */
        replayCallbackWithWindow: {
            name: "ReplayCallbackWithWindow",
            requestType: ReplayCallbackWithWindowRequest,
            requestStream: false,
            responseType: ReplayCallbackWithWindowResponse,
            responseStream: false,
            options: { idempotencyLevel: "IDEMPOTENT" },
        },
    },
};
function toTimestamp(date) {
    const seconds = Math.trunc(date.getTime() / 1000);
    const nanos = (date.getTime() % 1000) * 1000000;
    return { seconds, nanos };
}
function fromTimestamp(t) {
    let millis = (t.seconds || 0) * 1000;
    millis += (t.nanos || 0) / 1000000;
    return new globalThis.Date(millis);
}
function fromJsonTimestamp(o) {
    if (o instanceof globalThis.Date) {
        return o;
    }
    else if (typeof o === "string") {
        return new globalThis.Date(o);
    }
    else {
        return fromTimestamp(Timestamp.fromJSON(o));
    }
}
function isObject(value) {
    return typeof value === "object" && value !== null;
}
function isSet(value) {
    return value !== null && value !== undefined;
}
