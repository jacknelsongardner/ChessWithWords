import { TwirpServer, TwirpError, TwirpErrorCode, TwirpContentType, chainInterceptors, } from 'twirp-ts';
import { InstallationUpgradeRequest, FullInstallationInfo, InstallationUpgradeManyRequest, InstallationUpgradeManyResponse, } from './installation/installation.js';
import { GetPendingRequest, GetResponse, UpdateStatusForAppRequest, } from './fetch_domain_request/fetch_domain_request.js';
import { Empty } from '../../google/protobuf/empty.js';
import { Int32Value } from '../../google/protobuf/wrappers.js';
import { GetAppBySlugWithDomainInfoRequest, AppWithDomainInfo, GetAppsWithDomainInfoRequest, GetAppsWithDomainInfoResponse, AddDomainsToAppRequest, RemoveDomainFromAppRequest, } from './app/app.js';
export var AdminInstallationMethod;
(function (AdminInstallationMethod) {
    AdminInstallationMethod["Upgrade"] = "Upgrade";
    AdminInstallationMethod["UpgradeMany"] = "UpgradeMany";
})(AdminInstallationMethod || (AdminInstallationMethod = {}));
export const AdminInstallationMethodList = [
    AdminInstallationMethod.Upgrade,
    AdminInstallationMethod.UpgradeMany,
];
export function createAdminInstallationServer(service) {
    return new TwirpServer({
        service,
        packageName: 'devvit.dev_portal',
        serviceName: 'AdminInstallation',
        methodList: AdminInstallationMethodList,
        matchRoute: matchAdminInstallationRoute,
    });
}
function matchAdminInstallationRoute(method, events) {
    switch (method) {
        case 'Upgrade':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'Upgrade' };
                await events.onMatch(ctx);
                return handleAdminInstallationUpgradeRequest(ctx, service, data, interceptors);
            };
        case 'UpgradeMany':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'UpgradeMany' };
                await events.onMatch(ctx);
                return handleAdminInstallationUpgradeManyRequest(ctx, service, data, interceptors);
            };
        default:
            events.onNotFound();
            const msg = `no handler found`;
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleAdminInstallationUpgradeRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleAdminInstallationUpgradeJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleAdminInstallationUpgradeProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleAdminInstallationUpgradeManyRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleAdminInstallationUpgradeManyJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleAdminInstallationUpgradeManyProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
async function handleAdminInstallationUpgradeJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = InstallationUpgradeRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.Upgrade(ctx, inputReq);
        });
    }
    else {
        response = await service.Upgrade(ctx, request);
    }
    return JSON.stringify(FullInstallationInfo.toJSON(response));
}
async function handleAdminInstallationUpgradeManyJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = InstallationUpgradeManyRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.UpgradeMany(ctx, inputReq);
        });
    }
    else {
        response = await service.UpgradeMany(ctx, request);
    }
    return JSON.stringify(InstallationUpgradeManyResponse.toJSON(response));
}
async function handleAdminInstallationUpgradeProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = InstallationUpgradeRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.Upgrade(ctx, inputReq);
        });
    }
    else {
        response = await service.Upgrade(ctx, request);
    }
    return Buffer.from(FullInstallationInfo.encode(response).finish());
}
async function handleAdminInstallationUpgradeManyProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = InstallationUpgradeManyRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.UpgradeMany(ctx, inputReq);
        });
    }
    else {
        response = await service.UpgradeMany(ctx, request);
    }
    return Buffer.from(InstallationUpgradeManyResponse.encode(response).finish());
}
export var AdminFetchDomainRequestMethod;
(function (AdminFetchDomainRequestMethod) {
    AdminFetchDomainRequestMethod["GetPending"] = "GetPending";
    AdminFetchDomainRequestMethod["GetPendingRequestsCount"] = "GetPendingRequestsCount";
    AdminFetchDomainRequestMethod["UpdateStatusForApp"] = "UpdateStatusForApp";
})(AdminFetchDomainRequestMethod || (AdminFetchDomainRequestMethod = {}));
export const AdminFetchDomainRequestMethodList = [
    AdminFetchDomainRequestMethod.GetPending,
    AdminFetchDomainRequestMethod.GetPendingRequestsCount,
    AdminFetchDomainRequestMethod.UpdateStatusForApp,
];
export function createAdminFetchDomainRequestServer(service) {
    return new TwirpServer({
        service,
        packageName: 'devvit.dev_portal',
        serviceName: 'AdminFetchDomainRequest',
        methodList: AdminFetchDomainRequestMethodList,
        matchRoute: matchAdminFetchDomainRequestRoute,
    });
}
function matchAdminFetchDomainRequestRoute(method, events) {
    switch (method) {
        case 'GetPending':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'GetPending' };
                await events.onMatch(ctx);
                return handleAdminFetchDomainRequestGetPendingRequest(ctx, service, data, interceptors);
            };
        case 'GetPendingRequestsCount':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'GetPendingRequestsCount' };
                await events.onMatch(ctx);
                return handleAdminFetchDomainRequestGetPendingRequestsCountRequest(ctx, service, data, interceptors);
            };
        case 'UpdateStatusForApp':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'UpdateStatusForApp' };
                await events.onMatch(ctx);
                return handleAdminFetchDomainRequestUpdateStatusForAppRequest(ctx, service, data, interceptors);
            };
        default:
            events.onNotFound();
            const msg = `no handler found`;
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleAdminFetchDomainRequestGetPendingRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleAdminFetchDomainRequestGetPendingJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleAdminFetchDomainRequestGetPendingProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleAdminFetchDomainRequestGetPendingRequestsCountRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleAdminFetchDomainRequestGetPendingRequestsCountJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleAdminFetchDomainRequestGetPendingRequestsCountProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleAdminFetchDomainRequestUpdateStatusForAppRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleAdminFetchDomainRequestUpdateStatusForAppJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleAdminFetchDomainRequestUpdateStatusForAppProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
async function handleAdminFetchDomainRequestGetPendingJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = GetPendingRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.GetPending(ctx, inputReq);
        });
    }
    else {
        response = await service.GetPending(ctx, request);
    }
    return JSON.stringify(GetResponse.toJSON(response));
}
async function handleAdminFetchDomainRequestGetPendingRequestsCountJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = Empty.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.GetPendingRequestsCount(ctx, inputReq);
        });
    }
    else {
        response = await service.GetPendingRequestsCount(ctx, request);
    }
    return JSON.stringify(Int32Value.toJSON(response));
}
async function handleAdminFetchDomainRequestUpdateStatusForAppJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = UpdateStatusForAppRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.UpdateStatusForApp(ctx, inputReq);
        });
    }
    else {
        response = await service.UpdateStatusForApp(ctx, request);
    }
    return JSON.stringify(Empty.toJSON(response));
}
async function handleAdminFetchDomainRequestGetPendingProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = GetPendingRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.GetPending(ctx, inputReq);
        });
    }
    else {
        response = await service.GetPending(ctx, request);
    }
    return Buffer.from(GetResponse.encode(response).finish());
}
async function handleAdminFetchDomainRequestGetPendingRequestsCountProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = Empty.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.GetPendingRequestsCount(ctx, inputReq);
        });
    }
    else {
        response = await service.GetPendingRequestsCount(ctx, request);
    }
    return Buffer.from(Int32Value.encode(response).finish());
}
async function handleAdminFetchDomainRequestUpdateStatusForAppProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = UpdateStatusForAppRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.UpdateStatusForApp(ctx, inputReq);
        });
    }
    else {
        response = await service.UpdateStatusForApp(ctx, request);
    }
    return Buffer.from(Empty.encode(response).finish());
}
export var AdminAppMethod;
(function (AdminAppMethod) {
    AdminAppMethod["GetAppBySlugWithDomainInfo"] = "GetAppBySlugWithDomainInfo";
    AdminAppMethod["GetAppsWithDomainInfo"] = "GetAppsWithDomainInfo";
    AdminAppMethod["AddDomainsToApp"] = "AddDomainsToApp";
    AdminAppMethod["RemoveDomainFromApp"] = "RemoveDomainFromApp";
})(AdminAppMethod || (AdminAppMethod = {}));
export const AdminAppMethodList = [
    AdminAppMethod.GetAppBySlugWithDomainInfo,
    AdminAppMethod.GetAppsWithDomainInfo,
    AdminAppMethod.AddDomainsToApp,
    AdminAppMethod.RemoveDomainFromApp,
];
export function createAdminAppServer(service) {
    return new TwirpServer({
        service,
        packageName: 'devvit.dev_portal',
        serviceName: 'AdminApp',
        methodList: AdminAppMethodList,
        matchRoute: matchAdminAppRoute,
    });
}
function matchAdminAppRoute(method, events) {
    switch (method) {
        case 'GetAppBySlugWithDomainInfo':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'GetAppBySlugWithDomainInfo' };
                await events.onMatch(ctx);
                return handleAdminAppGetAppBySlugWithDomainInfoRequest(ctx, service, data, interceptors);
            };
        case 'GetAppsWithDomainInfo':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'GetAppsWithDomainInfo' };
                await events.onMatch(ctx);
                return handleAdminAppGetAppsWithDomainInfoRequest(ctx, service, data, interceptors);
            };
        case 'AddDomainsToApp':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'AddDomainsToApp' };
                await events.onMatch(ctx);
                return handleAdminAppAddDomainsToAppRequest(ctx, service, data, interceptors);
            };
        case 'RemoveDomainFromApp':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'RemoveDomainFromApp' };
                await events.onMatch(ctx);
                return handleAdminAppRemoveDomainFromAppRequest(ctx, service, data, interceptors);
            };
        default:
            events.onNotFound();
            const msg = `no handler found`;
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleAdminAppGetAppBySlugWithDomainInfoRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleAdminAppGetAppBySlugWithDomainInfoJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleAdminAppGetAppBySlugWithDomainInfoProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleAdminAppGetAppsWithDomainInfoRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleAdminAppGetAppsWithDomainInfoJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleAdminAppGetAppsWithDomainInfoProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleAdminAppAddDomainsToAppRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleAdminAppAddDomainsToAppJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleAdminAppAddDomainsToAppProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handleAdminAppRemoveDomainFromAppRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handleAdminAppRemoveDomainFromAppJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handleAdminAppRemoveDomainFromAppProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
async function handleAdminAppGetAppBySlugWithDomainInfoJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = GetAppBySlugWithDomainInfoRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.GetAppBySlugWithDomainInfo(ctx, inputReq);
        });
    }
    else {
        response = await service.GetAppBySlugWithDomainInfo(ctx, request);
    }
    return JSON.stringify(AppWithDomainInfo.toJSON(response));
}
async function handleAdminAppGetAppsWithDomainInfoJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = GetAppsWithDomainInfoRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.GetAppsWithDomainInfo(ctx, inputReq);
        });
    }
    else {
        response = await service.GetAppsWithDomainInfo(ctx, request);
    }
    return JSON.stringify(GetAppsWithDomainInfoResponse.toJSON(response));
}
async function handleAdminAppAddDomainsToAppJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = AddDomainsToAppRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.AddDomainsToApp(ctx, inputReq);
        });
    }
    else {
        response = await service.AddDomainsToApp(ctx, request);
    }
    return JSON.stringify(Empty.toJSON(response));
}
async function handleAdminAppRemoveDomainFromAppJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = RemoveDomainFromAppRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.RemoveDomainFromApp(ctx, inputReq);
        });
    }
    else {
        response = await service.RemoveDomainFromApp(ctx, request);
    }
    return JSON.stringify(Empty.toJSON(response));
}
async function handleAdminAppGetAppBySlugWithDomainInfoProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = GetAppBySlugWithDomainInfoRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.GetAppBySlugWithDomainInfo(ctx, inputReq);
        });
    }
    else {
        response = await service.GetAppBySlugWithDomainInfo(ctx, request);
    }
    return Buffer.from(AppWithDomainInfo.encode(response).finish());
}
async function handleAdminAppGetAppsWithDomainInfoProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = GetAppsWithDomainInfoRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.GetAppsWithDomainInfo(ctx, inputReq);
        });
    }
    else {
        response = await service.GetAppsWithDomainInfo(ctx, request);
    }
    return Buffer.from(GetAppsWithDomainInfoResponse.encode(response).finish());
}
async function handleAdminAppAddDomainsToAppProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = AddDomainsToAppRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.AddDomainsToApp(ctx, inputReq);
        });
    }
    else {
        response = await service.AddDomainsToApp(ctx, request);
    }
    return Buffer.from(Empty.encode(response).finish());
}
async function handleAdminAppRemoveDomainFromAppProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = RemoveDomainFromAppRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.RemoveDomainFromApp(ctx, inputReq);
        });
    }
    else {
        response = await service.RemoveDomainFromApp(ctx, request);
    }
    return Buffer.from(Empty.encode(response).finish());
}
