/**
 * #webbit.ts
 *
 * Code generated by ts-proto. DO NOT EDIT.
 * @packageDocumentation
 */
/* eslint-disable */
import _m0 from "protobufjs/minimal.js";
import { messageTypeRegistry } from "../../../typeRegistry.js";
export var HttpMethod;
(function (HttpMethod) {
    HttpMethod[HttpMethod["HTTP_METHOD_UNSPECIFIED"] = 0] = "HTTP_METHOD_UNSPECIFIED";
    HttpMethod[HttpMethod["POST"] = 1] = "POST";
    HttpMethod[HttpMethod["GET"] = 2] = "GET";
    HttpMethod[HttpMethod["HEAD"] = 3] = "HEAD";
    HttpMethod[HttpMethod["PUT"] = 4] = "PUT";
    HttpMethod[HttpMethod["DELETE"] = 5] = "DELETE";
    HttpMethod[HttpMethod["PATCH"] = 6] = "PATCH";
    HttpMethod[HttpMethod["OPTIONS"] = 7] = "OPTIONS";
    HttpMethod[HttpMethod["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(HttpMethod || (HttpMethod = {}));
export function httpMethodFromJSON(object) {
    switch (object) {
        case 0:
        case "HTTP_METHOD_UNSPECIFIED":
            return HttpMethod.HTTP_METHOD_UNSPECIFIED;
        case 1:
        case "POST":
            return HttpMethod.POST;
        case 2:
        case "GET":
            return HttpMethod.GET;
        case 3:
        case "HEAD":
            return HttpMethod.HEAD;
        case 4:
        case "PUT":
            return HttpMethod.PUT;
        case 5:
        case "DELETE":
            return HttpMethod.DELETE;
        case 6:
        case "PATCH":
            return HttpMethod.PATCH;
        case 7:
        case "OPTIONS":
            return HttpMethod.OPTIONS;
        case -1:
        case "UNRECOGNIZED":
        default:
            return HttpMethod.UNRECOGNIZED;
    }
}
export function httpMethodToJSON(object) {
    switch (object) {
        case HttpMethod.HTTP_METHOD_UNSPECIFIED:
            return 0;
        case HttpMethod.POST:
            return 1;
        case HttpMethod.GET:
            return 2;
        case HttpMethod.HEAD:
            return 3;
        case HttpMethod.PUT:
            return 4;
        case HttpMethod.DELETE:
            return 5;
        case HttpMethod.PATCH:
            return 6;
        case HttpMethod.OPTIONS:
            return 7;
        case HttpMethod.UNRECOGNIZED:
        default:
            return -1;
    }
}
function createBaseWebbitHttpRequest() {
    return { method: 0, path: "", headers: {}, body: new Uint8Array(0) };
}
export const WebbitHttpRequest = {
    $type: "devvit.actor.webbit.WebbitHttpRequest",
    encode(message, writer = _m0.Writer.create()) {
        if (message.method !== 0) {
            writer.uint32(8).int32(message.method);
        }
        if (message.path !== "") {
            writer.uint32(18).string(message.path);
        }
        Object.entries(message.headers).forEach(([key, value]) => {
            WebbitHttpRequest_HeadersEntry.encode({ key: key, value }, writer.uint32(26).fork()).ldelim();
        });
        if (message.body.length !== 0) {
            writer.uint32(34).bytes(message.body);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseWebbitHttpRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.method = reader.int32();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.path = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    const entry3 = WebbitHttpRequest_HeadersEntry.decode(reader, reader.uint32());
                    if (entry3.value !== undefined) {
                        message.headers[entry3.key] = entry3.value;
                    }
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.body = reader.bytes();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            method: isSet(object.method) ? httpMethodFromJSON(object.method) : 0,
            path: isSet(object.path) ? globalThis.String(object.path) : "",
            headers: isObject(object.headers)
                ? Object.entries(object.headers).reduce((acc, [key, value]) => {
                    acc[key] = String(value);
                    return acc;
                }, {})
                : {},
            body: isSet(object.body) ? bytesFromBase64(object.body) : new Uint8Array(0),
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.method !== 0) {
            obj.method = httpMethodToJSON(message.method);
        }
        if (message.path !== "") {
            obj.path = message.path;
        }
        if (message.headers) {
            const entries = Object.entries(message.headers);
            if (entries.length > 0) {
                obj.headers = {};
                entries.forEach(([k, v]) => {
                    obj.headers[k] = v;
                });
            }
        }
        if (message.body.length !== 0) {
            obj.body = base64FromBytes(message.body);
        }
        return obj;
    },
    create(base) {
        return WebbitHttpRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseWebbitHttpRequest();
        message.method = object.method ?? 0;
        message.path = object.path ?? "";
        message.headers = Object.entries(object.headers ?? {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = globalThis.String(value);
            }
            return acc;
        }, {});
        message.body = object.body ?? new Uint8Array(0);
        return message;
    },
};
messageTypeRegistry.set(WebbitHttpRequest.$type, WebbitHttpRequest);
function createBaseWebbitHttpRequest_HeadersEntry() {
    return { key: "", value: "" };
}
export const WebbitHttpRequest_HeadersEntry = {
    $type: "devvit.actor.webbit.WebbitHttpRequest.HeadersEntry",
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== "") {
            writer.uint32(18).string(message.value);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseWebbitHttpRequest_HeadersEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.key = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.value = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? globalThis.String(object.key) : "",
            value: isSet(object.value) ? globalThis.String(object.value) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.key !== "") {
            obj.key = message.key;
        }
        if (message.value !== "") {
            obj.value = message.value;
        }
        return obj;
    },
    create(base) {
        return WebbitHttpRequest_HeadersEntry.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseWebbitHttpRequest_HeadersEntry();
        message.key = object.key ?? "";
        message.value = object.value ?? "";
        return message;
    },
};
messageTypeRegistry.set(WebbitHttpRequest_HeadersEntry.$type, WebbitHttpRequest_HeadersEntry);
function createBaseWebbitHttpResponse() {
    return { statusCode: 0, headers: {}, body: new Uint8Array(0) };
}
export const WebbitHttpResponse = {
    $type: "devvit.actor.webbit.WebbitHttpResponse",
    encode(message, writer = _m0.Writer.create()) {
        if (message.statusCode !== 0) {
            writer.uint32(8).int32(message.statusCode);
        }
        Object.entries(message.headers).forEach(([key, value]) => {
            WebbitHttpResponse_HeadersEntry.encode({ key: key, value }, writer.uint32(18).fork()).ldelim();
        });
        if (message.body.length !== 0) {
            writer.uint32(26).bytes(message.body);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseWebbitHttpResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.statusCode = reader.int32();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    const entry2 = WebbitHttpResponse_HeadersEntry.decode(reader, reader.uint32());
                    if (entry2.value !== undefined) {
                        message.headers[entry2.key] = entry2.value;
                    }
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.body = reader.bytes();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            statusCode: isSet(object.statusCode) ? globalThis.Number(object.statusCode) : 0,
            headers: isObject(object.headers)
                ? Object.entries(object.headers).reduce((acc, [key, value]) => {
                    acc[key] = String(value);
                    return acc;
                }, {})
                : {},
            body: isSet(object.body) ? bytesFromBase64(object.body) : new Uint8Array(0),
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.statusCode !== 0) {
            obj.statusCode = Math.round(message.statusCode);
        }
        if (message.headers) {
            const entries = Object.entries(message.headers);
            if (entries.length > 0) {
                obj.headers = {};
                entries.forEach(([k, v]) => {
                    obj.headers[k] = v;
                });
            }
        }
        if (message.body.length !== 0) {
            obj.body = base64FromBytes(message.body);
        }
        return obj;
    },
    create(base) {
        return WebbitHttpResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseWebbitHttpResponse();
        message.statusCode = object.statusCode ?? 0;
        message.headers = Object.entries(object.headers ?? {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = globalThis.String(value);
            }
            return acc;
        }, {});
        message.body = object.body ?? new Uint8Array(0);
        return message;
    },
};
messageTypeRegistry.set(WebbitHttpResponse.$type, WebbitHttpResponse);
function createBaseWebbitHttpResponse_HeadersEntry() {
    return { key: "", value: "" };
}
export const WebbitHttpResponse_HeadersEntry = {
    $type: "devvit.actor.webbit.WebbitHttpResponse.HeadersEntry",
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== "") {
            writer.uint32(18).string(message.value);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseWebbitHttpResponse_HeadersEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.key = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.value = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? globalThis.String(object.key) : "",
            value: isSet(object.value) ? globalThis.String(object.value) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.key !== "") {
            obj.key = message.key;
        }
        if (message.value !== "") {
            obj.value = message.value;
        }
        return obj;
    },
    create(base) {
        return WebbitHttpResponse_HeadersEntry.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseWebbitHttpResponse_HeadersEntry();
        message.key = object.key ?? "";
        message.value = object.value ?? "";
        return message;
    },
};
messageTypeRegistry.set(WebbitHttpResponse_HeadersEntry.$type, WebbitHttpResponse_HeadersEntry);
export const WebbitServerServiceName = "devvit.actor.webbit.WebbitServer";
export class WebbitServerClientImpl {
    constructor(rpc, opts) {
        this.service = opts?.service || WebbitServerServiceName;
        this.rpc = rpc;
        this.Request = this.Request.bind(this);
    }
    Request(request, metadata) {
        const data = WebbitHttpRequest.encode(request).finish();
        const promise = this.rpc.request(this.service, "Request", data, metadata);
        return promise.then((data) => WebbitHttpResponse.decode(_m0.Reader.create(data)));
    }
}
export const WebbitServerDefinition = {
    name: "WebbitServer",
    fullName: "devvit.actor.webbit.WebbitServer",
    methods: {
        request: {
            name: "Request",
            requestType: WebbitHttpRequest,
            requestStream: false,
            responseType: WebbitHttpResponse,
            responseStream: false,
            options: {},
        },
    },
};
function bytesFromBase64(b64) {
    if (globalThis.Buffer) {
        return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
    }
    else {
        const bin = globalThis.atob(b64);
        const arr = new Uint8Array(bin.length);
        for (let i = 0; i < bin.length; ++i) {
            arr[i] = bin.charCodeAt(i);
        }
        return arr;
    }
}
function base64FromBytes(arr) {
    if (globalThis.Buffer) {
        return globalThis.Buffer.from(arr).toString("base64");
    }
    else {
        const bin = [];
        arr.forEach((byte) => {
            bin.push(globalThis.String.fromCharCode(byte));
        });
        return globalThis.btoa(bin.join(""));
    }
}
function isObject(value) {
    return typeof value === "object" && value !== null;
}
function isSet(value) {
    return value !== null && value !== undefined;
}
