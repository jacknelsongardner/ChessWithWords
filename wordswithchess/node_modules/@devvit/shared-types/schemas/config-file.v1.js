/**
 * Warning: this file is not isomorphic. Do not functionally import this file
 * from client code.
 */
import { Scope, scopeFromJSON } from '@devvit/protos';
import jsonschema from 'jsonschema/lib/index.js';
import schema from './config-file.v1.json' with { type: 'json' };
import { defaultPostEntry, UNINITIALIZED_APP_NAME } from './constants.js';
export function parseAppConfig(str, allowUninitializedConfig) {
    if (!str)
        throw Error('config is empty');
    let json;
    try {
        json = JSON.parse(str);
    }
    catch (err) {
        throw Error(`cannot parse config JSON`, { cause: err });
    }
    return parseAppConfigJson(json, allowUninitializedConfig);
}
export function parseAppConfigJson(json, allowUninitializedConfig) {
    const unitializedSchema = {
        ...schema,
        properties: {
            ...schema.properties,
            name: {
                ...schema.properties.name,
                pattern: `${schema.properties.name.pattern}|^${UNINITIALIZED_APP_NAME}$`,
            },
        },
    };
    const ret = jsonschema.validate(json, allowUninitializedConfig ? unitializedSchema : schema);
    if (!ret.valid)
        throw new Error(ret.errors
            .map((err) => {
            if (!err.path.length && err.name === 'anyOf' && /\[subschema \d\]/.test(err.stack))
                return 'config requires property "post", "server", or "blocks".';
            if (err.stack.includes('name does not match pattern'))
                return err.stack
                    .replaceAll('instance.', '')
                    .concat('. Try running `npm create devvit` to fix your app name.');
            return err.stack.replaceAll('instance.', '').replaceAll('instance', 'config');
        })
            .join('; '));
    const instance = ret.instance;
    if (instance.$schema != null && instance.$schema !== schema.$id)
        console.warn(`Unknown schema "${instance.$schema}".`);
    return AppConfig(instance);
}
// jsonschema only supports rewrite hooks but it's easier to update defaults
// after validation when the entire config is known. Eg,
// `config.permissions.http` has a different default if `config.server` is set.
//
// Ajv supports some default application but it seems like some features are
// still missing (https://github.com/ajv-validator/ajv/issues/1158). Even if the
// feature is added, we need the defaults in the properties for documentation
// and the same dynamic default adjustments as above are required.
function AppConfig(json) {
    const partial = {
        schema: 'v1', // Always assume v1 since that's all that's supported.
        name: json.name,
        json,
    };
    if (json.media)
        partial.media = {
            dir: json.media.dir ?? schema.properties.media.properties.dir.default,
        };
    if (json.post)
        partial.post = AppPostConfig(json);
    if (json.server)
        partial.server = {
            dir: json.server.dir ?? schema.properties.server.properties.dir.default,
            entry: json.server.entry ?? schema.properties.server.properties.entry.default,
        };
    if (json.triggers && Object.keys(json.triggers).length)
        partial.triggers = json.triggers;
    if (json.blocks)
        partial.blocks = AppBlocksConfig(json);
    if (json.menu)
        partial.menu = AppMenuConfig(json);
    if (json.scheduler)
        partial.scheduler = AppSchedulerConfig(json);
    if (json.settings)
        partial.settings = AppSettingsConfig(json);
    if (json.forms)
        partial.forms = json.forms;
    if (json.marketingAssets)
        partial.marketingAssets = json.marketingAssets;
    if (json.dev) {
        partial.dev = {};
        if (json.dev.subreddit)
            partial.dev.subreddit = json.dev.subreddit;
    }
    const config = { ...partial, permissions: AppPermissionConfig(json, partial) };
    validate(config);
    // Deep copy so schema is not mutated.
    return structuredClone(config);
}
function AppSchedulerConfig(json) {
    const appSchedulerConfig = { tasks: {} };
    if (json.scheduler?.tasks) {
        for (const [name, taskSpec] of Object.entries(json.scheduler.tasks)) {
            if (typeof taskSpec === 'string') {
                // If the task is a string, it is an endpoint.
                appSchedulerConfig.tasks[name] = {
                    endpoint: taskSpec,
                };
            }
            else {
                // Otherwise, it is an object with an endpoint and optionally a cron.
                appSchedulerConfig.tasks[name] = {
                    endpoint: taskSpec.endpoint,
                    ...(taskSpec.cron
                        ? { cron: taskSpec.cron, ...(taskSpec.data ? { data: taskSpec.data } : {}) }
                        : {}),
                };
            }
        }
    }
    return appSchedulerConfig;
}
function AppPermissionConfig(json, partial) {
    return {
        http: {
            enable: json.permissions?.http?.enable ??
                (json.permissions?.http
                    ? schema.properties.permissions.properties.http.properties.enable.default
                    : false),
            domains: json.permissions?.http?.domains ??
                schema.properties.permissions.properties.http.properties.domains.default,
        },
        media: json.permissions?.media ?? schema.properties.permissions.properties.media.default,
        menu: !!partial.menu?.items?.length ||
            (json.blocks?.menu?.enable ??
                (json.blocks ? schema.properties.blocks.properties.menu.properties.enable.default : false)),
        payments: json.permissions?.payments ?? schema.properties.permissions.properties.payments.default,
        realtime: json.permissions?.realtime ?? schema.properties.permissions.properties.realtime.default,
        redis: json.permissions?.redis ??
            // Menu items call addCSRFTokenToContext() which uses Redis.
            (partial.menu?.items?.length
                ? true
                : partial.post
                    ? true
                    : schema.properties.permissions.properties.redis.default),
        reddit: {
            enable: json.permissions?.reddit?.enable ??
                (partial.post
                    ? true
                    : json.permissions?.reddit
                        ? schema.properties.permissions.properties.reddit.properties.enable.default
                        : false),
            scope: json.permissions?.reddit?.scope ??
                schema.properties.permissions.properties.reddit.properties.scope
                    .default,
            asUser: json.permissions?.reddit?.asUser?.map((x) => scopeFromJSON(x)) ??
                schema.properties.permissions.properties.reddit.properties.asUser.default,
        },
        settings: json.blocks?.settings?.enable ??
            (json.blocks
                ? schema.properties.blocks.properties.settings.properties.enable.default
                : false),
        triggers: !!partial.triggers,
    };
}
function AppPostConfig(json) {
    const dir = json.post?.dir ?? schema.properties.post.properties.dir.default;
    const defaultHeight = schema.$defs.Entrypoint.properties.height.default;
    const entrypoints = {
        [defaultPostEntry]: {
            name: defaultPostEntry,
            entry: json.post?.entrypoints?.default.entry ??
                schema.properties.post.properties.entrypoints.properties.default.properties.entry.default,
            height: json.post?.entrypoints?.default.height ?? defaultHeight,
            inline: json.post?.entrypoints?.default.inline ?? false,
        },
    };
    for (const [name, pt] of Object.entries(json.post?.entrypoints ?? {})) {
        if (name !== defaultPostEntry)
            entrypoints[name] = {
                name,
                entry: pt.entry,
                height: pt.height ?? defaultHeight,
                inline: pt.inline ?? false,
            };
    }
    return {
        dir,
        entrypoints,
    };
}
function AppBlocksConfig(json) {
    return {
        entry: json.blocks?.entry ?? schema.properties.blocks.properties.entry.default,
    };
}
function AppMenuConfig(json) {
    const items = [];
    for (const item of json.menu?.items ?? []) {
        items.push({
            label: item.label,
            description: item.description ?? '',
            forUserType: item.forUserType ?? 'moderator',
            postFilter: item.postFilter ?? 'none',
            location: Array.isArray(item.location) ? item.location : [item.location],
            endpoint: item.endpoint,
        });
    }
    return { items };
}
function AppSettingsConfig(json) {
    const appSettingsConfig = {};
    if (json.settings?.global) {
        appSettingsConfig.global = {};
        for (const [name, setting] of Object.entries(json.settings.global)) {
            appSettingsConfig.global[name] = {
                ...setting,
                name: name,
            };
        }
    }
    if (json.settings?.subreddit) {
        appSettingsConfig.subreddit = {};
        for (const [name, setting] of Object.entries(json.settings.subreddit)) {
            appSettingsConfig.subreddit[name] = {
                ...setting,
                name: name,
            };
        }
    }
    return appSettingsConfig;
}
/** @internal */
export function validate(config) {
    const errs = [];
    if (config.menu?.items?.length && !config.permissions.redis)
        errs.push('`config.menu.items` requires `config.permissions.redis` to be enabled');
    // If there are any select settings, their default values must be in the options,
    // and if it's not a multi-select, the default value must be a single string.
    const settingValues = [
        ...Object.values(config.settings?.global ?? {}),
        ...Object.values(config.settings?.subreddit ?? {}),
    ];
    for (const setting of settingValues) {
        if (setting.type === 'select' && setting.defaultValue) {
            if (!setting.options.some((option) => option.value === setting.defaultValue))
                errs.push(`Setting "${setting.name}" default value "${setting.defaultValue}" is not in
          options "${setting.options.map((option) => option.value).join(', ')}"`);
        }
        if (setting.type === 'multiSelect' && setting.defaultValue) {
            if (!setting.defaultValue.every((value) => setting.options.some((option) => option.value === value)))
                errs.push(`Setting "${setting.name}" default values "${setting.defaultValue.join(', ')}" are not in options "${setting.options.map((option) => option.value).join(', ')}"`);
        }
    }
    if (errs.length)
        throw Error(`${errs.join('; ')}.`);
}
