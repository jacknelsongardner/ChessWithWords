var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _a, _ModNote_fromProto, _ModNote_metadata_get;
import { context } from '@devvit/server';
import { assertNonNull } from '@devvit/shared-types/NonNull.js';
import { asTid, T1, T2, T3, T5 } from '@devvit/shared-types/tid.js';
import { getRedditApiPlugins } from '../plugin.js';
import { Listing } from './Listing.js';
export class ModNote {
    /**
     * @internal
     */
    constructor() { }
    /** @internal */
    static get(options) {
        const client = getRedditApiPlugins().ModNote;
        return new Listing({
            hasMore: true,
            before: options.before,
            limit: options.limit,
            pageSize: options.limit,
            fetch: async (fetchOptions) => {
                const protoRes = await client.GetNotes({
                    subreddit: options.subreddit,
                    user: options.user,
                    filter: options.filter,
                    before: fetchOptions.before,
                    limit: fetchOptions.limit,
                }, __classPrivateFieldGet(this, _a, "a", _ModNote_metadata_get));
                return {
                    children: protoRes.modNotes?.map((protoModNote) => __classPrivateFieldGet(this, _a, "m", _ModNote_fromProto).call(this, protoModNote)) || [],
                    // if the response says that there are no more pages, then we should set before to undefined
                    // to prevent more requests from being made
                    before: protoRes.hasNextPage ? protoRes.endCursor : undefined,
                    hasMore: protoRes.hasNextPage,
                };
            },
        });
    }
    /** @internal */
    static async delete(options) {
        const client = getRedditApiPlugins().ModNote;
        const { deleted } = await client.DeleteNotes(options, __classPrivateFieldGet(this, _a, "a", _ModNote_metadata_get));
        return !!deleted;
    }
    /** @internal */
    static async add(options) {
        const client = getRedditApiPlugins().ModNote;
        const res = await client.PostNotes(options, __classPrivateFieldGet(this, _a, "a", _ModNote_metadata_get));
        if (!res?.created) {
            throw new Error('Failed to create mod note');
        }
        return __classPrivateFieldGet(this, _a, "m", _ModNote_fromProto).call(this, res.created);
    }
    /** @internal */
    static async addRemovalNote(options) {
        const client = getRedditApiPlugins().ModNote;
        await client.PostRemovalNote(options, __classPrivateFieldGet(this, _a, "a", _ModNote_metadata_get));
    }
}
_a = ModNote, _ModNote_fromProto = function _ModNote_fromProto(protoModNote) {
    // check that all required fields of protoModNote needed to create a ModNote are present
    assertNonNull(protoModNote.id, 'Mod note ID is null or undefined');
    assertNonNull(protoModNote.createdAt, 'Mod note createdAt is null or undefined');
    assertNonNull(protoModNote.type, 'Mod note type is null or undefined');
    assertNonNull(protoModNote.subreddit, 'Mod note subreddit is null or undefined');
    assertNonNull(protoModNote.subredditId, 'Mod note subredditId is null or undefined');
    assertNonNull(protoModNote.operator, 'Mod note operator is null or undefined');
    assertNonNull(protoModNote.operatorId, 'Mod note operatorId is null or undefined');
    assertNonNull(protoModNote.user, 'Mod note user is null or undefined');
    assertNonNull(protoModNote.userId, 'Mod note userId is null or undefined');
    assertNonNull(protoModNote.userNoteData, 'Mod note userNote is null or undefined');
    assertNonNull(protoModNote.modActionData, 'Mod note modAction is null or undefined');
    return {
        id: protoModNote.id,
        user: {
            id: T2(protoModNote.userId ?? ''),
            name: protoModNote.user,
        },
        subreddit: {
            id: T5(protoModNote.subredditId ?? ''),
            name: protoModNote.subreddit,
        },
        operator: {
            id: T2(protoModNote.operatorId ?? ''),
            name: protoModNote.operator,
        },
        createdAt: new Date(protoModNote.createdAt * 1000), // convert to ms
        userNote: {
            note: protoModNote.userNoteData?.note,
            redditId: protoModNote.userNoteData?.redditId
                ? asTid(protoModNote.userNoteData?.redditId)
                : undefined,
            label: protoModNote.userNoteData?.label,
        },
        type: protoModNote.type,
    };
}, _ModNote_metadata_get = function _ModNote_metadata_get() {
    return context.metadata;
};
