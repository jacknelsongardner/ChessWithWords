var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _a, _Post_id, _Post_authorId, _Post_authorName, _Post_createdAt, _Post_subredditId, _Post_subredditName, _Post_permalink, _Post_title, _Post_body, _Post_bodyHtml, _Post_url, _Post_score, _Post_numberOfComments, _Post_numberOfReports, _Post_thumbnail, _Post_approved, _Post_approvedAtUtc, _Post_bannedAtUtc, _Post_spam, _Post_stickied, _Post_removed, _Post_removedBy, _Post_removedByCategory, _Post_archived, _Post_edited, _Post_locked, _Post_nsfw, _Post_quarantined, _Post_spoiler, _Post_hidden, _Post_ignoringReports, _Post_distinguishedBy, _Post_flair, _Post_secureMedia, _Post_modReportReasons, _Post_userReportReasons, _Post_gallery, _Post_metadata_get;
import { Block, DevvitPostData, UIResponse } from '@devvit/protos';
import { SetCustomPostPreviewRequest_BodyType } from '@devvit/protos/json/devvit/plugin/redditapi/linksandcomments/linksandcomments_msg.js';
import {} from '@devvit/protos/json/devvit/ui/effects/web_view/v1alpha/context.js';
import { Scope } from '@devvit/protos/json/reddit/devvit/app_permission/v1/app_permission.js';
import { BlocksHandler } from '@devvit/public-api/devvit/internals/blocks/handler/BlocksHandler.js';
import { context } from '@devvit/server';
import { assertNonNull } from '@devvit/shared-types/NonNull.js';
import { RichTextBuilder } from '@devvit/shared-types/richtext/RichTextBuilder.js';
import { defaultPostEntry } from '@devvit/shared-types/schemas/constants.js';
import { isT3, T2, T3, T5 } from '@devvit/shared-types/tid.js';
import { Loading } from '@devvit/splash/loading.js';
import {} from '@devvit/splash/splash.js';
import { backgroundUrl } from '@devvit/splash/utils/assets.js';
import { assertUserScope, RunAs } from '../common.js';
import { GraphQL } from '../graphql/GraphQL.js';
import { makeGettersEnumerable } from '../helpers/makeGettersEnumerable.js';
import { richtextToString } from '../helpers/richtextToString.js';
import { getCustomPostRichTextFallback } from '../helpers/textFallbackToRichtext.js';
import { getRedditApiPlugins, getUserActionsPlugin } from '../plugin.js';
import { Comment } from './Comment.js';
import { Listing } from './Listing.js';
import { ModNote } from './ModNote.js';
import { User } from './User.js';
export const GalleryMediaStatus = {
    UNKNOWN: 0,
    VALID: 1,
    FAILED: 2,
};
export class Post {
    /**
     * @internal
     */
    constructor(data) {
        _Post_id.set(this, void 0);
        _Post_authorId.set(this, void 0);
        _Post_authorName.set(this, void 0);
        _Post_createdAt.set(this, void 0);
        _Post_subredditId.set(this, void 0);
        _Post_subredditName.set(this, void 0);
        _Post_permalink.set(this, void 0);
        _Post_title.set(this, void 0);
        _Post_body.set(this, void 0);
        _Post_bodyHtml.set(this, void 0);
        _Post_url.set(this, void 0);
        _Post_score.set(this, void 0);
        _Post_numberOfComments.set(this, void 0);
        _Post_numberOfReports.set(this, void 0);
        _Post_thumbnail.set(this, void 0);
        _Post_approved.set(this, void 0);
        _Post_approvedAtUtc.set(this, void 0);
        _Post_bannedAtUtc.set(this, void 0);
        _Post_spam.set(this, void 0);
        _Post_stickied.set(this, void 0);
        _Post_removed.set(this, void 0);
        _Post_removedBy.set(this, void 0);
        _Post_removedByCategory.set(this, void 0);
        _Post_archived.set(this, void 0);
        _Post_edited.set(this, void 0);
        _Post_locked.set(this, void 0);
        _Post_nsfw.set(this, void 0);
        _Post_quarantined.set(this, void 0);
        _Post_spoiler.set(this, void 0);
        _Post_hidden.set(this, void 0);
        _Post_ignoringReports.set(this, void 0);
        _Post_distinguishedBy.set(this, void 0);
        _Post_flair.set(this, void 0);
        _Post_secureMedia.set(this, void 0);
        _Post_modReportReasons.set(this, void 0);
        _Post_userReportReasons.set(this, void 0);
        _Post_gallery.set(this, void 0);
        makeGettersEnumerable(this);
        assertNonNull(data.id, 'Post is missing id');
        assertNonNull(data.title, 'Post is missing title');
        assertNonNull(data.createdUtc, 'Post is missing created date');
        assertNonNull(data.author, 'Post is missing author name');
        assertNonNull(data.subreddit, 'Post is missing subreddit name');
        assertNonNull(data.subredditId, 'Post is missing subreddit id');
        assertNonNull(data.url, 'Post is missing url');
        assertNonNull(data.permalink, 'Post is missing permalink');
        __classPrivateFieldSet(this, _Post_id, `t3_${data.id}`, "f");
        __classPrivateFieldSet(this, _Post_authorName, data.author, "f");
        __classPrivateFieldSet(this, _Post_authorId, data.authorFullname ? T2(data.authorFullname) : undefined, "f");
        __classPrivateFieldSet(this, _Post_subredditId, T5(data.subredditId), "f");
        __classPrivateFieldSet(this, _Post_subredditName, data.subreddit, "f");
        __classPrivateFieldSet(this, _Post_score, data.score ?? 0, "f");
        __classPrivateFieldSet(this, _Post_numberOfComments, data.numComments ?? 0, "f");
        __classPrivateFieldSet(this, _Post_numberOfReports, data.numReports ?? 0, "f");
        const createdAt = new Date(0);
        createdAt.setUTCSeconds(data.createdUtc);
        __classPrivateFieldSet(this, _Post_createdAt, createdAt, "f");
        __classPrivateFieldSet(this, _Post_title, data.title, "f");
        __classPrivateFieldSet(this, _Post_body, data.selftext, "f");
        __classPrivateFieldSet(this, _Post_bodyHtml, data.selftextHtml, "f");
        __classPrivateFieldSet(this, _Post_url, data.url, "f");
        __classPrivateFieldSet(this, _Post_permalink, data.permalink, "f");
        if (data.thumbnail &&
            data.thumbnail !== 'self' &&
            data.thumbnail !== 'nsfw' &&
            data.thumbnailHeight != null &&
            data.thumbnailWidth != null) {
            __classPrivateFieldSet(this, _Post_thumbnail, {
                url: data.thumbnail,
                height: data.thumbnailHeight,
                width: data.thumbnailWidth,
            }, "f");
        }
        __classPrivateFieldSet(this, _Post_approved, data.approved ?? false, "f");
        __classPrivateFieldSet(this, _Post_approvedAtUtc, data.approvedAtUtc ?? 0, "f");
        __classPrivateFieldSet(this, _Post_bannedAtUtc, data.bannedAtUtc ?? 0, "f");
        __classPrivateFieldSet(this, _Post_removed, data.removed ?? false, "f");
        __classPrivateFieldSet(this, _Post_removedBy, data.removedBy, "f");
        __classPrivateFieldSet(this, _Post_removedByCategory, data.removedByCategory, "f");
        __classPrivateFieldSet(this, _Post_spam, data.spam ?? false, "f");
        __classPrivateFieldSet(this, _Post_stickied, data.stickied ?? false, "f");
        __classPrivateFieldSet(this, _Post_archived, data.archived ?? false, "f");
        __classPrivateFieldSet(this, _Post_edited, data.edited ?? false, "f");
        __classPrivateFieldSet(this, _Post_locked, data.locked ?? false, "f");
        __classPrivateFieldSet(this, _Post_nsfw, data.over18 ?? false, "f");
        __classPrivateFieldSet(this, _Post_quarantined, data.quarantine ?? false, "f");
        __classPrivateFieldSet(this, _Post_spoiler, data.spoiler, "f");
        __classPrivateFieldSet(this, _Post_hidden, data.hidden ?? false, "f");
        __classPrivateFieldSet(this, _Post_ignoringReports, data.ignoreReports ?? false, "f");
        __classPrivateFieldSet(this, _Post_distinguishedBy, data.distinguished, "f");
        __classPrivateFieldSet(this, _Post_secureMedia, data.secureMedia, "f");
        __classPrivateFieldSet(this, _Post_modReportReasons, (data.modReports ?? []).map(([reason]) => reason), "f");
        __classPrivateFieldSet(this, _Post_userReportReasons, (data.userReports ?? []).map(([reason]) => reason), "f");
        if (data.linkFlairBackgroundColor ||
            data.linkFlairCssClass ||
            data.linkFlairText ||
            data.linkFlairType ||
            data.linkFlairTemplateId ||
            data.linkFlairRichtext ||
            data.linkFlairTextColor) {
            __classPrivateFieldSet(this, _Post_flair, {
                backgroundColor: data.linkFlairBackgroundColor,
                cssClass: data.linkFlairCssClass,
                text: data.linkFlairText,
                type: data.linkFlairType,
                templateId: data.linkFlairTemplateId,
                // Map linkFlairRichtext[] into the objects with more user-friendly property names
                richtext: (data.linkFlairRichtext ?? []).map(({ e, t, a, u }) => ({
                    elementType: e,
                    text: t,
                    emojiRef: a,
                    url: u,
                })),
                textColor: data.linkFlairTextColor,
            }, "f");
        }
        if (data.gallery) {
            __classPrivateFieldSet(this, _Post_gallery, data.gallery.map((item) => ({
                status: item.status,
                url: item.url,
                height: item.height,
                width: item.width,
            })), "f");
        }
        else {
            __classPrivateFieldSet(this, _Post_gallery, [], "f");
        }
    }
    get id() {
        return __classPrivateFieldGet(this, _Post_id, "f");
    }
    get authorId() {
        return __classPrivateFieldGet(this, _Post_authorId, "f");
    }
    get authorName() {
        return __classPrivateFieldGet(this, _Post_authorName, "f");
    }
    get subredditId() {
        return __classPrivateFieldGet(this, _Post_subredditId, "f");
    }
    get subredditName() {
        return __classPrivateFieldGet(this, _Post_subredditName, "f");
    }
    get permalink() {
        return __classPrivateFieldGet(this, _Post_permalink, "f");
    }
    get title() {
        return __classPrivateFieldGet(this, _Post_title, "f");
    }
    get body() {
        return __classPrivateFieldGet(this, _Post_body, "f");
    }
    get bodyHtml() {
        return __classPrivateFieldGet(this, _Post_bodyHtml, "f");
    }
    get url() {
        return __classPrivateFieldGet(this, _Post_url, "f");
    }
    get thumbnail() {
        return __classPrivateFieldGet(this, _Post_thumbnail, "f");
    }
    get createdAt() {
        return __classPrivateFieldGet(this, _Post_createdAt, "f");
    }
    get score() {
        return __classPrivateFieldGet(this, _Post_score, "f");
    }
    get numberOfComments() {
        return __classPrivateFieldGet(this, _Post_numberOfComments, "f");
    }
    get numberOfReports() {
        return __classPrivateFieldGet(this, _Post_numberOfReports, "f");
    }
    get approved() {
        return __classPrivateFieldGet(this, _Post_approved, "f");
    }
    get approvedAtUtc() {
        return __classPrivateFieldGet(this, _Post_approvedAtUtc, "f");
    }
    get bannedAtUtc() {
        return __classPrivateFieldGet(this, _Post_bannedAtUtc, "f");
    }
    get spam() {
        return __classPrivateFieldGet(this, _Post_spam, "f");
    }
    get stickied() {
        return __classPrivateFieldGet(this, _Post_stickied, "f");
    }
    get removed() {
        return __classPrivateFieldGet(this, _Post_removed, "f");
    }
    /**
     * Who removed this object (username)
     */
    get removedBy() {
        return __classPrivateFieldGet(this, _Post_removedBy, "f");
    }
    /**
     * who/what removed this object. It will return one of the following:
     * - "anti_evil_ops": object is removed by a aeops member
     * - "author": object is removed by author of the post
     * - "automod_filtered": object is filtered by automod
     * - "community_ops": object is removed by a community team member
     * - "content_takedown": object is removed due to content violation
     * - "copyright_takedown": object is removed due to copyright violation
     * - "deleted": object is deleted
     * - "moderator": object is removed by a mod of the sub
     * - "reddit": object is removed by anyone else
     * - undefined: object is not removed
     */
    get removedByCategory() {
        return __classPrivateFieldGet(this, _Post_removedByCategory, "f");
    }
    get archived() {
        return __classPrivateFieldGet(this, _Post_archived, "f");
    }
    get edited() {
        return __classPrivateFieldGet(this, _Post_edited, "f");
    }
    get locked() {
        return __classPrivateFieldGet(this, _Post_locked, "f");
    }
    get nsfw() {
        return __classPrivateFieldGet(this, _Post_nsfw, "f");
    }
    get quarantined() {
        return __classPrivateFieldGet(this, _Post_quarantined, "f");
    }
    get spoiler() {
        return __classPrivateFieldGet(this, _Post_spoiler, "f");
    }
    get hidden() {
        return __classPrivateFieldGet(this, _Post_hidden, "f");
    }
    get ignoringReports() {
        return __classPrivateFieldGet(this, _Post_ignoringReports, "f");
    }
    get distinguishedBy() {
        return __classPrivateFieldGet(this, _Post_distinguishedBy, "f");
    }
    get comments() {
        return Comment.getComments({
            postId: this.id,
        });
    }
    get flair() {
        return __classPrivateFieldGet(this, _Post_flair, "f");
    }
    get secureMedia() {
        return __classPrivateFieldGet(this, _Post_secureMedia, "f");
    }
    get userReportReasons() {
        return __classPrivateFieldGet(this, _Post_userReportReasons, "f");
    }
    get modReportReasons() {
        return __classPrivateFieldGet(this, _Post_modReportReasons, "f");
    }
    /**
     * Get the media in the post. Empty if the post doesn't have any media.
     */
    get gallery() {
        return __classPrivateFieldGet(this, _Post_gallery, "f");
    }
    toJSON() {
        return {
            id: this.id,
            authorId: this.authorId,
            authorName: this.authorName,
            subredditId: this.subredditId,
            subredditName: this.subredditName,
            permalink: this.permalink,
            title: this.title,
            body: this.body,
            bodyHtml: this.bodyHtml,
            url: this.url,
            thumbnail: this.thumbnail,
            score: this.score,
            numberOfComments: this.numberOfComments,
            numberOfReports: this.numberOfReports,
            createdAt: this.createdAt,
            approved: this.approved,
            spam: this.spam,
            stickied: this.stickied,
            removed: this.removed,
            removedBy: __classPrivateFieldGet(this, _Post_removedBy, "f"),
            removedByCategory: __classPrivateFieldGet(this, _Post_removedByCategory, "f"),
            archived: this.archived,
            edited: this.edited,
            locked: this.locked,
            nsfw: this.nsfw,
            quarantined: this.quarantined,
            spoiler: this.spoiler,
            hidden: this.hidden,
            ignoringReports: this.ignoringReports,
            distinguishedBy: this.distinguishedBy,
            flair: this.flair,
            secureMedia: this.secureMedia,
            modReportReasons: __classPrivateFieldGet(this, _Post_modReportReasons, "f"),
            userReportReasons: __classPrivateFieldGet(this, _Post_userReportReasons, "f"),
        };
    }
    isApproved() {
        return __classPrivateFieldGet(this, _Post_approved, "f");
    }
    isSpam() {
        return __classPrivateFieldGet(this, _Post_spam, "f");
    }
    isStickied() {
        return __classPrivateFieldGet(this, _Post_stickied, "f");
    }
    isRemoved() {
        return __classPrivateFieldGet(this, _Post_removed, "f");
    }
    isArchived() {
        return __classPrivateFieldGet(this, _Post_archived, "f");
    }
    isEdited() {
        return __classPrivateFieldGet(this, _Post_edited, "f");
    }
    isLocked() {
        return __classPrivateFieldGet(this, _Post_locked, "f");
    }
    isNsfw() {
        return __classPrivateFieldGet(this, _Post_nsfw, "f");
    }
    isQuarantined() {
        return __classPrivateFieldGet(this, _Post_quarantined, "f");
    }
    isSpoiler() {
        return __classPrivateFieldGet(this, _Post_spoiler, "f");
    }
    isHidden() {
        return __classPrivateFieldGet(this, _Post_hidden, "f");
    }
    isIgnoringReports() {
        return __classPrivateFieldGet(this, _Post_ignoringReports, "f");
    }
    isDistinguishedBy() {
        return __classPrivateFieldGet(this, _Post_distinguishedBy, "f");
    }
    async edit(opts) {
        const newPost = await _a.edit({
            id: this.id,
            ...opts,
        });
        __classPrivateFieldSet(this, _Post_body, newPost.body, "f");
        __classPrivateFieldSet(this, _Post_edited, newPost.edited, "f");
    }
    /**
     * Set the suggested sort for comments on a Post.
     *
     * @throws {Error} Throws an error if the suggested sort could not be set.
     * @example
     * ```ts
     * const post = await reddit.getPostById(context.postId);
     * await post.setSuggestedCommentSort("NEW");
     * ```
     */
    async setSuggestedCommentSort(suggestedSort) {
        await _a.setSuggestedCommentSort({
            id: this.id,
            subredditId: __classPrivateFieldGet(this, _Post_subredditId, "f"),
            suggestedSort,
        });
    }
    /**
     * Get the postData for the post.
     *
     * @example
     * ```ts
     * const post = await reddit.getPostById(context.postId);
     * const postData = await post.getPostData();
     * ```
     */
    async getPostData() {
        const devvitPostData = await _a.getDevvitPostData(this.id);
        return devvitPostData?.developerData;
    }
    /**
     * Set the postData on a custom post.
     *
     * @param postData - Represents the postData to be set, eg: { currentScore: 55, secretWord: 'barbeque' }
     * @throws {Error} Throws an error if the postData could not be set.
     * @example
     * ```ts
     * const post = await reddit.getPostById(context.postId);
     * await post.setPostData({
     *   currentScore: 55,
     *   secretWord: 'barbeque',
     * });
     * ```
     */
    async setPostData(postData) {
        const prev = await _a.getDevvitPostData(this.id);
        await _a.setPostData({ postId: this.id, postData: { ...prev, developerData: postData } });
    }
    /**
     * Set the launch and loading screens of a custom post.
     *
     * @example
     * ```ts
     * const post = await reddit.getPostById(context.postId);
     * await post.setSplash({ appDisplayName: "Pixelary" });
     * ```
     */
    async setSplash(opts) {
        const prev = await _a.getDevvitPostData(this.id);
        const config = getConfig();
        const entry = getEntry(config, opts?.entry);
        const splash = SplashPostData(config, entry, opts, this.title);
        const [, richtextJson] = await Promise.all([
            _a.setPostData({ postId: this.id, postData: { ...prev, splash } }),
            renderLoadingAsRichTextJson({
                appDisplayName: splash.appDisplayName,
                backgroundUri: splash.backgroundUri,
                height: entry.height,
            }, context.metadata),
        ]);
        const client = getRedditApiPlugins().LinksAndComments;
        await client.SetCustomPostPreview({
            thingId: this.id,
            bodyType: SetCustomPostPreviewRequest_BodyType.BLOCKS,
            blocksRenderContent: richtextJson,
        }, context.metadata);
    }
    /**
     * Set a text fallback for the custom post
     *
     * @param opts - A text or a richtext to render in a fallback
     * @throws {Error} Throws an error if the fallback could not be set.
     * @example
     * ```ts
     * // from a menu action, form, scheduler, trigger, custom post click event, etc
     * const newTextFallback = { text: 'This is an updated text fallback' };
     * const post = await context.reddit.getPostById(context.postId);
     * await post.setTextFallback(newTextFallback);
     * ```
     */
    async setTextFallback(opts) {
        const newPost = await _a.setTextFallback(opts, this.id);
        __classPrivateFieldSet(this, _Post_body, newPost.body, "f");
        __classPrivateFieldSet(this, _Post_edited, newPost.edited, "f");
    }
    async addComment(opts) {
        return Comment.submit({
            id: this.id,
            ...opts,
        });
    }
    async delete() {
        const appUsername = context.appName;
        if (appUsername !== __classPrivateFieldGet(this, _Post_authorName, "f")) {
            throw new Error(`App '${appUsername}' is not the author of Post ${this.id}, delete not allowed.`);
        }
        return _a.delete(this.id);
    }
    async approve() {
        await _a.approve(this.id);
        __classPrivateFieldSet(this, _Post_approved, true, "f");
        __classPrivateFieldSet(this, _Post_removed, false, "f");
    }
    async remove(isSpam = false) {
        await _a.remove(this.id, isSpam);
        __classPrivateFieldSet(this, _Post_removed, true, "f");
        __classPrivateFieldSet(this, _Post_spam, isSpam, "f");
        __classPrivateFieldSet(this, _Post_approved, false, "f");
    }
    async lock() {
        await _a.lock(this.id);
        __classPrivateFieldSet(this, _Post_locked, true, "f");
    }
    async unlock() {
        await _a.unlock(this.id);
        __classPrivateFieldSet(this, _Post_locked, false, "f");
    }
    async hide() {
        await _a.hide(this.id);
        __classPrivateFieldSet(this, _Post_hidden, true, "f");
    }
    async unhide() {
        await _a.unhide(this.id);
        __classPrivateFieldSet(this, _Post_hidden, false, "f");
    }
    async markAsNsfw() {
        await _a.markAsNsfw(this.id);
        __classPrivateFieldSet(this, _Post_nsfw, true, "f");
    }
    async unmarkAsNsfw() {
        await _a.unmarkAsNsfw(this.id);
        __classPrivateFieldSet(this, _Post_nsfw, false, "f");
    }
    async markAsSpoiler() {
        await _a.markAsSpoiler(this.id);
        __classPrivateFieldSet(this, _Post_spoiler, true, "f");
    }
    async unmarkAsSpoiler() {
        await _a.unmarkAsSpoiler(this.id);
        __classPrivateFieldSet(this, _Post_spoiler, false, "f");
    }
    async sticky(position) {
        await _a.sticky(this.id, position);
    }
    async unsticky() {
        await _a.unsticky(this.id);
    }
    async distinguish() {
        const { distinguishedBy } = await _a.distinguish(this.id, false);
        __classPrivateFieldSet(this, _Post_distinguishedBy, distinguishedBy, "f");
    }
    async distinguishAsAdmin() {
        const { distinguishedBy } = await _a.distinguish(this.id, true);
        __classPrivateFieldSet(this, _Post_distinguishedBy, distinguishedBy, "f");
    }
    async undistinguish() {
        const { distinguishedBy } = await _a.undistinguish(this.id);
        __classPrivateFieldSet(this, _Post_distinguishedBy, distinguishedBy, "f");
    }
    async ignoreReports() {
        await _a.ignoreReports(this.id);
        __classPrivateFieldSet(this, _Post_ignoringReports, true, "f");
    }
    async unignoreReports() {
        await _a.unignoreReports(this.id);
        __classPrivateFieldSet(this, _Post_ignoringReports, false, "f");
    }
    async getAuthor() {
        return User.getByUsername(__classPrivateFieldGet(this, _Post_authorName, "f"));
    }
    async crosspost(opts) {
        return _a.crosspost({ ...opts, postId: this.id });
    }
    /**
     * Add a mod note for why the post was removed
     *
     * @param options.reasonId id of a Removal Reason - you can leave this as an empty string if you don't have one
     * @param options.modNote the reason for removal (maximum 100 characters) (optional)
     * @returns
     */
    addRemovalNote(opts) {
        return ModNote.addRemovalNote({ itemIds: [__classPrivateFieldGet(this, _Post_id, "f")], ...opts });
    }
    /**
     * Get a thumbnail that contains a preview image and also contains a blurred preview for
     * NSFW images. The thumbnail returned has higher resolution than Post.thumbnail.
     * Returns undefined if the post doesn't have a thumbnail
     *
     * @returns {EnrichedThumbnail | undefined}
     * @throws {Error} Throws an error if the thumbnail could not be fetched
     * @example
     * ```ts
     * // from a menu action, form, scheduler, trigger, custom post click event, etc
     * const post = await context.reddit.getPostById(context.postId);
     * const enrichedThumbnail = await post.getEnrichedThumbnail();
     * ```
     */
    async getEnrichedThumbnail() {
        return getThumbnailV2({ id: this.id });
    }
    // TODO: flair methods
    /** @internal */
    static async getById(id) {
        const client = getRedditApiPlugins().LinksAndComments;
        const postId = isT3(id) ? id : `t3_${id}`;
        const rsp = await client.Info({
            subreddits: [],
            thingIds: [postId],
        }, __classPrivateFieldGet(this, _a, "a", _Post_metadata_get));
        if (!rsp.data?.children?.length)
            throw Error(`no post ${id}`);
        const postData = rsp.data.children[0];
        if (!postData?.data)
            throw Error(`no post ${id}`);
        return new _a(postData.data);
    }
    /** @internal */
    static async submit(opts) {
        const runAsType = RunAs[opts.runAs ?? 'APP'];
        const client = runAsType === RunAs.USER ? getUserActionsPlugin() : getRedditApiPlugins().LinksAndComments;
        if (runAsType === RunAs.USER) {
            assertUserScope(Scope.SUBMIT_POST);
        }
        const rsp = await client.Submit({
            kind: 'kind' in opts ? opts.kind : 'url' in opts ? 'link' : 'self',
            sr: opts.subredditName,
            richtextJson: 'richtext' in opts ? richtextToString(opts.richtext) : undefined,
            ...opts,
            runAs: runAsType,
        }, __classPrivateFieldGet(this, _a, "a", _Post_metadata_get));
        // Post Id might not be present as image/video post creation can happen asynchronously
        const isAllowedMediaType = 'kind' in opts && ['image', 'video', 'videogif'].includes(opts.kind);
        if (isAllowedMediaType && !rsp.json?.data?.id) {
            if (opts.kind === 'image' && 'imageUrls' in opts) {
                throw new Error(`Image post type with ${opts.imageUrls} is being created asynchronously and should be updated in the subreddit soon.`);
            }
            else if ('videoPosterUrl' in opts) {
                throw new Error(`Post of ${opts.kind} type with ${opts.videoPosterUrl} is being created asynchronously and should be updated in the subreddit soon.`);
            }
        }
        return postFromSubmitResponse(rsp);
    }
    /** @internal */
    static async submitCustomPost(opts) {
        const runAsType = RunAs[opts.runAs ?? 'APP'];
        const client = runAsType === RunAs.USER ? getUserActionsPlugin() : getRedditApiPlugins().LinksAndComments;
        if (runAsType === RunAs.USER && !opts.userGeneratedContent) {
            throw Error('userGeneratedContent must be set when `runAs` is `USER`');
        }
        if (runAsType === RunAs.USER) {
            assertUserScope(Scope.SUBMIT_POST);
        }
        const config = getConfig();
        const entry = getEntry(config, opts.splash?.entry);
        const splash = SplashPostData(config, entry, opts.splash, opts.title);
        const richtextJson = await renderLoadingAsRichTextJson({
            appDisplayName: splash.appDisplayName,
            backgroundUri: splash.backgroundUri,
            height: entry.height,
        }, __classPrivateFieldGet(this, _a, "a", _Post_metadata_get));
        const richtextFallback = opts.textFallback
            ? getCustomPostRichTextFallback(opts.textFallback)
            : '';
        const userGeneratedContent = opts.userGeneratedContent
            ? {
                text: opts.userGeneratedContent.text ?? '',
                imageUrls: opts.userGeneratedContent.imageUrls ?? [],
            }
            : undefined;
        const postData = {
            developerData: opts.postData,
            splash,
        };
        const rsp = await client.SubmitCustomPost({
            kind: 'custom',
            sr: opts.subredditName,
            richtextJson,
            richtextFallback,
            flairId: opts.flairId,
            flairText: opts.flairText,
            nsfw: opts.nsfw,
            sendreplies: opts.sendreplies,
            spoiler: opts.spoiler,
            title: opts.title,
            userGeneratedContent,
            runAs: runAsType,
            postData,
        }, __classPrivateFieldGet(this, _a, "a", _Post_metadata_get));
        return postFromSubmitResponse(rsp);
    }
    /** @internal */
    static async crosspost(opts) {
        const { runAs = 'APP' } = opts;
        const runAsType = RunAs[runAs];
        const client = runAsType === RunAs.USER ? getUserActionsPlugin() : getRedditApiPlugins().LinksAndComments;
        const { postId, subredditName, ...rest } = opts;
        if (runAsType === RunAs.USER) {
            assertUserScope(Scope.SUBMIT_POST);
        }
        const rsp = await client.Submit({
            kind: 'crosspost',
            sr: subredditName,
            crosspostFullname: postId,
            ...rest,
            runAs: runAsType,
        }, __classPrivateFieldGet(this, _a, "a", _Post_metadata_get));
        return postFromSubmitResponse(rsp);
    }
    /** @internal */
    static async edit(opts) {
        const client = getRedditApiPlugins().LinksAndComments;
        const { id } = opts;
        let richtextString;
        if ('richtext' in opts) {
            richtextString = richtextToString(opts.richtext);
        }
        const rsp = await client.EditUserText({
            thingId: id,
            text: 'text' in opts ? opts.text : '',
            richtextJson: richtextString,
            runAs: RunAs.APP,
        }, __classPrivateFieldGet(this, _a, "a", _Post_metadata_get));
        if (rsp.json?.errors?.length)
            throw Error(`post ${id} edit failed: ${rsp.json?.errors.join(', ')}`);
        // The LinksAndComments.EditUserText response is wrong and assumes that
        // the API is only used to for comments so we fetch the new post here.
        return _a.getById(id);
    }
    /** @internal */
    static async setSuggestedCommentSort(opts) {
        const operationName = 'SetSuggestedSort';
        const persistedQueryHash = 'cf6052acc7fefaa65b710625b81dba8041f258313aafe9730e2a3dc855e5d10d';
        const rsp = await GraphQL.query(operationName, persistedQueryHash, {
            input: {
                subredditId: opts.subredditId,
                postId: opts.id,
                sort: opts.suggestedSort,
            },
        });
        if (!rsp.data?.setSuggestedSort?.ok)
            throw Error(`set post ${opts.id} suggested comment sort failed: ${rsp.errors.map((err) => `error ${err.code} (${err.message})`).join('; ')}`);
    }
    /** @internal */
    static async getDevvitPostData(id) {
        const operationName = 'GetDevvitPostData';
        const persistedQueryHash = 'd349c9bee385336e44837c4a041d4b366fa32f16121cef7f12e1e3f230340696';
        const rsp = await GraphQL.query(operationName, persistedQueryHash, {
            id,
        });
        // to-do: why is postInfoById a `Record<string, any>`?
        if (rsp.data?.postInfoById?.errors?.length) {
            throw new Error(`Failed to get devvit post data due to errors: ${rsp.data?.postInfoById?.errors.join(', ')}`);
        }
        // GQL returns postData as a JSON string
        const devvitPostData = rsp.data?.postInfoById?.devvit?.postData;
        if (!devvitPostData) {
            return undefined;
        }
        return JSON.parse(devvitPostData);
    }
    /** @internal */
    static async setPostData(opts) {
        const [rsp] = await Promise.all([
            getRedditApiPlugins().LinksAndComments.EditCustomPost({
                thingId: opts.postId,
                postData: opts.postData,
            }, __classPrivateFieldGet(this, _a, "a", _Post_metadata_get)),
        ]);
        if (rsp.json?.errors?.length)
            // to-do: why is errors `Any[]`?
            throw Error(`set post ${opts.postId} data failed: ${JSON.stringify(rsp.json.errors)}`);
    }
    /** @internal */
    static async setTextFallback(opts, postId) {
        if (!('text' in opts) && !('richtext' in opts)) {
            throw new Error(`No text fallback provided for post ${postId}.`);
        }
        const client = getRedditApiPlugins().LinksAndComments;
        const richtextFallback = getCustomPostRichTextFallback(opts);
        const rsp = await client.EditCustomPost({
            thingId: postId,
            richtextFallback,
        }, __classPrivateFieldGet(this, _a, "a", _Post_metadata_get));
        if (rsp.json?.errors?.length)
            // to-do: why is errors `Any[]`?
            throw Error(`set post ${postId} text fallback failed: ${JSON.stringify(rsp.json.errors)}`);
        return _a.getById(postId);
    }
    /** @internal */
    static async delete(id) {
        const client = getRedditApiPlugins().LinksAndComments;
        await client.Del({
            id,
        }, __classPrivateFieldGet(this, _a, "a", _Post_metadata_get));
    }
    /** @internal */
    static async approve(id) {
        const client = getRedditApiPlugins().Moderation;
        await client.Approve({
            id,
        }, __classPrivateFieldGet(this, _a, "a", _Post_metadata_get));
    }
    /** @internal */
    static async remove(id, isSpam = false) {
        const client = getRedditApiPlugins().Moderation;
        await client.Remove({
            id,
            spam: isSpam,
        }, __classPrivateFieldGet(this, _a, "a", _Post_metadata_get));
    }
    /** @internal */
    static async hide(id) {
        const client = getRedditApiPlugins().LinksAndComments;
        await client.Hide({
            id,
        }, __classPrivateFieldGet(this, _a, "a", _Post_metadata_get));
    }
    /** @internal */
    static async unhide(id) {
        const client = getRedditApiPlugins().LinksAndComments;
        await client.Unhide({
            id,
        }, __classPrivateFieldGet(this, _a, "a", _Post_metadata_get));
    }
    /** @internal */
    static async markAsNsfw(id) {
        const client = getRedditApiPlugins().LinksAndComments;
        await client.MarkNSFW({
            id,
        }, __classPrivateFieldGet(this, _a, "a", _Post_metadata_get));
    }
    /** @internal */
    static async unmarkAsNsfw(id) {
        const client = getRedditApiPlugins().LinksAndComments;
        await client.UnmarkNSFW({
            id,
        }, __classPrivateFieldGet(this, _a, "a", _Post_metadata_get));
    }
    /** @internal */
    static async markAsSpoiler(id) {
        const client = getRedditApiPlugins().LinksAndComments;
        await client.Spoiler({
            id,
        }, __classPrivateFieldGet(this, _a, "a", _Post_metadata_get));
    }
    /** @internal */
    static async unmarkAsSpoiler(id) {
        const client = getRedditApiPlugins().LinksAndComments;
        await client.Unspoiler({
            id,
        }, __classPrivateFieldGet(this, _a, "a", _Post_metadata_get));
    }
    /** @internal */
    static async sticky(id, position) {
        const client = getRedditApiPlugins().LinksAndComments;
        await client.SetSubredditSticky({
            id,
            state: true,
            num: position,
        }, __classPrivateFieldGet(this, _a, "a", _Post_metadata_get));
    }
    /** @internal */
    static async unsticky(id) {
        const client = getRedditApiPlugins().LinksAndComments;
        await client.SetSubredditSticky({
            id,
            state: false,
        }, __classPrivateFieldGet(this, _a, "a", _Post_metadata_get));
    }
    /** @internal */
    static async lock(id) {
        const client = getRedditApiPlugins().LinksAndComments;
        await client.Lock({
            id,
        }, __classPrivateFieldGet(this, _a, "a", _Post_metadata_get));
    }
    /** @internal */
    static async unlock(id) {
        const client = getRedditApiPlugins().LinksAndComments;
        await client.Unlock({
            id,
        }, __classPrivateFieldGet(this, _a, "a", _Post_metadata_get));
    }
    /** @internal */
    static async distinguish(id, asAdmin) {
        const client = getRedditApiPlugins().Moderation;
        const response = await client.Distinguish({
            id,
            how: asAdmin ? 'admin' : 'yes',
            sticky: false,
        }, __classPrivateFieldGet(this, _a, "a", _Post_metadata_get));
        const post = response.json?.data?.things?.[0]?.data;
        assertNonNull(post);
        return {
            distinguishedBy: post.distinguished,
        };
    }
    /** @internal */
    static async undistinguish(id) {
        const client = getRedditApiPlugins().Moderation;
        const response = await client.Distinguish({
            id,
            how: 'no',
            sticky: false,
        }, __classPrivateFieldGet(this, _a, "a", _Post_metadata_get));
        const post = response.json?.data?.things?.[0]?.data;
        assertNonNull(post);
        return {
            distinguishedBy: post.distinguished,
        };
    }
    /** @internal */
    static async ignoreReports(id) {
        const client = getRedditApiPlugins().Moderation;
        await client.IgnoreReports({
            id,
        }, __classPrivateFieldGet(this, _a, "a", _Post_metadata_get));
    }
    /** @internal */
    static async unignoreReports(id) {
        const client = getRedditApiPlugins().Moderation;
        await client.UnignoreReports({
            id,
        }, __classPrivateFieldGet(this, _a, "a", _Post_metadata_get));
    }
    /** @internal */
    static getControversialPosts(opts) {
        return this.getSortedPosts({ ...opts, sort: 'controversial' });
    }
    /** @internal */
    static getTopPosts(opts) {
        return this.getSortedPosts({ ...opts, sort: 'top' });
    }
    /** @internal */
    static getSortedPosts(opts) {
        const client = getRedditApiPlugins().Listings;
        return new Listing({
            hasMore: true,
            before: opts.before,
            after: opts.after,
            pageSize: opts.pageSize,
            limit: opts.limit,
            fetch: async (fetchOpts) => {
                const response = await client.Sort({
                    show: 'all',
                    sort: opts.sort,
                    t: opts.timeframe,
                    subreddit: opts.subredditName,
                    ...fetchOpts,
                }, __classPrivateFieldGet(this, _a, "a", _Post_metadata_get));
                return listingProtosToPosts(response);
            },
        });
    }
    /** @internal */
    static getHotPosts(opts = {
        location: 'GLOBAL',
    }) {
        const client = getRedditApiPlugins().Listings;
        return new Listing({
            hasMore: true,
            before: opts.before,
            after: opts.after,
            pageSize: opts.pageSize,
            limit: opts.limit,
            fetch: async (fetchOpts) => {
                const response = await client.Hot({
                    g: opts.location,
                    show: 'all',
                    subreddit: opts.subredditName,
                    ...fetchOpts,
                }, __classPrivateFieldGet(this, _a, "a", _Post_metadata_get));
                return listingProtosToPosts(response);
            },
        });
    }
    /** @internal */
    static getNewPosts(opts) {
        const client = getRedditApiPlugins().Listings;
        return new Listing({
            hasMore: true,
            before: opts.before,
            after: opts.after,
            pageSize: opts.pageSize,
            limit: opts.limit,
            fetch: async (fetchOpts) => {
                const response = await client.New({
                    show: 'all',
                    subreddit: opts.subredditName,
                    ...fetchOpts,
                }, __classPrivateFieldGet(this, _a, "a", _Post_metadata_get));
                return listingProtosToPosts(response);
            },
        });
    }
    /** @internal */
    static getRisingPosts(opts) {
        const client = getRedditApiPlugins().Listings;
        return new Listing({
            hasMore: true,
            before: opts.before,
            after: opts.after,
            pageSize: opts.pageSize,
            limit: opts.limit,
            fetch: async (fetchOpts) => {
                const response = await client.Rising({
                    show: 'all',
                    subreddit: opts.subredditName,
                    ...fetchOpts,
                }, __classPrivateFieldGet(this, _a, "a", _Post_metadata_get));
                return listingProtosToPosts(response);
            },
        });
    }
    /** @internal */
    static getPostsByUser(opts) {
        const client = getRedditApiPlugins().Users;
        return new Listing({
            hasMore: true,
            before: opts.before,
            after: opts.after,
            pageSize: opts.pageSize,
            limit: opts.limit,
            fetch: async (fetchOptions) => {
                const response = await client.UserWhere({
                    username: opts.username,
                    where: 'submitted',
                    ...fetchOptions,
                }, __classPrivateFieldGet(this, _a, "a", _Post_metadata_get));
                return listingProtosToPosts(response);
            },
        });
    }
}
_a = Post, _Post_id = new WeakMap(), _Post_authorId = new WeakMap(), _Post_authorName = new WeakMap(), _Post_createdAt = new WeakMap(), _Post_subredditId = new WeakMap(), _Post_subredditName = new WeakMap(), _Post_permalink = new WeakMap(), _Post_title = new WeakMap(), _Post_body = new WeakMap(), _Post_bodyHtml = new WeakMap(), _Post_url = new WeakMap(), _Post_score = new WeakMap(), _Post_numberOfComments = new WeakMap(), _Post_numberOfReports = new WeakMap(), _Post_thumbnail = new WeakMap(), _Post_approved = new WeakMap(), _Post_approvedAtUtc = new WeakMap(), _Post_bannedAtUtc = new WeakMap(), _Post_spam = new WeakMap(), _Post_stickied = new WeakMap(), _Post_removed = new WeakMap(), _Post_removedBy = new WeakMap(), _Post_removedByCategory = new WeakMap(), _Post_archived = new WeakMap(), _Post_edited = new WeakMap(), _Post_locked = new WeakMap(), _Post_nsfw = new WeakMap(), _Post_quarantined = new WeakMap(), _Post_spoiler = new WeakMap(), _Post_hidden = new WeakMap(), _Post_ignoringReports = new WeakMap(), _Post_distinguishedBy = new WeakMap(), _Post_flair = new WeakMap(), _Post_secureMedia = new WeakMap(), _Post_modReportReasons = new WeakMap(), _Post_userReportReasons = new WeakMap(), _Post_gallery = new WeakMap(), _Post_metadata_get = function _Post_metadata_get() {
    return context.metadata;
};
function listingProtosToPosts(listingProto) {
    if (!listingProto.data?.children) {
        throw new Error('Listing response is missing children');
    }
    const children = listingProto.data.children.map((child) => new Post(child.data));
    return {
        children,
        before: listingProto.data.before,
        after: listingProto.data.after,
    };
}
/** @internal */
async function getThumbnailV2(opts) {
    const operationName = 'GetThumbnailV2';
    const persistedQueryHash = '81580ce4e23d748c5a59a1618489b559bf4518b6a73af41f345d8d074c8b2ce9';
    const rsp = await GraphQL.query(operationName, persistedQueryHash, {
        id: opts.id,
    });
    // to-do: why is postInfoById a `Record<string, any>`?
    const thumbnail = rsp.data?.postInfoById?.thumbnailV2;
    if (!thumbnail || rsp.errors.length)
        throw Error(`get post ${opts.id} thumbnail failed: ${rsp.errors.map((err) => `error ${err.code} (${err.message})`).join('; ')}`);
    if (!thumbnail.image)
        return;
    return {
        attribution: thumbnail.attribution,
        image: {
            url: thumbnail.image.url,
            width: thumbnail.image.dimensions.width,
            height: thumbnail.image.dimensions.height,
        },
        isObfuscatedDefault: thumbnail.isObfuscatedDefault,
        ...(thumbnail.obfuscatedImage && {
            obfuscatedImage: {
                url: thumbnail.obfuscatedImage.url,
                width: thumbnail.obfuscatedImage.dimensions.width,
                height: thumbnail.obfuscatedImage.dimensions.height,
            },
        }),
    };
}
function getConfig() {
    const config = devvit?.appConfig;
    if (!config)
        throw Error('no config');
    return config;
}
function getEntry(config, entry) {
    entry ?? (entry = defaultPostEntry);
    const entrypoint = config.post?.entrypoints[entry];
    if (!entrypoint)
        throw Error(`missing "${entry}" in \`devvit.json\` \`post.entrypoints\``);
    return entrypoint;
}
function SplashPostData(config, entry, opts, title) {
    // Align to `blocks.template.tsx`. The "preview" or loading screen is rendered
    // at post time so it can't float to whatever the current code default is. The
    // recorded post data must record the current state for `LoadingProps` and no
    // defaults for anything else.
    return {
        // Loading.
        appDisplayName: opts?.appDisplayName ?? config.name,
        backgroundUri: opts?.backgroundUri ?? backgroundUrl,
        appIconUri: opts?.appIconUri,
        buttonLabel: opts?.buttonLabel,
        description: opts?.description,
        entry: entry.name,
        title: opts?.heading ?? title,
    };
}
function postFromSubmitResponse(rsp) {
    if (!rsp.json?.data?.id || rsp.json.errors?.length)
        throw Error(
        // to-do: why is errors an `Any[]`?
        `post ${rsp.json?.data?.id} submission failed: ${JSON.stringify(rsp.json?.errors)}`);
    return Post.getById(`t3_${rsp.json.data.id}`);
}
async function renderLoadingAsRichTextJson(props, meta) {
    const handler = new BlocksHandler(() => Loading(props));
    const { blocks } = UIResponse.fromJSON(await handler.handle({ events: [] }, meta));
    const encodedCached = Block.encode(blocks).finish();
    return Buffer.from(encodedCached).toString('base64');
}
