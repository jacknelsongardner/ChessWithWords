var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _a, _FlairTemplate_id, _FlairTemplate_subredditName, _FlairTemplate_text, _FlairTemplate_textColor, _FlairTemplate_backgroundColor, _FlairTemplate_allowableContent, _FlairTemplate_modOnly, _FlairTemplate_maxEmojis, _FlairTemplate_allowUserEdits, _FlairTemplate_createOrUpdateFlairTemplate, _FlairTemplate_metadata_get, _b, _Flair_setFlair, _Flair_setUserFlairBatch, _Flair_removeFlair, _Flair_metadata_get;
import {} from '@devvit/protos';
import { context } from '@devvit/server';
import { assertNonNull } from '@devvit/shared-types/NonNull.js';
import { T3 } from '@devvit/shared-types/tid.js';
import { makeGettersEnumerable } from '../helpers/makeGettersEnumerable.js';
import { getRedditApiPlugins } from '../plugin.js';
export var FlairType;
(function (FlairType) {
    FlairType["User"] = "USER_FLAIR";
    FlairType["Post"] = "LINK_FLAIR";
})(FlairType || (FlairType = {}));
export class FlairTemplate {
    /**
     * @internal
     */
    constructor(data, subredditName) {
        _FlairTemplate_id.set(this, void 0);
        _FlairTemplate_subredditName.set(this, void 0);
        _FlairTemplate_text.set(this, void 0);
        _FlairTemplate_textColor.set(this, void 0);
        _FlairTemplate_backgroundColor.set(this, void 0);
        _FlairTemplate_allowableContent.set(this, void 0);
        _FlairTemplate_modOnly.set(this, void 0);
        _FlairTemplate_maxEmojis.set(this, void 0);
        _FlairTemplate_allowUserEdits.set(this, void 0);
        makeGettersEnumerable(this);
        assertNonNull(data.id);
        assertNonNull(data.text);
        __classPrivateFieldSet(this, _FlairTemplate_id, data.id, "f");
        __classPrivateFieldSet(this, _FlairTemplate_subredditName, subredditName, "f");
        __classPrivateFieldSet(this, _FlairTemplate_text, data.text, "f");
        __classPrivateFieldSet(this, _FlairTemplate_textColor, asFlairTextColor(data.textColor), "f");
        __classPrivateFieldSet(this, _FlairTemplate_backgroundColor, asFlairBackgroundColor(data.backgroundColor), "f");
        __classPrivateFieldSet(this, _FlairTemplate_allowableContent, asAllowableContent(data.allowableContent), "f");
        __classPrivateFieldSet(this, _FlairTemplate_modOnly, data.modOnly, "f");
        __classPrivateFieldSet(this, _FlairTemplate_maxEmojis, data.maxEmojis, "f");
        __classPrivateFieldSet(this, _FlairTemplate_allowUserEdits, data.textEditable, "f");
    }
    /** The flair template's ID */
    get id() {
        return __classPrivateFieldGet(this, _FlairTemplate_id, "f");
    }
    /** The flair template's text */
    get text() {
        return __classPrivateFieldGet(this, _FlairTemplate_text, "f");
    }
    /** The flair template's text color. Either 'dark' or 'light'. */
    get textColor() {
        return __classPrivateFieldGet(this, _FlairTemplate_textColor, "f");
    }
    /** The flair template's background color. Either 'transparent' or a hex color code. e.g. #FFC0CB */
    get backgroundColor() {
        return __classPrivateFieldGet(this, _FlairTemplate_backgroundColor, "f");
    }
    /** The flair template's allowable content. Either 'all', 'emoji', or 'text'. */
    get allowableContent() {
        return __classPrivateFieldGet(this, _FlairTemplate_allowableContent, "f");
    }
    /** Is the flair template only available to moderators? */
    get modOnly() {
        return __classPrivateFieldGet(this, _FlairTemplate_modOnly, "f");
    }
    /** The flair template's maximum number of emojis. */
    get maxEmojis() {
        return __classPrivateFieldGet(this, _FlairTemplate_maxEmojis, "f");
    }
    /** Does the flair template allow users to edit their flair? */
    get allowUserEdits() {
        return __classPrivateFieldGet(this, _FlairTemplate_allowUserEdits, "f");
    }
    /** Delete this flair template */
    async delete() {
        return _a.deleteFlairTemplate(__classPrivateFieldGet(this, _FlairTemplate_id, "f"), __classPrivateFieldGet(this, _FlairTemplate_subredditName, "f"));
    }
    /** Edit this flair template */
    async edit(options) {
        return _a.editFlairTemplate({
            id: __classPrivateFieldGet(this, _FlairTemplate_id, "f"),
            subredditName: __classPrivateFieldGet(this, _FlairTemplate_subredditName, "f"),
            text: options.text ?? __classPrivateFieldGet(this, _FlairTemplate_text, "f"),
            allowableContent: options.allowableContent ?? __classPrivateFieldGet(this, _FlairTemplate_allowableContent, "f"),
            backgroundColor: options.backgroundColor ?? __classPrivateFieldGet(this, _FlairTemplate_backgroundColor, "f"),
            maxEmojis: options.maxEmojis ?? __classPrivateFieldGet(this, _FlairTemplate_maxEmojis, "f"),
            modOnly: options.modOnly ?? __classPrivateFieldGet(this, _FlairTemplate_modOnly, "f"),
            textColor: options.textColor ?? __classPrivateFieldGet(this, _FlairTemplate_textColor, "f"),
            allowUserEdits: options.allowUserEdits ?? __classPrivateFieldGet(this, _FlairTemplate_allowUserEdits, "f"),
        });
    }
    /** @internal */
    static async createPostFlairTemplate(options) {
        return __classPrivateFieldGet(_a, _a, "m", _FlairTemplate_createOrUpdateFlairTemplate).call(_a, { ...options, flairType: FlairType.Post });
    }
    /** @internal */
    static async createUserFlairTemplate(options) {
        return __classPrivateFieldGet(_a, _a, "m", _FlairTemplate_createOrUpdateFlairTemplate).call(_a, { ...options, flairType: FlairType.User });
    }
    /** @internal */
    static async editFlairTemplate(editOptions) {
        return __classPrivateFieldGet(_a, _a, "m", _FlairTemplate_createOrUpdateFlairTemplate).call(_a, editOptions);
    }
    /** @internal */
    static async getPostFlairTemplates(subredditName) {
        const client = getRedditApiPlugins().Flair;
        const response = await client.LinkFlair({
            subreddit: subredditName,
        }, __classPrivateFieldGet(this, _a, "a", _FlairTemplate_metadata_get));
        return response.flair?.map((flair) => new _a(flair, subredditName)) || [];
    }
    /** @internal */
    static async getUserFlairTemplates(subredditName) {
        const client = getRedditApiPlugins().Flair;
        const response = await client.UserFlair({
            subreddit: subredditName,
        }, __classPrivateFieldGet(this, _a, "a", _FlairTemplate_metadata_get));
        return response.flair?.map((flair) => new _a(flair, subredditName)) || [];
    }
    /** @internal */
    static async deleteFlairTemplate(subredditName, flairTemplateId) {
        const client = getRedditApiPlugins().Flair;
        await client.DeleteFlairTemplate({
            subreddit: subredditName,
            flairTemplateId,
        }, __classPrivateFieldGet(this, _a, "a", _FlairTemplate_metadata_get));
    }
}
_a = FlairTemplate, _FlairTemplate_id = new WeakMap(), _FlairTemplate_subredditName = new WeakMap(), _FlairTemplate_text = new WeakMap(), _FlairTemplate_textColor = new WeakMap(), _FlairTemplate_backgroundColor = new WeakMap(), _FlairTemplate_allowableContent = new WeakMap(), _FlairTemplate_modOnly = new WeakMap(), _FlairTemplate_maxEmojis = new WeakMap(), _FlairTemplate_allowUserEdits = new WeakMap(), _FlairTemplate_createOrUpdateFlairTemplate = async function _FlairTemplate_createOrUpdateFlairTemplate(options) {
    const { subredditName: subreddit, allowableContent = 'all', backgroundColor = 'transparent', flairType = '', maxEmojis = 10, modOnly = false, text, textColor = 'dark', allowUserEdits: textEditable = false, id: flairTemplateId = '', } = options;
    if (modOnly && textEditable) {
        throw new Error('Cannot have a mod only flair that is editable by users');
    }
    const client = getRedditApiPlugins().Flair;
    const response = await client.FlairTemplate({
        subreddit,
        allowableContent,
        backgroundColor,
        flairType,
        maxEmojis,
        modOnly,
        text,
        textColor,
        textEditable,
        flairTemplateId,
        cssClass: '',
        overrideCss: false,
    }, __classPrivateFieldGet(this, _a, "a", _FlairTemplate_metadata_get));
    return new _a(response, subreddit);
}, _FlairTemplate_metadata_get = function _FlairTemplate_metadata_get() {
    return context.metadata;
};
/** @internal */
export function convertUserFlairProtoToAPI(userFlair) {
    return {
        flairCssClass: userFlair.flairCssClass,
        user: userFlair.user,
        flairText: userFlair.flairText,
    };
}
export class Flair {
    /**
     * Exposes the ListFlair API. This method will return the list of user flair for the subreddit. If name
     * is specified then it will return the user flair for the given user.
     *
     * @param { GetUserFlairBySubredditOptions } options See the interface
     *
     * @returns { Promise<GetUserFlairBySubredditResponse> }
     *
     * @example
     * ```ts
     * const response = await reddit.flair.getUserFlairBySubreddit({
     *      subreddit: "EyeBleach",
     *      name: "badapple"
     *   },
     *   metadata
     * );
     * ```
     * @internal
     */
    static async getUserFlairBySubreddit(options) {
        const client = getRedditApiPlugins().Flair;
        return client.FlairList(options, __classPrivateFieldGet(this, _b, "a", _Flair_metadata_get));
    }
    /** @internal */
    static setUserFlair(options) {
        return __classPrivateFieldGet(_b, _b, "m", _Flair_setFlair).call(_b, options);
    }
    /** @internal */
    static setUserFlairBatch(subredditName, flairs) {
        return __classPrivateFieldGet(_b, _b, "m", _Flair_setUserFlairBatch).call(_b, subredditName, flairs);
    }
    /** @internal */
    static setPostFlair(options) {
        return __classPrivateFieldGet(_b, _b, "m", _Flair_setFlair).call(_b, {
            ...options,
            postId: T3(options.t3),
        });
    }
    /** @internal */
    static async removePostFlair(subredditName, postId) {
        return __classPrivateFieldGet(_b, _b, "m", _Flair_removeFlair).call(_b, subredditName, postId, undefined);
    }
    /** @internal */
    static async removeUserFlair(subredditName, username) {
        return __classPrivateFieldGet(_b, _b, "m", _Flair_removeFlair).call(_b, subredditName, undefined, username);
    }
}
_b = Flair, _Flair_setFlair = async function _Flair_setFlair(options) {
    const client = getRedditApiPlugins().Flair;
    await client.SelectFlair({
        subreddit: options.subredditName,
        flairTemplateId: options.flairTemplateId ?? '',
        text: options.text ?? '',
        name: options.username,
        link: options.t3,
        backgroundColor: options.backgroundColor ?? '',
        textColor: options.textColor ?? 'dark',
        cssClass: options.cssClass ?? '',
        returnRtjson: 'none',
    }, __classPrivateFieldGet(this, _b, "a", _Flair_metadata_get));
}, _Flair_setUserFlairBatch = async function _Flair_setUserFlairBatch(subredditName, flairs) {
    if (!flairs.length) {
        return [];
    }
    const maxFlairsPerRequest = 100;
    if (flairs.length > maxFlairsPerRequest) {
        throw new Error('Unexpected input: flairs array cannot be longer than 100 entries.');
    }
    const csvDelimiter = ',';
    const flairCsv = flairs
        .map((userConfig) => {
        for (const propertyName in userConfig) {
            if (userConfig[propertyName]?.includes(csvDelimiter)) {
                throw new Error(`Unexpected input: ${propertyName} cannot contain the "," character`);
            }
        }
        return [userConfig.username, userConfig.text || '', userConfig.cssClass || ''].join(csvDelimiter);
    })
        .join('\n');
    const client = getRedditApiPlugins().Flair;
    const response = await client.FlairCsv({
        subreddit: subredditName,
        flairCsv,
    }, __classPrivateFieldGet(this, _b, "a", _Flair_metadata_get));
    return response.result;
}, _Flair_removeFlair = async function _Flair_removeFlair(subredditName, postId, username) {
    const client = getRedditApiPlugins().Flair;
    await client.SelectFlair({
        subreddit: subredditName,
        name: username ?? '',
        link: postId ?? '',
        flairTemplateId: '',
        backgroundColor: '',
        text: '',
        textColor: '',
        cssClass: '',
        returnRtjson: 'none',
    }, __classPrivateFieldGet(this, _b, "a", _Flair_metadata_get));
}, _Flair_metadata_get = function _Flair_metadata_get() {
    return context.metadata;
};
function asFlairTextColor(color) {
    assertNonNull(color, 'Flair text color is required');
    if (color === 'light' || color === 'dark') {
        return color;
    }
    throw new Error(`Invalid flair text color: ${color}`);
}
function asFlairBackgroundColor(color) {
    if (!color || color.length === 0 || color === 'transparent') {
        return 'transparent';
    }
    if (/^#([A-Fa-f0-9]{6})$/.test(color)) {
        return color;
    }
    throw new Error(`Invalid flair background color: ${color}`);
}
function asAllowableContent(allowableContent) {
    if (allowableContent === 'all' || allowableContent === 'text' || allowableContent === 'emoji') {
        return allowableContent;
    }
    throw new Error(`Invalid allowable content: ${allowableContent}`);
}
