var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _a, _Comment_id, _Comment_authorId, _Comment_authorName, _Comment_body, _Comment_createdAt, _Comment_parentId, _Comment_postId, _Comment_subredditId, _Comment_subredditName, _Comment_replies, _Comment_approved, _Comment_approvedAtUtc, _Comment_bannedAtUtc, _Comment_edited, _Comment_locked, _Comment_removed, _Comment_stickied, _Comment_spam, _Comment_distinguishedBy, _Comment_numReports, _Comment_collapsedBecauseCrowdControl, _Comment_score, _Comment_permalink, _Comment_modReportReasons, _Comment_userReportReasons, _Comment_url, _Comment_ignoringReports, _Comment_getCommentsListing, _Comment_buildCommentsTree, _Comment_metadata_get;
import { Scope } from '@devvit/protos/json/reddit/devvit/app_permission/v1/app_permission.js';
import { context } from '@devvit/server';
import { assertNonNull } from '@devvit/shared-types/NonNull.js';
import { asTid, isT1, T1, T2, T3, T5 } from '@devvit/shared-types/tid.js';
import { assertUserScope, RunAs } from '../common.js';
import { makeGettersEnumerable } from '../helpers/makeGettersEnumerable.js';
import { richtextToString } from '../helpers/richtextToString.js';
import { getRedditApiPlugins, getUserActionsPlugin } from '../plugin.js';
import { Listing } from './Listing.js';
import { ModNote } from './ModNote.js';
import { User } from './User.js';
export class Comment {
    /**
     * @internal
     */
    constructor(data) {
        _Comment_id.set(this, void 0);
        _Comment_authorId.set(this, void 0);
        _Comment_authorName.set(this, void 0);
        _Comment_body.set(this, void 0);
        _Comment_createdAt.set(this, void 0);
        _Comment_parentId.set(this, void 0);
        _Comment_postId.set(this, void 0);
        _Comment_subredditId.set(this, void 0);
        _Comment_subredditName.set(this, void 0);
        _Comment_replies.set(this, void 0);
        _Comment_approved.set(this, void 0);
        _Comment_approvedAtUtc.set(this, void 0);
        _Comment_bannedAtUtc.set(this, void 0);
        _Comment_edited.set(this, void 0);
        _Comment_locked.set(this, void 0);
        _Comment_removed.set(this, void 0);
        _Comment_stickied.set(this, void 0);
        _Comment_spam.set(this, void 0);
        _Comment_distinguishedBy.set(this, void 0);
        _Comment_numReports.set(this, void 0);
        _Comment_collapsedBecauseCrowdControl.set(this, void 0);
        _Comment_score.set(this, void 0);
        _Comment_permalink.set(this, void 0);
        _Comment_modReportReasons.set(this, void 0);
        _Comment_userReportReasons.set(this, void 0);
        _Comment_url.set(this, void 0);
        _Comment_ignoringReports.set(this, void 0);
        makeGettersEnumerable(this);
        assertNonNull(data.id, 'Comment id is null or undefined');
        assertNonNull(data.body, 'Comment body is null or undefined');
        assertNonNull(data.createdUtc, 'Comment is missing created date');
        assertNonNull(data.author, 'Comment author is null or undefined');
        assertNonNull(data.parentId, 'Comment parentId is null or undefined');
        assertNonNull(data.linkId, 'Comment linkId is null or undefined');
        assertNonNull(data.permalink, 'Comment permalink is null or undefined');
        assertNonNull(data.subreddit, 'Comment is missing subreddit name');
        assertNonNull(data.subredditId, 'Comment is missing subreddit id');
        __classPrivateFieldSet(this, _Comment_id, `t1_${data.id}`, "f");
        __classPrivateFieldSet(this, _Comment_authorId, data.authorFullname ? T2(data.authorFullname) : undefined, "f");
        __classPrivateFieldSet(this, _Comment_authorName, data.author, "f");
        __classPrivateFieldSet(this, _Comment_body, data.body, "f");
        __classPrivateFieldSet(this, _Comment_subredditId, T5(data.subredditId), "f");
        __classPrivateFieldSet(this, _Comment_subredditName, data.subreddit, "f");
        __classPrivateFieldSet(this, _Comment_parentId, asTid(data.parentId), "f");
        __classPrivateFieldSet(this, _Comment_postId, T3(data.linkId), "f");
        __classPrivateFieldSet(this, _Comment_edited, data.edited ?? false, "f");
        __classPrivateFieldSet(this, _Comment_locked, data.locked ?? false, "f");
        __classPrivateFieldSet(this, _Comment_removed, data.removed ?? false, "f");
        __classPrivateFieldSet(this, _Comment_stickied, data.stickied ?? false, "f");
        __classPrivateFieldSet(this, _Comment_approved, data.approved ?? false, "f");
        __classPrivateFieldSet(this, _Comment_approvedAtUtc, data.approvedAtUtc ?? 0, "f");
        __classPrivateFieldSet(this, _Comment_bannedAtUtc, data.bannedAtUtc ?? 0, "f");
        __classPrivateFieldSet(this, _Comment_spam, data.spam ?? false, "f");
        __classPrivateFieldSet(this, _Comment_distinguishedBy, data.distinguished, "f");
        __classPrivateFieldSet(this, _Comment_numReports, data.numReports ?? 0, "f");
        __classPrivateFieldSet(this, _Comment_collapsedBecauseCrowdControl, data.collapsedBecauseCrowdControl ?? false, "f");
        __classPrivateFieldSet(this, _Comment_score, data.score ?? 0, "f");
        __classPrivateFieldSet(this, _Comment_permalink, data.permalink, "f");
        // R2 API does not include a URL for a comment, just a permalink
        __classPrivateFieldSet(this, _Comment_url, new URL(data.permalink ?? '', 'https://www.reddit.com/').toString(), "f");
        __classPrivateFieldSet(this, _Comment_ignoringReports, data.ignoreReports ?? false, "f");
        __classPrivateFieldSet(this, _Comment_modReportReasons, (data.modReports ?? []).map(([reason]) => reason), "f");
        __classPrivateFieldSet(this, _Comment_userReportReasons, (data.userReports ?? []).map(([reason]) => reason), "f");
        const createdAt = new Date(0);
        createdAt.setUTCSeconds(data.createdUtc);
        __classPrivateFieldSet(this, _Comment_createdAt, createdAt, "f");
        __classPrivateFieldSet(this, _Comment_replies, __classPrivateFieldGet(_a, _a, "m", _Comment_getCommentsListing).call(_a, {
            postId: __classPrivateFieldGet(this, _Comment_postId, "f"),
            commentId: __classPrivateFieldGet(this, _Comment_id, "f"),
        }), "f");
    }
    get id() {
        return __classPrivateFieldGet(this, _Comment_id, "f");
    }
    get authorId() {
        return __classPrivateFieldGet(this, _Comment_authorId, "f");
    }
    get authorName() {
        return __classPrivateFieldGet(this, _Comment_authorName, "f");
    }
    get subredditId() {
        return __classPrivateFieldGet(this, _Comment_subredditId, "f");
    }
    get subredditName() {
        return __classPrivateFieldGet(this, _Comment_subredditName, "f");
    }
    get body() {
        return __classPrivateFieldGet(this, _Comment_body, "f");
    }
    get createdAt() {
        return __classPrivateFieldGet(this, _Comment_createdAt, "f");
    }
    get parentId() {
        return __classPrivateFieldGet(this, _Comment_parentId, "f");
    }
    get postId() {
        return __classPrivateFieldGet(this, _Comment_postId, "f");
    }
    get replies() {
        return __classPrivateFieldGet(this, _Comment_replies, "f");
    }
    get distinguishedBy() {
        return __classPrivateFieldGet(this, _Comment_distinguishedBy, "f");
    }
    get locked() {
        return __classPrivateFieldGet(this, _Comment_locked, "f");
    }
    get stickied() {
        return __classPrivateFieldGet(this, _Comment_stickied, "f");
    }
    get removed() {
        return __classPrivateFieldGet(this, _Comment_removed, "f");
    }
    get approved() {
        return __classPrivateFieldGet(this, _Comment_approved, "f");
    }
    get approvedAtUtc() {
        return __classPrivateFieldGet(this, _Comment_approvedAtUtc, "f");
    }
    get bannedAtUtc() {
        return __classPrivateFieldGet(this, _Comment_bannedAtUtc, "f");
    }
    get spam() {
        return __classPrivateFieldGet(this, _Comment_spam, "f");
    }
    get edited() {
        return __classPrivateFieldGet(this, _Comment_edited, "f");
    }
    get numReports() {
        return __classPrivateFieldGet(this, _Comment_numReports, "f");
    }
    get collapsedBecauseCrowdControl() {
        return __classPrivateFieldGet(this, _Comment_collapsedBecauseCrowdControl, "f");
    }
    get score() {
        return __classPrivateFieldGet(this, _Comment_score, "f");
    }
    get permalink() {
        return __classPrivateFieldGet(this, _Comment_permalink, "f");
    }
    get userReportReasons() {
        return __classPrivateFieldGet(this, _Comment_userReportReasons, "f");
    }
    get modReportReasons() {
        return __classPrivateFieldGet(this, _Comment_modReportReasons, "f");
    }
    get url() {
        return __classPrivateFieldGet(this, _Comment_url, "f");
    }
    get ignoringReports() {
        return __classPrivateFieldGet(this, _Comment_ignoringReports, "f");
    }
    toJSON() {
        return {
            id: this.id,
            authorName: this.authorName,
            subredditId: this.subredditId,
            subredditName: this.subredditName,
            body: this.body,
            createdAt: this.createdAt,
            parentId: this.parentId,
            postId: this.postId,
            replies: this.replies,
            approved: this.approved,
            locked: this.locked,
            removed: this.removed,
            stickied: this.stickied,
            spam: this.spam,
            edited: this.edited,
            distinguishedBy: this.distinguishedBy,
            numReports: this.numReports,
            collapsedBecauseCrowdControl: this.collapsedBecauseCrowdControl,
            score: this.score,
            permalink: this.permalink,
            modReportReasons: this.modReportReasons,
            userReportReasons: this.userReportReasons,
            url: this.url,
            ignoringReports: this.ignoringReports,
        };
    }
    isLocked() {
        return __classPrivateFieldGet(this, _Comment_locked, "f");
    }
    isApproved() {
        return __classPrivateFieldGet(this, _Comment_approved, "f");
    }
    isRemoved() {
        return __classPrivateFieldGet(this, _Comment_removed, "f");
    }
    isSpam() {
        return __classPrivateFieldGet(this, _Comment_spam, "f");
    }
    isStickied() {
        return __classPrivateFieldGet(this, _Comment_stickied, "f");
    }
    isDistinguished() {
        return Boolean(__classPrivateFieldGet(this, _Comment_distinguishedBy, "f"));
    }
    isEdited() {
        return __classPrivateFieldGet(this, _Comment_edited, "f");
    }
    isIgnoringReports() {
        return __classPrivateFieldGet(this, _Comment_ignoringReports, "f");
    }
    async delete() {
        return _a.delete(this.id);
    }
    async edit(opts) {
        const newComment = await _a.edit({ id: this.id, ...opts });
        __classPrivateFieldSet(this, _Comment_body, newComment.body, "f");
        __classPrivateFieldSet(this, _Comment_edited, newComment.edited, "f");
        return this;
    }
    async approve() {
        await _a.approve(this.id);
        __classPrivateFieldSet(this, _Comment_approved, true, "f");
        __classPrivateFieldSet(this, _Comment_removed, false, "f");
    }
    async remove(isSpam = false) {
        await _a.remove(this.id, isSpam);
        __classPrivateFieldSet(this, _Comment_removed, true, "f");
        __classPrivateFieldSet(this, _Comment_spam, isSpam, "f");
        __classPrivateFieldSet(this, _Comment_approved, false, "f");
    }
    async lock() {
        await _a.lock(this.id);
        __classPrivateFieldSet(this, _Comment_locked, true, "f");
    }
    async unlock() {
        await _a.unlock(this.id);
        __classPrivateFieldSet(this, _Comment_locked, false, "f");
    }
    async reply(opts) {
        return _a.submit({ id: this.id, ...opts });
    }
    async getAuthor() {
        return User.getByUsername(__classPrivateFieldGet(this, _Comment_authorName, "f"));
    }
    async distinguish(makeSticky = false) {
        const { distinguishedBy, stickied } = await _a.distinguish(this.id, makeSticky, false);
        __classPrivateFieldSet(this, _Comment_distinguishedBy, distinguishedBy, "f");
        __classPrivateFieldSet(this, _Comment_stickied, stickied, "f");
    }
    async distinguishAsAdmin(makeSticky = false) {
        const { distinguishedBy, stickied } = await _a.distinguish(this.id, makeSticky, true);
        __classPrivateFieldSet(this, _Comment_distinguishedBy, distinguishedBy, "f");
        __classPrivateFieldSet(this, _Comment_stickied, stickied, "f");
    }
    async undistinguish() {
        const { distinguishedBy, stickied } = await _a.undistinguish(this.id);
        __classPrivateFieldSet(this, _Comment_distinguishedBy, distinguishedBy, "f");
        __classPrivateFieldSet(this, _Comment_stickied, stickied, "f");
    }
    async ignoreReports() {
        await _a.ignoreReports(this.id);
        __classPrivateFieldSet(this, _Comment_ignoringReports, true, "f");
    }
    async unignoreReports() {
        await _a.unignoreReports(this.id);
        __classPrivateFieldSet(this, _Comment_ignoringReports, false, "f");
    }
    /**
     * Add a mod note for why the comment was removed
     *
     * @param options.reasonId id of a Removal Reason - you can leave this as an empty string if you don't have one
     * @param options.modNote the reason for removal (maximum 100 characters) (optional)
     * @returns
     */
    addRemovalNote(opts) {
        return ModNote.addRemovalNote({ itemIds: [__classPrivateFieldGet(this, _Comment_id, "f")], ...opts });
    }
    /** @internal */
    static async getById(id) {
        const client = getRedditApiPlugins().LinksAndComments;
        const commentId = isT1(id) ? id : `t1_${id}`;
        const response = await client.Info({
            subreddits: [],
            thingIds: [commentId],
        }, __classPrivateFieldGet(this, _a, "a", _Comment_metadata_get));
        if (!response.data?.children?.[0]?.data) {
            throw new Error('not found');
        }
        return new _a(response.data.children[0].data);
    }
    /** @internal */
    static getComments(opts) {
        const { postId, commentId, ...rest } = opts;
        return __classPrivateFieldGet(_a, _a, "m", _Comment_getCommentsListing).call(_a, {
            postId: T3(postId),
            commentId: commentId ? T1(commentId) : undefined,
            ...rest,
        });
    }
    /** @internal */
    static async edit(opts) {
        const client = getRedditApiPlugins().LinksAndComments;
        const { id } = opts;
        let richtextString;
        if ('richtext' in opts) {
            richtextString = richtextToString(opts.richtext);
        }
        const response = await client.EditUserText({
            thingId: id,
            text: 'text' in opts ? opts.text : '',
            richtextJson: richtextString,
            runAs: RunAs.APP,
        }, __classPrivateFieldGet(this, _a, "a", _Comment_metadata_get));
        if (response.json?.errors?.length) {
            throw new Error('Failed to edit comment');
        }
        const comment = response.json?.data?.things?.[0]?.data;
        assertNonNull(comment);
        return new _a(comment);
    }
    /** @internal */
    static async delete(id) {
        const client = getRedditApiPlugins().LinksAndComments;
        await client.Del({
            id,
        }, __classPrivateFieldGet(this, _a, "a", _Comment_metadata_get));
    }
    /** @internal */
    static async approve(id) {
        const client = getRedditApiPlugins().Moderation;
        await client.Approve({
            id,
        }, __classPrivateFieldGet(this, _a, "a", _Comment_metadata_get));
    }
    /** @internal */
    static async remove(id, isSpam = false) {
        const client = getRedditApiPlugins().Moderation;
        await client.Remove({
            id,
            spam: isSpam,
        }, __classPrivateFieldGet(this, _a, "a", _Comment_metadata_get));
    }
    /** @internal */
    static async lock(id) {
        const client = getRedditApiPlugins().LinksAndComments;
        await client.Lock({
            id,
        }, __classPrivateFieldGet(this, _a, "a", _Comment_metadata_get));
    }
    /** @internal */
    static async unlock(id) {
        const client = getRedditApiPlugins().LinksAndComments;
        await client.Unlock({
            id,
        }, __classPrivateFieldGet(this, _a, "a", _Comment_metadata_get));
    }
    /** @internal */
    static async submit(options) {
        const { runAs = 'APP' } = options;
        const runAsType = RunAs[runAs];
        const client = runAsType === RunAs.USER ? getUserActionsPlugin() : getRedditApiPlugins().LinksAndComments;
        if (runAsType === RunAs.USER) {
            assertUserScope(Scope.SUBMIT_COMMENT);
        }
        const { id } = options;
        let richtextString;
        if ('richtext' in options) {
            richtextString = richtextToString(options.richtext);
        }
        const response = await client.Comment({
            thingId: id,
            text: 'text' in options ? options.text : '',
            richtextJson: richtextString,
            runAs: runAsType,
        }, __classPrivateFieldGet(this, _a, "a", _Comment_metadata_get));
        // TODO: figure out a better errors to throw
        if (response.json?.errors?.length) {
            throw new Error('failed to reply to comment');
        }
        const data = response.json?.data?.things?.[0]?.data;
        assertNonNull(data);
        return new _a(data);
    }
    /** @internal */
    static async distinguish(id, sticky, asAdmin) {
        const client = getRedditApiPlugins().Moderation;
        const response = await client.Distinguish({
            id,
            how: asAdmin ? 'admin' : 'yes',
            sticky,
        }, __classPrivateFieldGet(this, _a, "a", _Comment_metadata_get));
        const comment = response.json?.data?.things?.[0]?.data;
        assertNonNull(comment);
        return {
            distinguishedBy: comment.distinguished,
            stickied: Boolean(comment.stickied),
        };
    }
    /** @internal */
    static async undistinguish(id) {
        const client = getRedditApiPlugins().Moderation;
        const response = await client.Distinguish({
            id,
            how: 'no',
            sticky: false,
        }, __classPrivateFieldGet(this, _a, "a", _Comment_metadata_get));
        const comment = response.json?.data?.things?.[0]?.data;
        assertNonNull(comment);
        return {
            distinguishedBy: comment.distinguished,
            stickied: Boolean(comment.stickied),
        };
    }
    /** @internal */
    static getCommentsByUser(options) {
        const client = getRedditApiPlugins().Users;
        return new Listing({
            hasMore: true,
            before: options.before,
            after: options.after,
            pageSize: options.pageSize,
            limit: options.limit,
            fetch: async (fetchOptions) => {
                const response = await client.UserWhere({
                    username: options.username,
                    where: 'comments',
                    ...fetchOptions,
                }, __classPrivateFieldGet(this, _a, "a", _Comment_metadata_get));
                assertNonNull(response.data, 'Failed to get comments for user');
                const children = response.data.children?.map((child) => new _a(child.data)) || [];
                return {
                    children,
                    before: response.data.before,
                    after: response.data.after,
                };
            },
        });
    }
    /** @internal */
    static async ignoreReports(id) {
        const client = getRedditApiPlugins().Moderation;
        await client.IgnoreReports({
            id,
        }, __classPrivateFieldGet(this, _a, "a", _Comment_metadata_get));
    }
    /** @internal */
    static async unignoreReports(id) {
        const client = getRedditApiPlugins().Moderation;
        await client.UnignoreReports({
            id,
        }, __classPrivateFieldGet(this, _a, "a", _Comment_metadata_get));
    }
}
_a = Comment, _Comment_id = new WeakMap(), _Comment_authorId = new WeakMap(), _Comment_authorName = new WeakMap(), _Comment_body = new WeakMap(), _Comment_createdAt = new WeakMap(), _Comment_parentId = new WeakMap(), _Comment_postId = new WeakMap(), _Comment_subredditId = new WeakMap(), _Comment_subredditName = new WeakMap(), _Comment_replies = new WeakMap(), _Comment_approved = new WeakMap(), _Comment_approvedAtUtc = new WeakMap(), _Comment_bannedAtUtc = new WeakMap(), _Comment_edited = new WeakMap(), _Comment_locked = new WeakMap(), _Comment_removed = new WeakMap(), _Comment_stickied = new WeakMap(), _Comment_spam = new WeakMap(), _Comment_distinguishedBy = new WeakMap(), _Comment_numReports = new WeakMap(), _Comment_collapsedBecauseCrowdControl = new WeakMap(), _Comment_score = new WeakMap(), _Comment_permalink = new WeakMap(), _Comment_modReportReasons = new WeakMap(), _Comment_userReportReasons = new WeakMap(), _Comment_url = new WeakMap(), _Comment_ignoringReports = new WeakMap(), _Comment_getCommentsListing = function _Comment_getCommentsListing(options, depthOffset = 0) {
    return new Listing({
        limit: options.limit,
        pageSize: options.pageSize,
        fetch: async (fetchOptions) => {
            let limit = fetchOptions.limit;
            const listingsClient = getRedditApiPlugins().Listings;
            const linksAndCommentsClient = getRedditApiPlugins().LinksAndComments;
            let commentId = options.commentId;
            if (fetchOptions.more) {
                if (fetchOptions.more.children.length) {
                    const more = fetchOptions.more;
                    // The maximum page size for MoreChildren is 100
                    if (!limit || limit > 100) {
                        limit = 100;
                    }
                    const moreIds = more.children.splice(0, limit);
                    const response = await linksAndCommentsClient.MoreChildren({
                        linkId: options.postId,
                        children: moreIds,
                        sort: options.sort,
                    }, __classPrivateFieldGet(this, _a, "a", _Comment_metadata_get));
                    if (!response.json?.data?.things?.length) {
                        return { children: [] };
                    }
                    const { children } = __classPrivateFieldGet(_a, _a, "m", _Comment_buildCommentsTree).call(_a, response.json.data.things, options.postId, options);
                    return { children, more: more.children.length ? more : undefined };
                }
                else {
                    // parentId is only ever T3 for the MoreChildren case.
                    commentId = fetchOptions.more.parentId;
                    depthOffset = depthOffset + fetchOptions.more.depth;
                }
            }
            const response = await listingsClient.Comments({
                article: options.postId.substring(3),
                comment: commentId?.substring(3),
                limit,
                depth: options.depth,
                sort: options.sort,
            }, __classPrivateFieldGet(this, _a, "a", _Comment_metadata_get));
            // The first item of `response.listings` is always the post (t3) listing
            // and the second item is the comments (t1) listing.
            let responseChildren = response.listings?.[1]?.data?.children ?? [];
            const topLevelComment = responseChildren[0];
            if (commentId && topLevelComment?.data?.replyList?.data) {
                responseChildren = topLevelComment.data.replyList.data.children;
            }
            return __classPrivateFieldGet(_a, _a, "m", _Comment_buildCommentsTree).call(_a, responseChildren, commentId ?? options.postId, options, depthOffset);
        },
    });
}, _Comment_buildCommentsTree = function _Comment_buildCommentsTree(redditObjects, parentId, options, depthOffset = 0) {
    const children = [];
    let more;
    // Map of comments to help set parent-child relationship between comments returned by MoreChildren.
    const commentsMap = {};
    for (const child of redditObjects) {
        if (!child.data) {
            continue;
        }
        if (child.data.depth != null) {
            child.data.depth = child.data.depth + depthOffset;
        }
        // Prevent returning comments that are beyond the maximum depth requested.
        if (child.data.depth != null && options.depth != null && child.data.depth >= options.depth) {
            continue;
        }
        const parentComment = child.data.parentId ? commentsMap[child.data.parentId] : undefined;
        if (child.kind === 't1') {
            // Sometimes MoreChildren API returns a comment that has already been seen.
            if (child.data.name === parentId) {
                continue;
            }
            const comment = new _a(child.data);
            commentsMap[comment.id] = comment;
            __classPrivateFieldSet(comment, _Comment_replies, __classPrivateFieldGet(_a, _a, "m", _Comment_getCommentsListing).call(_a, {
                ...options,
                postId: comment.postId,
                commentId: comment.id,
            }, depthOffset), "f");
            // Preload the comment's replies Listing
            if ('replyList' in child.data && child.data.replyList?.data) {
                const { children, more } = __classPrivateFieldGet(_a, _a, "m", _Comment_buildCommentsTree).call(_a, child.data.replyList.data.children, comment.id, options, depthOffset);
                if (children.length) {
                    comment.replies.children.push(...children);
                }
                if (more) {
                    comment.replies.setMore(more);
                }
            }
            // Since the replies for this comment were already load we can skip the first fetch call
            comment.replies.preventInitialFetch();
            if (parentComment) {
                parentComment.replies.children.push(comment);
            }
            else {
                children.push(comment);
            }
        }
        else if (child.kind === 'more' && child.data.parentId && child.data.depth != null) {
            const thisMore = {
                parentId: asTid(child.data.parentId),
                children: child.data.children ?? [],
                depth: child.data.depth,
            };
            if (parentComment) {
                parentComment.replies.setMore(thisMore);
            }
            else if (thisMore.parentId === parentId) {
                more = thisMore;
            }
        }
    }
    return { children, more };
}, _Comment_metadata_get = function _Comment_metadata_get() {
    return context.metadata;
};
