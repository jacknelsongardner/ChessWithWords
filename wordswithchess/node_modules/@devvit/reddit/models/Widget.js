var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _Widget_id, _Widget_name, _Widget_subredditName, _ImageWidget_images, _CalendarWidget_googleCalendarId, _CalendarWidget_configuration, _CalendarWidget_styles, _TextAreaWidget_text, _TextAreaWidget_styles, _ButtonWidget_buttons, _ButtonWidget_description, _ButtonWidget_styles, _CommunityListWidget_communities, _CommunityListWidget_styles, _PostFlairWidget_styles, _PostFlairWidget_templates, _PostFlairWidget_display, _CustomWidget_images, _CustomWidget_text, _CustomWidget_stylesheetUrl, _CustomWidget_height, _CustomWidget_css, _SubredditRulesWidget_rules;
import { CommunityListWidget_CommunityData as CommunityData, GetWidgetsResponse_WidgetItem as WidgetItem, } from '@devvit/protos';
import { context } from '@devvit/server';
import { assertNonNull } from '@devvit/shared-types/NonNull.js';
import { makeGettersEnumerable } from '../helpers/makeGettersEnumerable.js';
import { getRedditApiPlugins } from '../plugin.js';
function getMetadata() {
    return context.metadata;
}
export class Widget {
    constructor(widgetData, subredditName) {
        _Widget_id.set(this, void 0);
        _Widget_name.set(this, void 0);
        _Widget_subredditName.set(this, void 0);
        makeGettersEnumerable(this);
        __classPrivateFieldSet(this, _Widget_id, widgetData.id, "f");
        __classPrivateFieldSet(this, _Widget_name, widgetData.shortName, "f");
        __classPrivateFieldSet(this, _Widget_subredditName, subredditName, "f");
    }
    get id() {
        return __classPrivateFieldGet(this, _Widget_id, "f");
    }
    get name() {
        return __classPrivateFieldGet(this, _Widget_name, "f");
    }
    get subredditName() {
        return __classPrivateFieldGet(this, _Widget_subredditName, "f");
    }
    toJSON() {
        return {
            id: this.id,
            name: this.name,
            subredditName: this.subredditName,
        };
    }
    delete() {
        return Widget.delete(this.subredditName, this.id);
    }
    /**
     * @internal
     * @note - This method only returns the widgets listed on the sidebar.
     */
    static async getWidgets(subredditName) {
        const client = getRedditApiPlugins().Widgets;
        const response = await client.GetWidgets({
            subreddit: subredditName,
        }, getMetadata());
        assertNonNull(response.layout, 'Failed to load widgets for subreddit');
        const widgetsMap = response.items;
        const widgets = [];
        for (const widgetId of response.layout.sidebar?.order ?? []) {
            const widgetData = widgetsMap[widgetId];
            switch (widgetData?.kind) {
                case 'image':
                    widgets.push(new ImageWidget(widgetData, subredditName));
                    break;
                case 'calendar':
                    widgets.push(new CalendarWidget(widgetData, subredditName));
                    break;
                case 'textarea':
                    widgets.push(new TextAreaWidget(widgetData, subredditName));
                    break;
                case 'button':
                    widgets.push(new ButtonWidget(widgetData, subredditName));
                    break;
                case 'community-list':
                    widgets.push(new CommunityListWidget(widgetData, subredditName));
                    break;
                case 'post-flair':
                    widgets.push(new PostFlairWidget(widgetData, subredditName));
                    break;
                case 'custom':
                    widgets.push(new CustomWidget(widgetData, subredditName));
                    break;
                case 'subreddit-rules': {
                    // subreddit rule widget does not contain any data
                    // we need to fetch it separately
                    const rulesRsp = await getRedditApiPlugins().Subreddits.SubredditAboutRules({
                        subreddit: subredditName,
                    }, getMetadata());
                    widgets.push(new SubredditRulesWidget(rulesRsp, widgetData, subredditName));
                    break;
                }
                default:
                    throw new Error(`Unknown widget type: ${widgetData.kind}`);
            }
        }
        return widgets;
    }
    /** @internal */
    static async delete(subredditName, id) {
        const client = getRedditApiPlugins().Widgets;
        await client.DeleteWidget({
            subreddit: subredditName,
            id,
        }, getMetadata());
    }
    /** @internal */
    static async reorder(subredditName, orderByIds) {
        const client = getRedditApiPlugins().Widgets;
        await client.OrderWidgets({
            subreddit: subredditName,
            order: orderByIds,
        }, getMetadata());
    }
    /** @internal */
    static async add(widgetData) {
        switch (widgetData?.type) {
            case 'image':
                return ImageWidget.create(widgetData);
            case 'calendar':
                return CalendarWidget.create(widgetData);
            case 'textarea':
                return TextAreaWidget.create(widgetData);
            case 'button':
                return ButtonWidget.create(widgetData);
            case 'community-list':
                return CommunityListWidget.create(widgetData);
            case 'post-flair':
                return PostFlairWidget.create(widgetData);
            case 'custom':
                return CustomWidget.create(widgetData);
            default:
                throw new Error('Unknown widget type');
        }
    }
}
_Widget_id = new WeakMap(), _Widget_name = new WeakMap(), _Widget_subredditName = new WeakMap();
export class ImageWidget extends Widget {
    constructor(widgetData, subredditName) {
        super(widgetData, subredditName);
        _ImageWidget_images.set(this, void 0);
        __classPrivateFieldSet(this, _ImageWidget_images, widgetData.data.map((data) => {
            assertNonNull(data.url, 'Image widget data is missing url');
            assertNonNull(data.height, 'Image widget data is missing height');
            assertNonNull(data.width, 'Image widget data is missing width');
            assertNonNull(data.linkUrl, 'Image widget data is missing linkUrl');
            return {
                url: data.url,
                height: data.height,
                width: data.width,
                linkUrl: data.linkUrl,
            };
        }), "f");
    }
    get images() {
        return __classPrivateFieldGet(this, _ImageWidget_images, "f");
    }
    toJSON() {
        return {
            ...super.toJSON(),
            images: this.images,
        };
    }
    /** @internal */
    static async create(options) {
        const client = getRedditApiPlugins().Widgets;
        const response = await client.AddImageWidget(options, getMetadata());
        return new ImageWidget(WidgetItem.fromJSON(response), options.subreddit);
    }
    /** @internal */
    static async update(options) {
        const client = getRedditApiPlugins().Widgets;
        const response = await client.UpdateImageWidget(options, getMetadata());
        return new ImageWidget(WidgetItem.fromJSON(response), options.subreddit);
    }
}
_ImageWidget_images = new WeakMap();
export class CalendarWidget extends Widget {
    constructor(widgetData, subredditName) {
        super(widgetData, subredditName);
        _CalendarWidget_googleCalendarId.set(this, void 0);
        _CalendarWidget_configuration.set(this, void 0);
        _CalendarWidget_styles.set(this, void 0);
        assertNonNull(widgetData.googleCalendarId, 'Calendar widget data is missing googleCalendarId');
        assertNonNull(widgetData.configuration, 'Calendar widget data is missing configuration');
        assertNonNull(widgetData.styles, 'Calendar widget data is missing styles');
        __classPrivateFieldSet(this, _CalendarWidget_googleCalendarId, widgetData.googleCalendarId, "f");
        __classPrivateFieldSet(this, _CalendarWidget_configuration, widgetData.configuration, "f");
        __classPrivateFieldSet(this, _CalendarWidget_styles, widgetData.styles, "f");
    }
    get googleCalendarId() {
        return __classPrivateFieldGet(this, _CalendarWidget_googleCalendarId, "f");
    }
    get configuration() {
        return __classPrivateFieldGet(this, _CalendarWidget_configuration, "f");
    }
    get styles() {
        return __classPrivateFieldGet(this, _CalendarWidget_styles, "f");
    }
    toJSON() {
        return {
            ...super.toJSON(),
            googleCalendarId: this.googleCalendarId,
            configuration: this.configuration,
            styles: this.styles,
        };
    }
    /** @internal */
    static async create(options) {
        const client = getRedditApiPlugins().Widgets;
        const response = await client.AddCalendarWidget(options, getMetadata());
        return new CalendarWidget(WidgetItem.fromJSON(response), options.subreddit);
    }
    /** @internal */
    static async update(options) {
        const client = getRedditApiPlugins().Widgets;
        const response = await client.UpdateCalendarWidget(options, getMetadata());
        return new CalendarWidget(WidgetItem.fromJSON(response), options.subreddit);
    }
}
_CalendarWidget_googleCalendarId = new WeakMap(), _CalendarWidget_configuration = new WeakMap(), _CalendarWidget_styles = new WeakMap();
export class TextAreaWidget extends Widget {
    constructor(widgetData, subredditName) {
        super(widgetData, subredditName);
        _TextAreaWidget_text.set(this, void 0);
        _TextAreaWidget_styles.set(this, void 0);
        assertNonNull(widgetData.text, 'Textarea widget data is missing text');
        assertNonNull(widgetData.styles, 'Textarea widget data is missing styles');
        __classPrivateFieldSet(this, _TextAreaWidget_text, widgetData.text, "f");
        __classPrivateFieldSet(this, _TextAreaWidget_styles, widgetData.styles, "f");
    }
    get text() {
        return __classPrivateFieldGet(this, _TextAreaWidget_text, "f");
    }
    get styles() {
        return __classPrivateFieldGet(this, _TextAreaWidget_styles, "f");
    }
    toJSON() {
        return {
            ...super.toJSON(),
            text: this.text,
            styles: this.styles,
        };
    }
    /** @internal */
    static async create(options) {
        const client = getRedditApiPlugins().Widgets;
        const response = await client.AddTextAreaWidget(options, getMetadata());
        return new TextAreaWidget(WidgetItem.fromJSON(response), options.subreddit);
    }
    /** @internal */
    static async update(options) {
        const client = getRedditApiPlugins().Widgets;
        const response = await client.UpdateTextAreaWidget(options, getMetadata());
        return new TextAreaWidget(WidgetItem.fromJSON(response), options.subreddit);
    }
}
_TextAreaWidget_text = new WeakMap(), _TextAreaWidget_styles = new WeakMap();
export class ButtonWidget extends Widget {
    constructor(widgetData, subredditName) {
        super(widgetData, subredditName);
        _ButtonWidget_buttons.set(this, void 0);
        _ButtonWidget_description.set(this, void 0);
        _ButtonWidget_styles.set(this, void 0);
        assertNonNull(widgetData.styles, 'Button widget data is missing styles');
        __classPrivateFieldSet(this, _ButtonWidget_buttons, widgetData.buttons, "f");
        __classPrivateFieldSet(this, _ButtonWidget_description, widgetData.description ?? '', "f");
        __classPrivateFieldSet(this, _ButtonWidget_styles, widgetData.styles, "f");
    }
    get buttons() {
        return __classPrivateFieldGet(this, _ButtonWidget_buttons, "f");
    }
    get description() {
        return __classPrivateFieldGet(this, _ButtonWidget_description, "f");
    }
    get styles() {
        return __classPrivateFieldGet(this, _ButtonWidget_styles, "f");
    }
    toJSON() {
        return {
            ...super.toJSON(),
            buttons: this.buttons,
            description: this.description,
            styles: this.styles,
        };
    }
    /** @internal */
    static async create(options) {
        const client = getRedditApiPlugins().Widgets;
        const response = await client.AddButtonWidget(options, getMetadata());
        return new ButtonWidget(WidgetItem.fromJSON(response), options.subreddit);
    }
    /** @internal */
    static async update(options) {
        const client = getRedditApiPlugins().Widgets;
        const response = await client.UpdateButtonWidget(options, getMetadata());
        return new ButtonWidget(WidgetItem.fromJSON(response), options.subreddit);
    }
}
_ButtonWidget_buttons = new WeakMap(), _ButtonWidget_description = new WeakMap(), _ButtonWidget_styles = new WeakMap();
export class CommunityListWidget extends Widget {
    constructor(widgetData, subredditName) {
        super(widgetData, subredditName);
        _CommunityListWidget_communities.set(this, void 0);
        _CommunityListWidget_styles.set(this, void 0);
        __classPrivateFieldSet(this, _CommunityListWidget_communities, widgetData.data.map((communityData) => CommunityData.fromJSON(communityData)), "f");
        assertNonNull(widgetData.styles, 'Community list widget data is missing styles');
        __classPrivateFieldSet(this, _CommunityListWidget_styles, widgetData.styles, "f");
    }
    get communities() {
        return __classPrivateFieldGet(this, _CommunityListWidget_communities, "f");
    }
    get styles() {
        return __classPrivateFieldGet(this, _CommunityListWidget_styles, "f");
    }
    toJSON() {
        return {
            ...super.toJSON(),
            communities: this.communities,
            styles: this.styles,
        };
    }
    /** @internal */
    static async create(options) {
        const client = getRedditApiPlugins().Widgets;
        const response = await client.AddCommunityListWidget(options, getMetadata());
        return new CommunityListWidget(WidgetItem.fromJSON(response), options.subreddit);
    }
    /** @internal */
    static async update(options) {
        const client = getRedditApiPlugins().Widgets;
        const response = await client.UpdateCommunityListWidget(options, getMetadata());
        return new CommunityListWidget(WidgetItem.fromJSON(response), options.subreddit);
    }
}
_CommunityListWidget_communities = new WeakMap(), _CommunityListWidget_styles = new WeakMap();
export class PostFlairWidget extends Widget {
    constructor(widgetData, subredditName) {
        super(widgetData, subredditName);
        _PostFlairWidget_styles.set(this, void 0);
        _PostFlairWidget_templates.set(this, void 0);
        _PostFlairWidget_display.set(this, void 0);
        assertNonNull(widgetData.styles, 'Post flair widget data is missing styles');
        __classPrivateFieldSet(this, _PostFlairWidget_styles, widgetData.styles, "f");
        __classPrivateFieldSet(this, _PostFlairWidget_templates, widgetData.order.map((templateId) => widgetData.templates[templateId]), "f");
        if (!((widgetData.display && widgetData.display === 'list') || widgetData.display === 'cloud')) {
            throw new Error('Post flair widget data is missing display type');
        }
        __classPrivateFieldSet(this, _PostFlairWidget_display, widgetData.display, "f");
    }
    get styles() {
        return __classPrivateFieldGet(this, _PostFlairWidget_styles, "f");
    }
    get templates() {
        return __classPrivateFieldGet(this, _PostFlairWidget_templates, "f");
    }
    get display() {
        return __classPrivateFieldGet(this, _PostFlairWidget_display, "f");
    }
    toJSON() {
        return {
            ...super.toJSON(),
            styles: this.styles,
            templates: this.templates,
            display: this.display,
        };
    }
    /** @internal */
    static async create(options) {
        const client = getRedditApiPlugins().Widgets;
        const response = await client.AddPostFlairWidget(options, getMetadata());
        return new PostFlairWidget(WidgetItem.fromJSON(response), options.subreddit);
    }
    /** @internal */
    static async update(options) {
        const client = getRedditApiPlugins().Widgets;
        const response = await client.UpdatePostFlairWidget(options, getMetadata());
        return new PostFlairWidget(WidgetItem.fromJSON(response), options.subreddit);
    }
}
_PostFlairWidget_styles = new WeakMap(), _PostFlairWidget_templates = new WeakMap(), _PostFlairWidget_display = new WeakMap();
export class CustomWidget extends Widget {
    constructor(widgetData, subredditName) {
        super(widgetData, subredditName);
        _CustomWidget_images.set(this, void 0);
        _CustomWidget_text.set(this, void 0);
        _CustomWidget_stylesheetUrl.set(this, void 0);
        _CustomWidget_height.set(this, void 0);
        _CustomWidget_css.set(this, void 0);
        assertNonNull(widgetData.stylesheetUrl, 'Custom widget data is missing stylesheetUrl');
        assertNonNull(widgetData.height, 'Custom widget data is missing height');
        assertNonNull(widgetData.css, 'Custom widget data is missing css');
        __classPrivateFieldSet(this, _CustomWidget_images, widgetData.imageData ?? [], "f");
        __classPrivateFieldSet(this, _CustomWidget_text, widgetData.text ?? '', "f");
        __classPrivateFieldSet(this, _CustomWidget_stylesheetUrl, widgetData.stylesheetUrl, "f");
        __classPrivateFieldSet(this, _CustomWidget_height, widgetData.height, "f");
        __classPrivateFieldSet(this, _CustomWidget_css, widgetData.css, "f");
    }
    get images() {
        return __classPrivateFieldGet(this, _CustomWidget_images, "f");
    }
    get text() {
        return __classPrivateFieldGet(this, _CustomWidget_text, "f");
    }
    get stylesheetUrl() {
        return __classPrivateFieldGet(this, _CustomWidget_stylesheetUrl, "f");
    }
    get height() {
        return __classPrivateFieldGet(this, _CustomWidget_height, "f");
    }
    get css() {
        return __classPrivateFieldGet(this, _CustomWidget_css, "f");
    }
    toJSON() {
        return {
            ...super.toJSON(),
            images: this.images,
            text: this.text,
            stylesheetUrl: this.stylesheetUrl,
            height: this.height,
            css: this.css,
        };
    }
    /** @internal */
    static async create(options) {
        const client = getRedditApiPlugins().Widgets;
        const response = await client.AddCustomWidget(options, getMetadata());
        return new CustomWidget(WidgetItem.fromJSON(response), options.subreddit);
    }
    /** @internal */
    static async update(options) {
        const client = getRedditApiPlugins().Widgets;
        const response = await client.UpdateCustomWidget(options, getMetadata());
        return new CustomWidget(WidgetItem.fromJSON(response), options.subreddit);
    }
}
_CustomWidget_images = new WeakMap(), _CustomWidget_text = new WeakMap(), _CustomWidget_stylesheetUrl = new WeakMap(), _CustomWidget_height = new WeakMap(), _CustomWidget_css = new WeakMap();
export class SubredditRulesWidget extends Widget {
    constructor(subredditAboutRulesRsp, widgetData, subredditName) {
        super(widgetData, subredditName);
        _SubredditRulesWidget_rules.set(this, void 0);
        __classPrivateFieldSet(this, _SubredditRulesWidget_rules, subredditAboutRulesRsp.rules.map(({ description, priority, shortName, violationReason }) => {
            assertNonNull(description, 'Subreddit rule is missing description');
            assertNonNull(priority, 'Subreddit rule is missing priority');
            assertNonNull(shortName, 'Subreddit rule is missing shortName');
            assertNonNull(violationReason, 'Subreddit rule is missing violationReason');
            return {
                description,
                priority,
                shortName,
                violationReason,
            };
        }), "f");
    }
    get rules() {
        return __classPrivateFieldGet(this, _SubredditRulesWidget_rules, "f");
    }
    toJSON() {
        return {
            ...super.toJSON(),
            rules: this.rules,
        };
    }
}
_SubredditRulesWidget_rules = new WeakMap();
