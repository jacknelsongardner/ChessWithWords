var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var _a, _PrivateMessage_id, _PrivateMessage_from, _PrivateMessage_body, _PrivateMessage_bodyHtml, _PrivateMessage_created, _PrivateMessage_metadata_get;
import { context } from '@devvit/server';
import { assertNonNull } from '@devvit/shared-types/NonNull.js';
import { asTid, T2, T5 } from '@devvit/shared-types/tid.js';
import { makeGettersEnumerable } from '../helpers/makeGettersEnumerable.js';
import { getRedditApiPlugins } from '../plugin.js';
import { Listing } from './Listing.js';
export class PrivateMessage {
    /** @internal */
    static async getMessages(options) {
        const client = getRedditApiPlugins().PrivateMessages;
        return new Listing({
            ...options,
            fetch: async (fetchOpts) => {
                const listing = await client.MessageWhere({
                    ...fetchOpts,
                    where: options.type ?? 'inbox',
                }, __classPrivateFieldGet(this, _a, "a", _PrivateMessage_metadata_get));
                return {
                    after: listing.data?.after,
                    before: listing.data?.before,
                    children: (listing.data?.children
                        ?.map((child) => {
                        return new _a(child.data);
                    })
                        .filter(Boolean) || []),
                };
            },
        });
    }
    /** @internal */
    static async send({ to, subject, text }) {
        const client = getRedditApiPlugins().PrivateMessages;
        await client.Compose({
            to,
            subject,
            text,
            fromSr: '',
        }, __classPrivateFieldGet(this, _a, "a", _PrivateMessage_metadata_get));
    }
    /** @internal */
    static async sendAsSubreddit({ to, fromSubredditName, subject, text, }) {
        const client = getRedditApiPlugins().PrivateMessages;
        await client.Compose({
            to,
            fromSr: fromSubredditName,
            subject,
            text,
        }, __classPrivateFieldGet(this, _a, "a", _PrivateMessage_metadata_get));
    }
    /** @internal */
    static async markAllAsRead() {
        const client = getRedditApiPlugins().PrivateMessages;
        await client.ReadAllMessages({ filterTypes: '' }, __classPrivateFieldGet(this, _a, "a", _PrivateMessage_metadata_get));
    }
    /**
     * @internal
     */
    constructor(data) {
        _PrivateMessage_id.set(this, void 0);
        _PrivateMessage_from.set(this, void 0);
        _PrivateMessage_body.set(this, void 0);
        _PrivateMessage_bodyHtml.set(this, void 0);
        _PrivateMessage_created.set(this, void 0);
        makeGettersEnumerable(this);
        assertNonNull(data.id, 'PrivateMessage: Invalid data, no id');
        assertNonNull(data.name, 'PrivateMessage: Invalid data, no name');
        assertNonNull(data.created, 'PrivateMessage: Invalid data, no created date');
        __classPrivateFieldSet(this, _PrivateMessage_id, asTid(data.name), "f");
        if (data.author != null) {
            __classPrivateFieldSet(this, _PrivateMessage_from, {
                type: 'user',
                username: data.author,
                id: data.authorFullname ? T2(data.authorFullname) : undefined,
            }, "f");
        }
        else if (data.subreddit != null) {
            __classPrivateFieldSet(this, _PrivateMessage_from, {
                type: 'subreddit',
                name: data.subreddit,
                id: data.subredditId ? T5(data.subredditId) : undefined,
            }, "f");
        }
        else {
            throw new Error('PrivateMessage: Invalid data, no author or subreddit');
        }
        __classPrivateFieldSet(this, _PrivateMessage_body, data.body ?? '', "f");
        __classPrivateFieldSet(this, _PrivateMessage_bodyHtml, data.bodyHtml ?? '', "f");
        const created = new Date(0);
        created.setUTCSeconds(data.createdUtc);
        __classPrivateFieldSet(this, _PrivateMessage_created, created, "f");
    }
    get id() {
        return __classPrivateFieldGet(this, _PrivateMessage_id, "f");
    }
    get from() {
        return __classPrivateFieldGet(this, _PrivateMessage_from, "f");
    }
    get body() {
        return __classPrivateFieldGet(this, _PrivateMessage_body, "f");
    }
    get bodyHtml() {
        return __classPrivateFieldGet(this, _PrivateMessage_bodyHtml, "f");
    }
    get created() {
        return __classPrivateFieldGet(this, _PrivateMessage_created, "f");
    }
    async markAsRead() {
        const client = getRedditApiPlugins().PrivateMessages;
        await client.ReadMessage({ id: __classPrivateFieldGet(this, _PrivateMessage_id, "f") }, context.metadata);
    }
}
_a = PrivateMessage, _PrivateMessage_id = new WeakMap(), _PrivateMessage_from = new WeakMap(), _PrivateMessage_body = new WeakMap(), _PrivateMessage_bodyHtml = new WeakMap(), _PrivateMessage_created = new WeakMap(), _PrivateMessage_metadata_get = function _PrivateMessage_metadata_get() {
    return context.metadata;
};
